<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>olca.ipc API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>olca.ipc</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import logging as log
import os

import requests
import olca.schema as schema
import olca.upstream_tree as utree

from dataclasses import dataclass

from typing import Any, Iterator, List, Optional, Type, TypeVar, Union

E = TypeVar(&#39;E&#39;, bound=schema.RootEntity)
ModelType = Union[Type[E], str]


def _model_type(param: ModelType) -&gt; str:
    &#34;&#34;&#34;Get the @type tag for a JSON request.&#34;&#34;&#34;
    if isinstance(param, str):
        return param
    else:
        return param.__name__


def _model_class(param: ModelType) -&gt; Type[schema.RootEntity]:
    if isinstance(param, str):
        return schema.__dict__[param]
    else:
        return param


@dataclass
class ProductResult(schema.Entity):
    &#34;&#34;&#34;
    The ProductResult type is not an olca-schema type but a return
    type of the IPC protocol. However, it implements the same interface
    as the olca.schema.Entity type.

    Attributes:
    -----------
    process: olca.schema.Ref

    product: olca.schema.Ref

    amount: float

    &#34;&#34;&#34;
    process: Optional[schema.Ref] = None
    product: Optional[schema.Ref] = None
    amount: Optional[float] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ProductResult, self).to_json()
        if self.process is not None:
            json[&#39;process&#39;] = self.process.to_json()
        if self.product is not None:
            json[&#39;product&#39;] = self.product.to_json()
        if self.amount is not None:
            json[&#39;amount&#39;] = self.amount
        return json

    def read_json(self, json: dict):
        super(ProductResult, self).read_json(json)
        val = json.get(&#39;process&#39;)
        if val is not None:
            self.process = schema.Ref.from_json(val)
        val = json.get(&#39;product&#39;)
        if val is not None:
            self.product = schema.Ref.from_json(val)
        val = json.get(&#39;amount&#39;)
        if val is not None:
            self.amount = val

    @staticmethod
    def from_json(json: dict):
        instance = ProductResult()
        instance.read_json(json)
        return instance


@dataclass
class ContributionItem(schema.Entity):
    &#34;&#34;&#34;
    The ContributionItem type is not an olca-schema type but a return
    type of the IPC protocol. However, it implements the same interface
    as the olca.schema.Entity type.

    Attributes:
    -----------
    item: olca.schema.Ref

    amount: float

    share: float

    rest: bool

    unit: str

    &#34;&#34;&#34;

    item: Optional[schema.Ref] = None
    amount: Optional[float] = None
    share: Optional[float] = None
    rest: Optional[bool] = None
    unit: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ContributionItem, self).to_json()
        if self.item is not None:
            json[&#39;item&#39;] = self.item.to_json()
        if self.amount is not None:
            json[&#39;amount&#39;] = self.amount
        if self.share is not None:
            json[&#39;share&#39;] = self.share
        if self.rest is not None:
            json[&#39;rest&#39;] = self.rest
        if self.unit is not None:
            json[&#39;unit&#39;] = self.unit
        return json

    def read_json(self, json: dict):
        super(ContributionItem, self).read_json(json)
        val = json.get(&#39;item&#39;)
        if val is not None:
            self.item = schema.Ref.from_json(val)
        val = json.get(&#39;amount&#39;)
        if val is not None:
            self.amount = val
        val = json.get(&#39;share&#39;)
        if val is not None:
            self.share = val
        val = json.get(&#39;rest&#39;)
        if val is not None:
            self.rest = val
        val = json.get(&#39;unit&#39;)
        if val is not None:
            self.unit = val

    @staticmethod
    def from_json(json: dict):
        instance = ContributionItem()
        instance.read_json(json)
        return instance


class Client(object):
    &#34;&#34;&#34;
    A client to communicate with an openLCA IPC server.

    An openLCA IPC server is always connected to a database and operations
    that are executed via this client are thus executed on that database.

    Parameters
    ----------

    port: int, optional
        The port of the server connection; optional, defaults to 8080.
    &#34;&#34;&#34;

    def __init__(self, port: int = 8080):
        self.url = &#39;http://localhost:%i&#39; % port
        self.next_id = 1

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        return

    def close(self):
        return

    def insert(self, model: E):
        &#34;&#34;&#34;
        Inserts the given model into the database of the IPC server.

        Example
        -------
        ```python
        import olca
        import uuid

        flow = olca.Flow()
        flow.name = &#39;CO2&#39;
        flow.id = str(uuid.uuid4())
        flow.flow_type = olca.FlowType.ELEMENTARY_FLOW
        prop = olca.FlowPropertyFactor()
        prop.flow_property = olca.ref(
            olca.FlowProperty,
            &#39;93a60a56-a3c8-11da-a746-0800200b9a66&#39;,
            &#39;Mass&#39;
        )
        prop.conversion_factor = 1.0
        prop.reference_flow_property = True
        flow.flow_properties = [prop]
        response = olca.Client().insert(flow)
        print(response)
        ```

        &#34;&#34;&#34;
        if model is None:
            return
        json = model.to_json()
        resp, err = self.__post(&#39;insert/model&#39;, json)
        if err:
            log.error(&#39;failed to insert model: %s&#39;, err)
            return err
        return resp

    def update(self, model: E):
        &#34;&#34;&#34;
        Update the given model in the database of the IPC server.
        &#34;&#34;&#34;
        if model is None:
            return
        json = model.to_json()
        resp, err = self.__post(&#39;update/model&#39;, json)
        if err:
            log.error(&#39;failed to update model: %s&#39;, err)
            return err
        return resp

    def delete(self, model: E):
        &#34;&#34;&#34;
        Delete the given model from the database of the IPC server.
        &#34;&#34;&#34;
        if model is None:
            return
        json = model.to_json()
        resp, err = self.__post(&#39;delete/model&#39;, json)
        if err:
            log.error(&#39;failed to delete model: %s&#39;, err)
            return err
        return resp

    def calculate(self, setup: schema.CalculationSetup) -&gt; schema.SimpleResult:
        &#34;&#34;&#34;
        Calculates a result for the given calculation setup.

        Parameters
        ----------

        setup: olca.schema.CalculationSetup
            The setup of the calculation.

        Example
        -------
        ```python
        client = olca.Client()
        setup = olca.CalculationSetup()
        setup.calculation_type = olca.CalculationType.UPSTREAM_ANALYSIS
        setup.product_system = olca.ref(
            olca.ProductSystem,
            &#39;91c2c4a5-2d9d-482e-8c8c-678d7e1b9f55&#39;
        )
        setup.impact_method = olca.ref(
            olca.ImpactMethod,
            &#39;d2c781ce-21b4-3218-8fca-78133f2c8d4d&#39;
        )
        setup.amount = 1.0
        result = client.calculate(setup)
        # do something with the result
        # you should always dispose the result when you
        # do not need it anymore to avoid memory leaks.
        client.dispose(result)
        ```
        &#34;&#34;&#34;
        resp, err = self.__post(&#39;calculate&#39;, setup.to_json())
        if err:
            log.error(&#39;calculation failed: %s&#39;, err)
            return schema.SimpleResult()
        return schema.SimpleResult.from_json(resp)

    def simulator(self, setup: schema.CalculationSetup) -&gt; schema.Ref:
        &#34;&#34;&#34;
        Create a simulator to run Monte-Carlo simulations for the given setup.

        Parameters
        ----------

        setup: olca.schema.CalculationSetup
            The calculation setup that should be used.

        Returns
        -------

        olca.schema.Ref
            A reference to an simulator instance.

        Example
        -------
        ```python
        import olca

        client = olca.Client()
        # creating the calculation setup
        setup = olca.CalculationSetup()
        setup.calculation_type = olca.CalculationType.MONTE_CARLO_SIMULATION
        setup.impact_method = client.find(olca.ImpactMethod, &#39;TRACI [v2.1, February 2014]&#39;)
        setup.product_system = client.find(olca.ProductSystem, &#39;compost plant, open&#39;)
        setup.amount = 1.0

        # create the simulator
        simulator = client.simulator(setup)

        for i in range(0, 10):
            result = client.next_simulation(simulator)
            first_impact = result.impact_results[0]
            print(&#39;iteration %i: result for %s = %4.4f&#39; %
                  (i, first_impact.impact_category.name, first_impact.value))
            # we do not have to dispose the result here (it is not cached
            # in openLCA); but we need to dispose the simulator later (see below)

        # export the complete result of all simulations
        client.excel_export(simulator, &#39;simulation_result.xlsx&#39;)

        # the result remains accessible (for exports etc.) until
        # you dispose it, which you should always do when you do
        # not need it anymore
        client.dispose(simulator)
        ```
        &#34;&#34;&#34;
        resp, err = self.__post(&#39;simulator&#39;, setup.to_json())
        if err:
            log.error(&#39;failed to create simulator: %s&#39;, err)
            return schema.Ref()
        return schema.Ref.from_json(resp)

    def next_simulation(self, simulator: schema.Ref) -&gt; schema.SimpleResult:
        &#34;&#34;&#34;
        Runs the next Monte-Carlo simulation with the given simulator reference.
        It returns the result of the simulation. Note that this result is not
        cached (the simulator is cached).
        See [the simulator example](#olca.ipc.Client.simulator).

        Parameters
        ----------
        simulator: olca.schema.Ref
            The reference to the simulator which is called to run the next
            simulation step.

        &#34;&#34;&#34;
        if simulator is None:
            raise ValueError(&#39;No simulator given&#39;)
        resp, err = self.__post(&#39;next/simulation&#39;, simulator.to_json())
        if err:
            log.error(&#39;failed to get simulation result: %s&#39;, err)
            return schema.SimpleResult()
        return schema.SimpleResult.from_json(resp)

    def get_descriptors(self, model_type: ModelType) -&gt; Iterator[schema.Ref]:
        &#34;&#34;&#34;
        Get the descriptors of the entities with the type from the database.

        Parameters
        ----------
        model_type: ModelType
            The model type, e.g. olca.Flow or `&#39;Flow&#39;`

        Returns
        -------
        Iterator[schema.Ref]
            An iterator with Ref objects.

        Example:
        --------
        ```python
        import olca

        with olca.Client() as client:
            for a in client.get_descriptors(&#39;Actor&#39;):
                print(&#39;found Actor: %s&#39; % a.name)
            for s in client.get_descriptors(olca.Source):
                print(&#39;found Source: %s&#39; % s.name)
        ```

        &#34;&#34;&#34;
        params = {&#39;@type&#39;: _model_type(model_type)}
        result, err = self.__post(&#39;get/descriptors&#39;, params)
        if err:
            log.error(&#39;failed to get descriptors of type %s: %s&#39;,
                      model_type, err)
            return []
        for r in result:
            yield schema.Ref.from_json(r)

    def get_descriptor(self, model_type: ModelType,
                       uid=&#39;&#39;, name=&#39;&#39;) -&gt; Optional[schema.Ref]:
        &#34;&#34;&#34;
        Get a descriptor of the model with the given ID or name from the database.

        Models like product systems can be very large but often we just need
        a reference to a model (e.g. in a calculation setup). In this case
        this method can be useful.

        since: openLCA 2.0

        Parameters
        ----------
        model_type: ModelType
            The type of the model, e.g. olca.ProductSystem or `&#39;ProductSystem&#39;`
        uid: str, optional
            The ID of the model.
        name: str, optional
            The name of the model.

        Returns
        -------
        schema.Ref
            The descriptor of the model.

        Example
        -------
        ```python
        import olca

        client = olca.Client()
        system_ref = client.get_descriptor(
            olca.ProductSystem,
            &#39;f50ee15a-968f-4316-a160-4c7741284c62&#39;)
        print(system_ref.to_json())
        ```
        &#34;&#34;&#34;

        params = {&#39;@type&#39;: _model_type(model_type)}
        if uid != &#39;&#39;:
            params[&#39;@id&#39;] = uid
        if name != &#39;&#39;:
            params[&#39;name&#39;] = name
        result, err = self.__post(&#39;get/descriptor&#39;, params)
        if err:
            log.error(&#39;failed to get descriptor: %s&#39;, err)
            return None
        return schema.Ref.from_json(result)

    def get(self, model_type: Type[E],
            uid=&#39;&#39;, name=&#39;&#39;) -&gt; Optional[E]:
        params = {&#39;@type&#39;: _model_type(model_type)}
        if uid != &#39;&#39;:
            params[&#39;@id&#39;] = uid
        if name != &#39;&#39;:
            params[&#39;name&#39;] = name
        result, err = self.__post(&#39;get/model&#39;, params)
        if err:
            log.error(&#39;failed to get entity of type %s: %s&#39;,
                      model_type, err)
            return None
        return _model_class(model_type).from_json(result)

    def get_all(self, model_type: Type[E]) -&gt; Iterator[E]:
        &#34;&#34;&#34;
        Returns a generator for all instances of the given type from the
        database. Note that this will first fetch the complete JSON list from
        the IPC server and thus should be only used when a small amount of
        instances is expected as return value.

        Example
        -------
        ```python
        import olca

        client = olca.Client()
        currencies = client.get_all(olca.Currency)
        for c in currencies:
            print(c.name)
        ```
        &#34;&#34;&#34;
        params = {&#39;@type&#39;: model_type.__name__}
        result, err = self.__post(&#39;get/models&#39;, params)
        if err:
            log.error(&#39;failed to get all of type %s: %s&#39;,
                      model_type, err)
        clazz = _model_class(model_type)
        for r in result:
            yield clazz.from_json(r)

    def find(self, model_type: ModelType, name: str) -&gt; Optional[schema.Ref]:
        &#34;&#34;&#34;Searches for a data set with the given type and name.

        :param model_type: The class of the data set, e.g. `olca.Flow`.
        :param name: The name of the data set.
        :return: The reference to the first data set with the given name and
                 type from the databases or ``None`` if there is no such data
                 set in the database.
        &#34;&#34;&#34;
        for d in self.get_descriptors(model_type):
            if d.name == name:
                return d

    def get_providers_of(self, flow: Union[schema.Ref, schema.Flow]) \
            -&gt; Iterator[schema.Ref]:
        &#34;&#34;&#34;
        Get the providers for the given flow.

        For products, these are the processes that have an output of the given
        product. For waste flows, these are the waste treatment processes that
        have this flow on the input side. Elementary flows do not have a
        provider.

        Parameters
        ----------
        flow: Union[schema.Ref, schema.Flow]
            The flow or reference to the flow for which the providers should be
            returned.

        Example
        -------
        ```python
        steel = client.get(&#39;Flow&#39;, &#39;Steel&#39;)
        for provider in client.get_providers_of(steel):
            print(provider.name)
        ```
        &#34;&#34;&#34;
        params = {
            &#39;@type&#39;: &#39;Flow&#39;,
            &#39;@id&#39;: flow.id,
            &#39;name&#39;: flow.name,
        }
        providers, err = self.__post(&#39;get/providers&#39;, params)
        if err:
            log.error(&#39;failed to get providers: %s&#39;, err)
            return []
        for obj in providers:
            yield schema.Ref.from_json(obj)

    def excel_export(self, result: schema.SimpleResult, path: str):
        &#34;&#34;&#34;Export the given result to an Excel file with the given path.

        :param result: The result that should be exported.
        :param path: The path of the Excel file to which the result should be
                     written.
        &#34;&#34;&#34;
        abs_path = os.path.abspath(path)
        params = {
            &#39;@id&#39;: result.id,
            &#39;path&#39;: abs_path
        }
        _, err = self.__post(&#39;export/excel&#39;, params)
        if err:
            log.error(&#39;Excel export to %s failed: %s&#39;, path, err)

    def dispose(self, entity: schema.Entity):
        &#34;&#34;&#34;
        Removes the given entity from the memory of the IPC server.

        This is required for calculation results that are hold on the server for
        further processing.

        Parameters
        ----------

        entity: olca.schema.Entity
            The entity that should be disposed (typically a result).

        Example
        -------
        ```python
        client = olca.Client()
        setup = olca.CalculationSetup()
        setup.calculation_type = olca.CalculationType.UPSTREAM_ANALYSIS
        setup.product_system = olca.ref(
          olca.ProductSystem,
          &#39;7d1cbce0-b5b3-47ba-95b5-014ab3c7f569&#39;
        )
        setup.amount = 1.0
        result = client.calculate(setup)
        # do something with the result
        # ...
        response = client.dispose(result)
        print(response)  # should print `ok`
        ```
        &#34;&#34;&#34;
        if entity is None:
            return
        arg = {&#39;@type&#39;: type(entity).__name__, &#39;@id&#39;: entity.id}
        _, err = self.__post(&#39;dispose&#39;, arg)
        if err:
            log.error(&#39;failed to dispose object: %s&#39;, err)

    def shutdown_server(self):
        &#34;&#34;&#34;
        Close the database and shutdown the server.

        This method is probably most useful when running a headless server
        (a server without openLCA user interface).
        &#34;&#34;&#34;
        _, err = self.__post(&#39;runtime/shutdown&#39;, None)
        if err:
            log.error(&#39;failed to shutdown server: %s&#39;, err)

    def create_product_system(self, process_id: str, default_providers=&#39;prefer&#39;,
                              preferred_type=&#39;LCI_RESULT&#39;) -&gt; Optional[schema.Ref]:
        &#34;&#34;&#34;
        Creates a product system from the process with the given ID.

        Parameters
        ----------

        process_id: str
            The ID of the process from which the product system should be
            generated. This will be the reference process of the product system
            with upstream and downstream processes added recursively.

        default_providers: {&#39;prefer&#39;, &#39;ignore&#39;, &#39;only&#39;}, optional
            Indicates how default providers of product inputs and waste outputs
            should be considered during the linking. `only` means that only
            product inputs and waste outputs should be linked that have a
            default provider and that this default provider is used. `prefer`
            means that a default provider is used during the linking if there
            are multiple options. `ignore` means that the default providers
            have no specific role.

        preferred_type : {&#39;LCI_RESULT&#39;, &#39;UNIT_PROCESS&#39;}, optional
            When there are multiple provider processes available for linking a
            product input or waste output the `preferred_type` indicates which
            type of process (LCI results or unit processes) should be preferred
            during the linking.

        Returns
        -------

        olca.schema.Ref
            A descriptor of the created product system.

        Example
        -------

        ```python
        import olca

        client = olca.Client(8080)
        process_id = &#39;4aee0b0c-eb46-37f1-8c7a-7e5b1adfd014&#39;
        ref = client.create_product_system(process_id)
        print(&#39;Created product system %s&#39; % ref.id)
        ```
        &#34;&#34;&#34;

        r, err = self.__post(&#39;create/product_system&#39;, {
            &#39;processId&#39;: process_id,
            &#39;preferredType&#39;: preferred_type,
            &#39;providerLinking&#39;: default_providers,
        })
        if err:
            log.error(&#39;failed to create product system: %s&#39;, err)
            return None
        return schema.Ref.from_json(r)

    def lci_inputs(self, result: schema.SimpleResult) -&gt; List[schema.FlowResult]:
        &#34;&#34;&#34;
        Returns the inputs of the given inventory result.

        Example
        -------
        ```python
        result = client.calculate(setup)
        # print the first input
        print(client.lci_inputs(result)[0])
        client.dispose(result)
        ```
        &#34;&#34;&#34;
        raw, err = self.__post(&#39;get/inventory/inputs&#39;, {
            &#39;resultId&#39;: result.id,
        })
        if err:
            log.error(&#39;failed to get LCI inputs&#39;)
            return []
        return [schema.FlowResult.from_json(it) for it in raw]

    def lci_outputs(self, result: schema.SimpleResult) -&gt; List[dict]:
        &#34;&#34;&#34;
        Returns the outputs of the given inventory result.

        Example
        -------
        ```python
        result = client.calculate(setup)
        # print the first output
        print(client.lci_outputs(result)[0])
        client.dispose(result)
        ```
        &#34;&#34;&#34;
        raw, err = self.__post(&#39;get/inventory/outputs&#39;, {
            &#39;resultId&#39;: result.id,
        })
        if err:
            log.error(&#39;failed to get LCI outputs: %s&#39;, err)
            return []
        return [schema.FlowResult.from_json(it) for it in raw]

    def lci_location_contributions(self, result: schema.SimpleResult,
                                   flow: schema.Ref) -&gt; List[ContributionItem]:
        &#34;&#34;&#34;
        Get the contributions of the result of the given flow by location.

        Parameters
        ----------
        result: olca.schema.SimpleResult
            The result which needs to be at least a contribution result.

        flow: olca.schema.Ref
            The (reference of the) flow for which the calculations should be
            calculated.

        Returns
        -------
        list[ContributionItem]
            The contributions to the flow result by location.

        Example
        -------
        ```python
        # ...
        result = client.calculate(setup)
        # select the first output of the LCI result
        output = client.lci_outputs(result)[0]
        # calculate the location contributions of the flow of that output
        cons = client.lci_location_contributions(result, output.flow)
        # ...
        client.dispose(result)
        ```
        &#34;&#34;&#34;
        raw, err = self.__post(&#39;get/inventory/contributions/locations&#39;, {
            &#39;resultId&#39;: result.id,
            &#39;flow&#39;: flow.to_json(),
        })
        if err:
            log.error(&#39;failed to ger contributions by location&#39;)
            return []
        return [ContributionItem.from_json(it) for it in raw]

    def lci_total_requirements(self, result: schema.SimpleResult) -&gt; List[ProductResult]:
        &#34;&#34;&#34;
        Returns the total requirements of the given result.

        The total requirements are the product amounts that are required to
        fulfill the demand of the product system. As our technology matrix
        \\(A\\) is indexed symmetrically (means rows and columns refer to the
        same process-product pair) our product amounts are on the diagonal of
        the technology matrix and the total requirements can be calculated by
        the following equation where \\(s\\) is the scaling vector (
        \\(\\odot\\) denotes element-wise multiplication):

        $$t = diag(A) \odot s$$

        Parameters
        ----------
        result: olca.schema.SimpleResult
            The simple result from which the total requirements should be
            returned.

        Example
        -------
        ```python
        import olca

        client = olca.Client()
        setup = olca.CalculationSetup()
        setup.calculation_type = olca.CalculationType.UPSTREAM_ANALYSIS
        setup.product_system = olca.ref(
            olca.ProductSystem,
            &#39;7d1cbce0-b5b3-47ba-95b5-014ab3c7f569&#39;
        )
        setup.amount = 1.0
        result = client.calculate(setup)
        print(client.lci_total_requirements(result)[0])
        client.dispose(result)
        ```
        &#34;&#34;&#34;

        raw, err = self.__post(&#39;get/inventory/total_requirements&#39;, {
            &#39;resultId&#39;: result.id
        })
        if err:
            log.error(&#39;failed to get total requirements %s&#39;, err)
            return []
        return [ProductResult.from_json(it) for it in raw]

    def lcia(self, result: schema.SimpleResult) -&gt; List[schema.ImpactResult]:
        &#34;&#34;&#34;
        Returns the LCIA result of the given result.

        Parameters
        ----------
        result: olca.schema.SimpleResult
            The result from which the LCIA result should be returned.

        Example
        -------
        ```python
        # ...
        result = client.calculate(setup)
        lcia = client.lcia(result)
        # ...
        client.dispose(result)
        ```
        &#34;&#34;&#34;

        raw, err = self.__post(&#39;get/impacts&#39;, {
            &#39;resultId&#39;: result.id,
        })
        if err:
            log.error(&#39;failed to get impact results: %s&#39;, err)
            return []
        return [schema.ImpactResult.from_json(it) for it in raw]

    def lcia_flow_contributions(self, result: schema.SimpleResult,
                                impact: schema.Ref) -&gt; List[ContributionItem]:
        &#34;&#34;&#34;
        Get the flow contributions to the result of the given impact category.

        Parameters
        ----------
        result: olca.schema.SimpleResult
            The result.

        impact: olca.schema.Ref
            The (reference to the) LCIA category.

        Example
        -------
        ```python
        # ...
        result = client.calculate(setup)
        # select the first LCIA result
        impact_result = client.lcia(result)[0]
        # get the flow contributions to the LCIA category of that result
        cons = client.lcia_flow_contributions(
            result, impact_result.impact_category)
        # ...
        client.dispose(result)
        ```
        &#34;&#34;&#34;

        raw, err = self.__post(&#39;get/impacts/contributions/flows&#39;, {
            &#39;resultId&#39;: result.id,
            &#39;impactCategory&#39;: impact.to_json(),
        })
        if err:
            log.error(&#39;failed to get contribution items: %s&#39;, err)
            return []
        return [ContributionItem.from_json(it) for it in raw]

    def lcia_location_contributions(self, result: schema.SimpleResult,
                                    impact: schema.Ref) -&gt; List[ContributionItem]:
        &#34;&#34;&#34;
        Get the contributions to the result of the given impact category by
        locations.

        Parameters
        ----------
        result: olca.schema.SimpleResult
            The result.

        impact: olca.schema.Ref
            The (reference to the) LCIA category.


        Example
        -------
        ```python
        # ...
        result = client.calculate(setup)
        # select the first LCIA result
        impact_result = client.lcia(result)[0]
        # get the flow contributions to the LCIA category of that result
        cons = client.lcia_location_contributions(
            result, impact_result.impact_category)
        # ...
        client.dispose(result)
        ```
        &#34;&#34;&#34;

        raw, err = self.__post(&#39;get/impacts/contributions/locations&#39;, {
            &#39;resultId&#39;: result.id,
            &#39;impactCategory&#39;: impact.to_json(),
        })
        if err:
            log.error(&#39;Failed to get contribution items: %s&#39;, err)
            return []
        return [ContributionItem.from_json(it) for it in raw]

    def lcia_process_contributions(self, result: schema.SimpleResult,
                                   impact: schema.Ref) -&gt; List[ContributionItem]:
        &#34;&#34;&#34;
        Get the contributions to the result of the given impact category by
        processes.

        Parameters
        ----------
        result: olca.schema.SimpleResult
            The result.

        impact: olca.schema.Ref
            The (reference to the) LCIA category.


        Example
        -------
        ```python
        # ...
        result = client.calculate(setup)
        # select the first LCIA result
        impact_result = client.lcia(result)[0]
        # get the flow contributions to the LCIA category of that result
        cons = client.lcia_process_contributions(
            result, impact_result.impact_category)
        # ...
        client.dispose(result)
        ```
        &#34;&#34;&#34;

        raw, err = self.__post(&#39;get/impacts/contributions/processes&#39;, {
            &#39;resultId&#39;: result.id,
            &#39;impactCategory&#39;: impact.to_json(),
        })
        if err:
            log.error(&#39;Failed to get contribution items: %s&#39;, err)
            return []
        return [ContributionItem.from_json(it) for it in raw]

    def upstream_tree_of(self, result: schema.SimpleResult, ref: schema.Ref,
                         max_depth=5, min_contribution=0.1,
                         max_recursion_depth=3) -&gt; Optional[utree.UpstreamTree]:
        &#34;&#34;&#34;
        Get an upstream tree for an impact category or flow.

        This function is only available in openLCA 2.x.

        Parameters
        ----------
        result: olca.schema.SimpleResult
            The previously calculated result. This needs to be an upstream
            result.

        ref: olca.schema.Ref
            The result reference of the upstream tree: a flow or impact
            category reference.

        max_depth: int
            The maximum number of levels of the tree. A value &lt; 0 means
            unlimited. In this case reasonable recursion limits are
            required if the underlying product system has cycles.

        min_contribution: float
            In addition to the maximum tree depth, this parameter describes
            the minimum upstream contribution of a node in the tree. A value
            &lt; 0 means that there is no minimum contribution.

        max_recursion_depth: int
            When the max. tree depth is unlimited and the underlying product
            system has cycles, this parameter indicates how often a process
            can occur in a tree path. It defines the maximum number of
            expansions of a loop in a tree path.

        Example
        -------
        ```python
        client = olca.Client()

        # create the calculation setup and run the calculation
        setup = olca.CalculationSetup()
        setup.calculation_type = olca.CalculationType.UPSTREAM_ANALYSIS
        setup.product_system = olca.ref(
            olca.ProductSystem,
            &#39;7d1cbce0-b5b3-47ba-95b5-014ab3c7f569&#39;
        )
        setup.impact_method = olca.ref(
            olca.ImpactMethod,
            &#39;99b9d86b-ec6f-4610-ba9f-68ebfe5691dd&#39;
        )
        setup.amount = 1.0
        result = client.calculate(setup)

        # calculate the upstream tree and traverse it
        impact = olca.ref(
            olca.ImpactCategory,
            &#39;2a26b243-23cb-4f90-baab-239d3d7397fa&#39;)
        tree = client.upstream_tree_of(result, impact)

        def traversal_handler(n: tuple[UpstreamNode, int]):
            (node, depth) = n
            print(&#39;%s+ %s %.3f&#39; % (
                &#39;  &#39; * depth,
                node.product.process.name,
                node.result
            ))

        tree.traverse(traversal_handler)

        # dispose the result
        client.dispose(result)
        ```
        &#34;&#34;&#34;
        raw, err = self.__post(&#39;get/upstream/tree&#39;, {
            &#39;resultId&#39;: result.id,
            &#39;ref&#39;: ref.to_json(),
            &#39;maxDepth&#39;: max_depth,
            &#39;minContribution&#39;: min_contribution,
            &#39;maxRecursionDepth&#39;: max_recursion_depth
        })
        if err:
            log.error(&#39;Failed to get upstream tree: %s&#39;, err)
            return None
        return utree.UpstreamTree.from_json(raw)

    def __post(self, method: str, params) -&gt; tuple[Any, Optional[str]]:
        &#34;&#34;&#34;
        Performs a request with the given parameters.

        It returns a tuple (result, error).
        &#34;&#34;&#34;
        req = {
            &#39;jsonrpc&#39;: &#39;2.0&#39;,
            &#39;id&#39;: self.next_id,
            &#39;method&#39;: method,
            &#39;params&#39;: params
        }
        self.next_id += 1
        resp = requests.post(self.url, json=req).json()  # type: dict
        err = resp.get(&#39;error&#39;)  # type: dict
        if err is not None:
            err_msg = &#39;%i: %s&#39; % (err.get(&#39;code&#39;), err.get(&#39;message&#39;))
            return None, err_msg
        result = resp.get(&#39;result&#39;)
        if result is None:
            err_msg = &#39;No error and no result: invalid JSON-RPC response&#39;
            return None, err_msg
        return result, None</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="olca.ipc.Client"><code class="flex name class">
<span>class <span class="ident">Client</span></span>
<span>(</span><span>port: int = 8080)</span>
</code></dt>
<dd>
<div class="desc"><p>A client to communicate with an openLCA IPC server.</p>
<p>An openLCA IPC server is always connected to a database and operations
that are executed via this client are thus executed on that database.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The port of the server connection; optional, defaults to 8080.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Client(object):
    &#34;&#34;&#34;
    A client to communicate with an openLCA IPC server.

    An openLCA IPC server is always connected to a database and operations
    that are executed via this client are thus executed on that database.

    Parameters
    ----------

    port: int, optional
        The port of the server connection; optional, defaults to 8080.
    &#34;&#34;&#34;

    def __init__(self, port: int = 8080):
        self.url = &#39;http://localhost:%i&#39; % port
        self.next_id = 1

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        return

    def close(self):
        return

    def insert(self, model: E):
        &#34;&#34;&#34;
        Inserts the given model into the database of the IPC server.

        Example
        -------
        ```python
        import olca
        import uuid

        flow = olca.Flow()
        flow.name = &#39;CO2&#39;
        flow.id = str(uuid.uuid4())
        flow.flow_type = olca.FlowType.ELEMENTARY_FLOW
        prop = olca.FlowPropertyFactor()
        prop.flow_property = olca.ref(
            olca.FlowProperty,
            &#39;93a60a56-a3c8-11da-a746-0800200b9a66&#39;,
            &#39;Mass&#39;
        )
        prop.conversion_factor = 1.0
        prop.reference_flow_property = True
        flow.flow_properties = [prop]
        response = olca.Client().insert(flow)
        print(response)
        ```

        &#34;&#34;&#34;
        if model is None:
            return
        json = model.to_json()
        resp, err = self.__post(&#39;insert/model&#39;, json)
        if err:
            log.error(&#39;failed to insert model: %s&#39;, err)
            return err
        return resp

    def update(self, model: E):
        &#34;&#34;&#34;
        Update the given model in the database of the IPC server.
        &#34;&#34;&#34;
        if model is None:
            return
        json = model.to_json()
        resp, err = self.__post(&#39;update/model&#39;, json)
        if err:
            log.error(&#39;failed to update model: %s&#39;, err)
            return err
        return resp

    def delete(self, model: E):
        &#34;&#34;&#34;
        Delete the given model from the database of the IPC server.
        &#34;&#34;&#34;
        if model is None:
            return
        json = model.to_json()
        resp, err = self.__post(&#39;delete/model&#39;, json)
        if err:
            log.error(&#39;failed to delete model: %s&#39;, err)
            return err
        return resp

    def calculate(self, setup: schema.CalculationSetup) -&gt; schema.SimpleResult:
        &#34;&#34;&#34;
        Calculates a result for the given calculation setup.

        Parameters
        ----------

        setup: olca.schema.CalculationSetup
            The setup of the calculation.

        Example
        -------
        ```python
        client = olca.Client()
        setup = olca.CalculationSetup()
        setup.calculation_type = olca.CalculationType.UPSTREAM_ANALYSIS
        setup.product_system = olca.ref(
            olca.ProductSystem,
            &#39;91c2c4a5-2d9d-482e-8c8c-678d7e1b9f55&#39;
        )
        setup.impact_method = olca.ref(
            olca.ImpactMethod,
            &#39;d2c781ce-21b4-3218-8fca-78133f2c8d4d&#39;
        )
        setup.amount = 1.0
        result = client.calculate(setup)
        # do something with the result
        # you should always dispose the result when you
        # do not need it anymore to avoid memory leaks.
        client.dispose(result)
        ```
        &#34;&#34;&#34;
        resp, err = self.__post(&#39;calculate&#39;, setup.to_json())
        if err:
            log.error(&#39;calculation failed: %s&#39;, err)
            return schema.SimpleResult()
        return schema.SimpleResult.from_json(resp)

    def simulator(self, setup: schema.CalculationSetup) -&gt; schema.Ref:
        &#34;&#34;&#34;
        Create a simulator to run Monte-Carlo simulations for the given setup.

        Parameters
        ----------

        setup: olca.schema.CalculationSetup
            The calculation setup that should be used.

        Returns
        -------

        olca.schema.Ref
            A reference to an simulator instance.

        Example
        -------
        ```python
        import olca

        client = olca.Client()
        # creating the calculation setup
        setup = olca.CalculationSetup()
        setup.calculation_type = olca.CalculationType.MONTE_CARLO_SIMULATION
        setup.impact_method = client.find(olca.ImpactMethod, &#39;TRACI [v2.1, February 2014]&#39;)
        setup.product_system = client.find(olca.ProductSystem, &#39;compost plant, open&#39;)
        setup.amount = 1.0

        # create the simulator
        simulator = client.simulator(setup)

        for i in range(0, 10):
            result = client.next_simulation(simulator)
            first_impact = result.impact_results[0]
            print(&#39;iteration %i: result for %s = %4.4f&#39; %
                  (i, first_impact.impact_category.name, first_impact.value))
            # we do not have to dispose the result here (it is not cached
            # in openLCA); but we need to dispose the simulator later (see below)

        # export the complete result of all simulations
        client.excel_export(simulator, &#39;simulation_result.xlsx&#39;)

        # the result remains accessible (for exports etc.) until
        # you dispose it, which you should always do when you do
        # not need it anymore
        client.dispose(simulator)
        ```
        &#34;&#34;&#34;
        resp, err = self.__post(&#39;simulator&#39;, setup.to_json())
        if err:
            log.error(&#39;failed to create simulator: %s&#39;, err)
            return schema.Ref()
        return schema.Ref.from_json(resp)

    def next_simulation(self, simulator: schema.Ref) -&gt; schema.SimpleResult:
        &#34;&#34;&#34;
        Runs the next Monte-Carlo simulation with the given simulator reference.
        It returns the result of the simulation. Note that this result is not
        cached (the simulator is cached).
        See [the simulator example](#olca.ipc.Client.simulator).

        Parameters
        ----------
        simulator: olca.schema.Ref
            The reference to the simulator which is called to run the next
            simulation step.

        &#34;&#34;&#34;
        if simulator is None:
            raise ValueError(&#39;No simulator given&#39;)
        resp, err = self.__post(&#39;next/simulation&#39;, simulator.to_json())
        if err:
            log.error(&#39;failed to get simulation result: %s&#39;, err)
            return schema.SimpleResult()
        return schema.SimpleResult.from_json(resp)

    def get_descriptors(self, model_type: ModelType) -&gt; Iterator[schema.Ref]:
        &#34;&#34;&#34;
        Get the descriptors of the entities with the type from the database.

        Parameters
        ----------
        model_type: ModelType
            The model type, e.g. olca.Flow or `&#39;Flow&#39;`

        Returns
        -------
        Iterator[schema.Ref]
            An iterator with Ref objects.

        Example:
        --------
        ```python
        import olca

        with olca.Client() as client:
            for a in client.get_descriptors(&#39;Actor&#39;):
                print(&#39;found Actor: %s&#39; % a.name)
            for s in client.get_descriptors(olca.Source):
                print(&#39;found Source: %s&#39; % s.name)
        ```

        &#34;&#34;&#34;
        params = {&#39;@type&#39;: _model_type(model_type)}
        result, err = self.__post(&#39;get/descriptors&#39;, params)
        if err:
            log.error(&#39;failed to get descriptors of type %s: %s&#39;,
                      model_type, err)
            return []
        for r in result:
            yield schema.Ref.from_json(r)

    def get_descriptor(self, model_type: ModelType,
                       uid=&#39;&#39;, name=&#39;&#39;) -&gt; Optional[schema.Ref]:
        &#34;&#34;&#34;
        Get a descriptor of the model with the given ID or name from the database.

        Models like product systems can be very large but often we just need
        a reference to a model (e.g. in a calculation setup). In this case
        this method can be useful.

        since: openLCA 2.0

        Parameters
        ----------
        model_type: ModelType
            The type of the model, e.g. olca.ProductSystem or `&#39;ProductSystem&#39;`
        uid: str, optional
            The ID of the model.
        name: str, optional
            The name of the model.

        Returns
        -------
        schema.Ref
            The descriptor of the model.

        Example
        -------
        ```python
        import olca

        client = olca.Client()
        system_ref = client.get_descriptor(
            olca.ProductSystem,
            &#39;f50ee15a-968f-4316-a160-4c7741284c62&#39;)
        print(system_ref.to_json())
        ```
        &#34;&#34;&#34;

        params = {&#39;@type&#39;: _model_type(model_type)}
        if uid != &#39;&#39;:
            params[&#39;@id&#39;] = uid
        if name != &#39;&#39;:
            params[&#39;name&#39;] = name
        result, err = self.__post(&#39;get/descriptor&#39;, params)
        if err:
            log.error(&#39;failed to get descriptor: %s&#39;, err)
            return None
        return schema.Ref.from_json(result)

    def get(self, model_type: Type[E],
            uid=&#39;&#39;, name=&#39;&#39;) -&gt; Optional[E]:
        params = {&#39;@type&#39;: _model_type(model_type)}
        if uid != &#39;&#39;:
            params[&#39;@id&#39;] = uid
        if name != &#39;&#39;:
            params[&#39;name&#39;] = name
        result, err = self.__post(&#39;get/model&#39;, params)
        if err:
            log.error(&#39;failed to get entity of type %s: %s&#39;,
                      model_type, err)
            return None
        return _model_class(model_type).from_json(result)

    def get_all(self, model_type: Type[E]) -&gt; Iterator[E]:
        &#34;&#34;&#34;
        Returns a generator for all instances of the given type from the
        database. Note that this will first fetch the complete JSON list from
        the IPC server and thus should be only used when a small amount of
        instances is expected as return value.

        Example
        -------
        ```python
        import olca

        client = olca.Client()
        currencies = client.get_all(olca.Currency)
        for c in currencies:
            print(c.name)
        ```
        &#34;&#34;&#34;
        params = {&#39;@type&#39;: model_type.__name__}
        result, err = self.__post(&#39;get/models&#39;, params)
        if err:
            log.error(&#39;failed to get all of type %s: %s&#39;,
                      model_type, err)
        clazz = _model_class(model_type)
        for r in result:
            yield clazz.from_json(r)

    def find(self, model_type: ModelType, name: str) -&gt; Optional[schema.Ref]:
        &#34;&#34;&#34;Searches for a data set with the given type and name.

        :param model_type: The class of the data set, e.g. `olca.Flow`.
        :param name: The name of the data set.
        :return: The reference to the first data set with the given name and
                 type from the databases or ``None`` if there is no such data
                 set in the database.
        &#34;&#34;&#34;
        for d in self.get_descriptors(model_type):
            if d.name == name:
                return d

    def get_providers_of(self, flow: Union[schema.Ref, schema.Flow]) \
            -&gt; Iterator[schema.Ref]:
        &#34;&#34;&#34;
        Get the providers for the given flow.

        For products, these are the processes that have an output of the given
        product. For waste flows, these are the waste treatment processes that
        have this flow on the input side. Elementary flows do not have a
        provider.

        Parameters
        ----------
        flow: Union[schema.Ref, schema.Flow]
            The flow or reference to the flow for which the providers should be
            returned.

        Example
        -------
        ```python
        steel = client.get(&#39;Flow&#39;, &#39;Steel&#39;)
        for provider in client.get_providers_of(steel):
            print(provider.name)
        ```
        &#34;&#34;&#34;
        params = {
            &#39;@type&#39;: &#39;Flow&#39;,
            &#39;@id&#39;: flow.id,
            &#39;name&#39;: flow.name,
        }
        providers, err = self.__post(&#39;get/providers&#39;, params)
        if err:
            log.error(&#39;failed to get providers: %s&#39;, err)
            return []
        for obj in providers:
            yield schema.Ref.from_json(obj)

    def excel_export(self, result: schema.SimpleResult, path: str):
        &#34;&#34;&#34;Export the given result to an Excel file with the given path.

        :param result: The result that should be exported.
        :param path: The path of the Excel file to which the result should be
                     written.
        &#34;&#34;&#34;
        abs_path = os.path.abspath(path)
        params = {
            &#39;@id&#39;: result.id,
            &#39;path&#39;: abs_path
        }
        _, err = self.__post(&#39;export/excel&#39;, params)
        if err:
            log.error(&#39;Excel export to %s failed: %s&#39;, path, err)

    def dispose(self, entity: schema.Entity):
        &#34;&#34;&#34;
        Removes the given entity from the memory of the IPC server.

        This is required for calculation results that are hold on the server for
        further processing.

        Parameters
        ----------

        entity: olca.schema.Entity
            The entity that should be disposed (typically a result).

        Example
        -------
        ```python
        client = olca.Client()
        setup = olca.CalculationSetup()
        setup.calculation_type = olca.CalculationType.UPSTREAM_ANALYSIS
        setup.product_system = olca.ref(
          olca.ProductSystem,
          &#39;7d1cbce0-b5b3-47ba-95b5-014ab3c7f569&#39;
        )
        setup.amount = 1.0
        result = client.calculate(setup)
        # do something with the result
        # ...
        response = client.dispose(result)
        print(response)  # should print `ok`
        ```
        &#34;&#34;&#34;
        if entity is None:
            return
        arg = {&#39;@type&#39;: type(entity).__name__, &#39;@id&#39;: entity.id}
        _, err = self.__post(&#39;dispose&#39;, arg)
        if err:
            log.error(&#39;failed to dispose object: %s&#39;, err)

    def shutdown_server(self):
        &#34;&#34;&#34;
        Close the database and shutdown the server.

        This method is probably most useful when running a headless server
        (a server without openLCA user interface).
        &#34;&#34;&#34;
        _, err = self.__post(&#39;runtime/shutdown&#39;, None)
        if err:
            log.error(&#39;failed to shutdown server: %s&#39;, err)

    def create_product_system(self, process_id: str, default_providers=&#39;prefer&#39;,
                              preferred_type=&#39;LCI_RESULT&#39;) -&gt; Optional[schema.Ref]:
        &#34;&#34;&#34;
        Creates a product system from the process with the given ID.

        Parameters
        ----------

        process_id: str
            The ID of the process from which the product system should be
            generated. This will be the reference process of the product system
            with upstream and downstream processes added recursively.

        default_providers: {&#39;prefer&#39;, &#39;ignore&#39;, &#39;only&#39;}, optional
            Indicates how default providers of product inputs and waste outputs
            should be considered during the linking. `only` means that only
            product inputs and waste outputs should be linked that have a
            default provider and that this default provider is used. `prefer`
            means that a default provider is used during the linking if there
            are multiple options. `ignore` means that the default providers
            have no specific role.

        preferred_type : {&#39;LCI_RESULT&#39;, &#39;UNIT_PROCESS&#39;}, optional
            When there are multiple provider processes available for linking a
            product input or waste output the `preferred_type` indicates which
            type of process (LCI results or unit processes) should be preferred
            during the linking.

        Returns
        -------

        olca.schema.Ref
            A descriptor of the created product system.

        Example
        -------

        ```python
        import olca

        client = olca.Client(8080)
        process_id = &#39;4aee0b0c-eb46-37f1-8c7a-7e5b1adfd014&#39;
        ref = client.create_product_system(process_id)
        print(&#39;Created product system %s&#39; % ref.id)
        ```
        &#34;&#34;&#34;

        r, err = self.__post(&#39;create/product_system&#39;, {
            &#39;processId&#39;: process_id,
            &#39;preferredType&#39;: preferred_type,
            &#39;providerLinking&#39;: default_providers,
        })
        if err:
            log.error(&#39;failed to create product system: %s&#39;, err)
            return None
        return schema.Ref.from_json(r)

    def lci_inputs(self, result: schema.SimpleResult) -&gt; List[schema.FlowResult]:
        &#34;&#34;&#34;
        Returns the inputs of the given inventory result.

        Example
        -------
        ```python
        result = client.calculate(setup)
        # print the first input
        print(client.lci_inputs(result)[0])
        client.dispose(result)
        ```
        &#34;&#34;&#34;
        raw, err = self.__post(&#39;get/inventory/inputs&#39;, {
            &#39;resultId&#39;: result.id,
        })
        if err:
            log.error(&#39;failed to get LCI inputs&#39;)
            return []
        return [schema.FlowResult.from_json(it) for it in raw]

    def lci_outputs(self, result: schema.SimpleResult) -&gt; List[dict]:
        &#34;&#34;&#34;
        Returns the outputs of the given inventory result.

        Example
        -------
        ```python
        result = client.calculate(setup)
        # print the first output
        print(client.lci_outputs(result)[0])
        client.dispose(result)
        ```
        &#34;&#34;&#34;
        raw, err = self.__post(&#39;get/inventory/outputs&#39;, {
            &#39;resultId&#39;: result.id,
        })
        if err:
            log.error(&#39;failed to get LCI outputs: %s&#39;, err)
            return []
        return [schema.FlowResult.from_json(it) for it in raw]

    def lci_location_contributions(self, result: schema.SimpleResult,
                                   flow: schema.Ref) -&gt; List[ContributionItem]:
        &#34;&#34;&#34;
        Get the contributions of the result of the given flow by location.

        Parameters
        ----------
        result: olca.schema.SimpleResult
            The result which needs to be at least a contribution result.

        flow: olca.schema.Ref
            The (reference of the) flow for which the calculations should be
            calculated.

        Returns
        -------
        list[ContributionItem]
            The contributions to the flow result by location.

        Example
        -------
        ```python
        # ...
        result = client.calculate(setup)
        # select the first output of the LCI result
        output = client.lci_outputs(result)[0]
        # calculate the location contributions of the flow of that output
        cons = client.lci_location_contributions(result, output.flow)
        # ...
        client.dispose(result)
        ```
        &#34;&#34;&#34;
        raw, err = self.__post(&#39;get/inventory/contributions/locations&#39;, {
            &#39;resultId&#39;: result.id,
            &#39;flow&#39;: flow.to_json(),
        })
        if err:
            log.error(&#39;failed to ger contributions by location&#39;)
            return []
        return [ContributionItem.from_json(it) for it in raw]

    def lci_total_requirements(self, result: schema.SimpleResult) -&gt; List[ProductResult]:
        &#34;&#34;&#34;
        Returns the total requirements of the given result.

        The total requirements are the product amounts that are required to
        fulfill the demand of the product system. As our technology matrix
        \\(A\\) is indexed symmetrically (means rows and columns refer to the
        same process-product pair) our product amounts are on the diagonal of
        the technology matrix and the total requirements can be calculated by
        the following equation where \\(s\\) is the scaling vector (
        \\(\\odot\\) denotes element-wise multiplication):

        $$t = diag(A) \odot s$$

        Parameters
        ----------
        result: olca.schema.SimpleResult
            The simple result from which the total requirements should be
            returned.

        Example
        -------
        ```python
        import olca

        client = olca.Client()
        setup = olca.CalculationSetup()
        setup.calculation_type = olca.CalculationType.UPSTREAM_ANALYSIS
        setup.product_system = olca.ref(
            olca.ProductSystem,
            &#39;7d1cbce0-b5b3-47ba-95b5-014ab3c7f569&#39;
        )
        setup.amount = 1.0
        result = client.calculate(setup)
        print(client.lci_total_requirements(result)[0])
        client.dispose(result)
        ```
        &#34;&#34;&#34;

        raw, err = self.__post(&#39;get/inventory/total_requirements&#39;, {
            &#39;resultId&#39;: result.id
        })
        if err:
            log.error(&#39;failed to get total requirements %s&#39;, err)
            return []
        return [ProductResult.from_json(it) for it in raw]

    def lcia(self, result: schema.SimpleResult) -&gt; List[schema.ImpactResult]:
        &#34;&#34;&#34;
        Returns the LCIA result of the given result.

        Parameters
        ----------
        result: olca.schema.SimpleResult
            The result from which the LCIA result should be returned.

        Example
        -------
        ```python
        # ...
        result = client.calculate(setup)
        lcia = client.lcia(result)
        # ...
        client.dispose(result)
        ```
        &#34;&#34;&#34;

        raw, err = self.__post(&#39;get/impacts&#39;, {
            &#39;resultId&#39;: result.id,
        })
        if err:
            log.error(&#39;failed to get impact results: %s&#39;, err)
            return []
        return [schema.ImpactResult.from_json(it) for it in raw]

    def lcia_flow_contributions(self, result: schema.SimpleResult,
                                impact: schema.Ref) -&gt; List[ContributionItem]:
        &#34;&#34;&#34;
        Get the flow contributions to the result of the given impact category.

        Parameters
        ----------
        result: olca.schema.SimpleResult
            The result.

        impact: olca.schema.Ref
            The (reference to the) LCIA category.

        Example
        -------
        ```python
        # ...
        result = client.calculate(setup)
        # select the first LCIA result
        impact_result = client.lcia(result)[0]
        # get the flow contributions to the LCIA category of that result
        cons = client.lcia_flow_contributions(
            result, impact_result.impact_category)
        # ...
        client.dispose(result)
        ```
        &#34;&#34;&#34;

        raw, err = self.__post(&#39;get/impacts/contributions/flows&#39;, {
            &#39;resultId&#39;: result.id,
            &#39;impactCategory&#39;: impact.to_json(),
        })
        if err:
            log.error(&#39;failed to get contribution items: %s&#39;, err)
            return []
        return [ContributionItem.from_json(it) for it in raw]

    def lcia_location_contributions(self, result: schema.SimpleResult,
                                    impact: schema.Ref) -&gt; List[ContributionItem]:
        &#34;&#34;&#34;
        Get the contributions to the result of the given impact category by
        locations.

        Parameters
        ----------
        result: olca.schema.SimpleResult
            The result.

        impact: olca.schema.Ref
            The (reference to the) LCIA category.


        Example
        -------
        ```python
        # ...
        result = client.calculate(setup)
        # select the first LCIA result
        impact_result = client.lcia(result)[0]
        # get the flow contributions to the LCIA category of that result
        cons = client.lcia_location_contributions(
            result, impact_result.impact_category)
        # ...
        client.dispose(result)
        ```
        &#34;&#34;&#34;

        raw, err = self.__post(&#39;get/impacts/contributions/locations&#39;, {
            &#39;resultId&#39;: result.id,
            &#39;impactCategory&#39;: impact.to_json(),
        })
        if err:
            log.error(&#39;Failed to get contribution items: %s&#39;, err)
            return []
        return [ContributionItem.from_json(it) for it in raw]

    def lcia_process_contributions(self, result: schema.SimpleResult,
                                   impact: schema.Ref) -&gt; List[ContributionItem]:
        &#34;&#34;&#34;
        Get the contributions to the result of the given impact category by
        processes.

        Parameters
        ----------
        result: olca.schema.SimpleResult
            The result.

        impact: olca.schema.Ref
            The (reference to the) LCIA category.


        Example
        -------
        ```python
        # ...
        result = client.calculate(setup)
        # select the first LCIA result
        impact_result = client.lcia(result)[0]
        # get the flow contributions to the LCIA category of that result
        cons = client.lcia_process_contributions(
            result, impact_result.impact_category)
        # ...
        client.dispose(result)
        ```
        &#34;&#34;&#34;

        raw, err = self.__post(&#39;get/impacts/contributions/processes&#39;, {
            &#39;resultId&#39;: result.id,
            &#39;impactCategory&#39;: impact.to_json(),
        })
        if err:
            log.error(&#39;Failed to get contribution items: %s&#39;, err)
            return []
        return [ContributionItem.from_json(it) for it in raw]

    def upstream_tree_of(self, result: schema.SimpleResult, ref: schema.Ref,
                         max_depth=5, min_contribution=0.1,
                         max_recursion_depth=3) -&gt; Optional[utree.UpstreamTree]:
        &#34;&#34;&#34;
        Get an upstream tree for an impact category or flow.

        This function is only available in openLCA 2.x.

        Parameters
        ----------
        result: olca.schema.SimpleResult
            The previously calculated result. This needs to be an upstream
            result.

        ref: olca.schema.Ref
            The result reference of the upstream tree: a flow or impact
            category reference.

        max_depth: int
            The maximum number of levels of the tree. A value &lt; 0 means
            unlimited. In this case reasonable recursion limits are
            required if the underlying product system has cycles.

        min_contribution: float
            In addition to the maximum tree depth, this parameter describes
            the minimum upstream contribution of a node in the tree. A value
            &lt; 0 means that there is no minimum contribution.

        max_recursion_depth: int
            When the max. tree depth is unlimited and the underlying product
            system has cycles, this parameter indicates how often a process
            can occur in a tree path. It defines the maximum number of
            expansions of a loop in a tree path.

        Example
        -------
        ```python
        client = olca.Client()

        # create the calculation setup and run the calculation
        setup = olca.CalculationSetup()
        setup.calculation_type = olca.CalculationType.UPSTREAM_ANALYSIS
        setup.product_system = olca.ref(
            olca.ProductSystem,
            &#39;7d1cbce0-b5b3-47ba-95b5-014ab3c7f569&#39;
        )
        setup.impact_method = olca.ref(
            olca.ImpactMethod,
            &#39;99b9d86b-ec6f-4610-ba9f-68ebfe5691dd&#39;
        )
        setup.amount = 1.0
        result = client.calculate(setup)

        # calculate the upstream tree and traverse it
        impact = olca.ref(
            olca.ImpactCategory,
            &#39;2a26b243-23cb-4f90-baab-239d3d7397fa&#39;)
        tree = client.upstream_tree_of(result, impact)

        def traversal_handler(n: tuple[UpstreamNode, int]):
            (node, depth) = n
            print(&#39;%s+ %s %.3f&#39; % (
                &#39;  &#39; * depth,
                node.product.process.name,
                node.result
            ))

        tree.traverse(traversal_handler)

        # dispose the result
        client.dispose(result)
        ```
        &#34;&#34;&#34;
        raw, err = self.__post(&#39;get/upstream/tree&#39;, {
            &#39;resultId&#39;: result.id,
            &#39;ref&#39;: ref.to_json(),
            &#39;maxDepth&#39;: max_depth,
            &#39;minContribution&#39;: min_contribution,
            &#39;maxRecursionDepth&#39;: max_recursion_depth
        })
        if err:
            log.error(&#39;Failed to get upstream tree: %s&#39;, err)
            return None
        return utree.UpstreamTree.from_json(raw)

    def __post(self, method: str, params) -&gt; tuple[Any, Optional[str]]:
        &#34;&#34;&#34;
        Performs a request with the given parameters.

        It returns a tuple (result, error).
        &#34;&#34;&#34;
        req = {
            &#39;jsonrpc&#39;: &#39;2.0&#39;,
            &#39;id&#39;: self.next_id,
            &#39;method&#39;: method,
            &#39;params&#39;: params
        }
        self.next_id += 1
        resp = requests.post(self.url, json=req).json()  # type: dict
        err = resp.get(&#39;error&#39;)  # type: dict
        if err is not None:
            err_msg = &#39;%i: %s&#39; % (err.get(&#39;code&#39;), err.get(&#39;message&#39;))
            return None, err_msg
        result = resp.get(&#39;result&#39;)
        if result is None:
            err_msg = &#39;No error and no result: invalid JSON-RPC response&#39;
            return None, err_msg
        return result, None</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="olca.ipc.Client.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self, setup: <a title="olca.schema.CalculationSetup" href="schema.html#olca.schema.CalculationSetup">CalculationSetup</a>) ‑> <a title="olca.schema.SimpleResult" href="schema.html#olca.schema.SimpleResult">SimpleResult</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calculates a result for the given calculation setup.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>setup</code></strong> :&ensp;<code><a title="olca.schema.CalculationSetup" href="schema.html#olca.schema.CalculationSetup">CalculationSetup</a></code></dt>
<dd>The setup of the calculation.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python">client = olca.Client()
setup = olca.CalculationSetup()
setup.calculation_type = olca.CalculationType.UPSTREAM_ANALYSIS
setup.product_system = olca.ref(
    olca.ProductSystem,
    '91c2c4a5-2d9d-482e-8c8c-678d7e1b9f55'
)
setup.impact_method = olca.ref(
    olca.ImpactMethod,
    'd2c781ce-21b4-3218-8fca-78133f2c8d4d'
)
setup.amount = 1.0
result = client.calculate(setup)
# do something with the result
# you should always dispose the result when you
# do not need it anymore to avoid memory leaks.
client.dispose(result)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, setup: schema.CalculationSetup) -&gt; schema.SimpleResult:
    &#34;&#34;&#34;
    Calculates a result for the given calculation setup.

    Parameters
    ----------

    setup: olca.schema.CalculationSetup
        The setup of the calculation.

    Example
    -------
    ```python
    client = olca.Client()
    setup = olca.CalculationSetup()
    setup.calculation_type = olca.CalculationType.UPSTREAM_ANALYSIS
    setup.product_system = olca.ref(
        olca.ProductSystem,
        &#39;91c2c4a5-2d9d-482e-8c8c-678d7e1b9f55&#39;
    )
    setup.impact_method = olca.ref(
        olca.ImpactMethod,
        &#39;d2c781ce-21b4-3218-8fca-78133f2c8d4d&#39;
    )
    setup.amount = 1.0
    result = client.calculate(setup)
    # do something with the result
    # you should always dispose the result when you
    # do not need it anymore to avoid memory leaks.
    client.dispose(result)
    ```
    &#34;&#34;&#34;
    resp, err = self.__post(&#39;calculate&#39;, setup.to_json())
    if err:
        log.error(&#39;calculation failed: %s&#39;, err)
        return schema.SimpleResult()
    return schema.SimpleResult.from_json(resp)</code></pre>
</details>
</dd>
<dt id="olca.ipc.Client.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    return</code></pre>
</details>
</dd>
<dt id="olca.ipc.Client.create_product_system"><code class="name flex">
<span>def <span class="ident">create_product_system</span></span>(<span>self, process_id: str, default_providers='prefer', preferred_type='LCI_RESULT') ‑> Optional[<a title="olca.schema.Ref" href="schema.html#olca.schema.Ref">Ref</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a product system from the process with the given ID.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>process_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the process from which the product system should be
generated. This will be the reference process of the product system
with upstream and downstream processes added recursively.</dd>
<dt><strong><code>default_providers</code></strong> :&ensp;<code>{'prefer', 'ignore', 'only'}</code>, optional</dt>
<dd>Indicates how default providers of product inputs and waste outputs
should be considered during the linking. <code>only</code> means that only
product inputs and waste outputs should be linked that have a
default provider and that this default provider is used. <code>prefer</code>
means that a default provider is used during the linking if there
are multiple options. <code>ignore</code> means that the default providers
have no specific role.</dd>
<dt><strong><code>preferred_type</code></strong> :&ensp;<code>{'LCI_RESULT', 'UNIT_PROCESS'}</code>, optional</dt>
<dd>When there are multiple provider processes available for linking a
product input or waste output the <code>preferred_type</code> indicates which
type of process (LCI results or unit processes) should be preferred
during the linking.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="olca.schema.Ref" href="schema.html#olca.schema.Ref">Ref</a></code></dt>
<dd>A descriptor of the created product system.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python">import olca

client = olca.Client(8080)
process_id = '4aee0b0c-eb46-37f1-8c7a-7e5b1adfd014'
ref = client.create_product_system(process_id)
print('Created product system %s' % ref.id)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_product_system(self, process_id: str, default_providers=&#39;prefer&#39;,
                          preferred_type=&#39;LCI_RESULT&#39;) -&gt; Optional[schema.Ref]:
    &#34;&#34;&#34;
    Creates a product system from the process with the given ID.

    Parameters
    ----------

    process_id: str
        The ID of the process from which the product system should be
        generated. This will be the reference process of the product system
        with upstream and downstream processes added recursively.

    default_providers: {&#39;prefer&#39;, &#39;ignore&#39;, &#39;only&#39;}, optional
        Indicates how default providers of product inputs and waste outputs
        should be considered during the linking. `only` means that only
        product inputs and waste outputs should be linked that have a
        default provider and that this default provider is used. `prefer`
        means that a default provider is used during the linking if there
        are multiple options. `ignore` means that the default providers
        have no specific role.

    preferred_type : {&#39;LCI_RESULT&#39;, &#39;UNIT_PROCESS&#39;}, optional
        When there are multiple provider processes available for linking a
        product input or waste output the `preferred_type` indicates which
        type of process (LCI results or unit processes) should be preferred
        during the linking.

    Returns
    -------

    olca.schema.Ref
        A descriptor of the created product system.

    Example
    -------

    ```python
    import olca

    client = olca.Client(8080)
    process_id = &#39;4aee0b0c-eb46-37f1-8c7a-7e5b1adfd014&#39;
    ref = client.create_product_system(process_id)
    print(&#39;Created product system %s&#39; % ref.id)
    ```
    &#34;&#34;&#34;

    r, err = self.__post(&#39;create/product_system&#39;, {
        &#39;processId&#39;: process_id,
        &#39;preferredType&#39;: preferred_type,
        &#39;providerLinking&#39;: default_providers,
    })
    if err:
        log.error(&#39;failed to create product system: %s&#39;, err)
        return None
    return schema.Ref.from_json(r)</code></pre>
</details>
</dd>
<dt id="olca.ipc.Client.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, model: ~E)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete the given model from the database of the IPC server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, model: E):
    &#34;&#34;&#34;
    Delete the given model from the database of the IPC server.
    &#34;&#34;&#34;
    if model is None:
        return
    json = model.to_json()
    resp, err = self.__post(&#39;delete/model&#39;, json)
    if err:
        log.error(&#39;failed to delete model: %s&#39;, err)
        return err
    return resp</code></pre>
</details>
</dd>
<dt id="olca.ipc.Client.dispose"><code class="name flex">
<span>def <span class="ident">dispose</span></span>(<span>self, entity: <a title="olca.schema.Entity" href="schema.html#olca.schema.Entity">Entity</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes the given entity from the memory of the IPC server.</p>
<p>This is required for calculation results that are hold on the server for
further processing.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>entity</code></strong> :&ensp;<code><a title="olca.schema.Entity" href="schema.html#olca.schema.Entity">Entity</a></code></dt>
<dd>The entity that should be disposed (typically a result).</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python">client = olca.Client()
setup = olca.CalculationSetup()
setup.calculation_type = olca.CalculationType.UPSTREAM_ANALYSIS
setup.product_system = olca.ref(
  olca.ProductSystem,
  '7d1cbce0-b5b3-47ba-95b5-014ab3c7f569'
)
setup.amount = 1.0
result = client.calculate(setup)
# do something with the result
# ...
response = client.dispose(result)
print(response)  # should print `ok`
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dispose(self, entity: schema.Entity):
    &#34;&#34;&#34;
    Removes the given entity from the memory of the IPC server.

    This is required for calculation results that are hold on the server for
    further processing.

    Parameters
    ----------

    entity: olca.schema.Entity
        The entity that should be disposed (typically a result).

    Example
    -------
    ```python
    client = olca.Client()
    setup = olca.CalculationSetup()
    setup.calculation_type = olca.CalculationType.UPSTREAM_ANALYSIS
    setup.product_system = olca.ref(
      olca.ProductSystem,
      &#39;7d1cbce0-b5b3-47ba-95b5-014ab3c7f569&#39;
    )
    setup.amount = 1.0
    result = client.calculate(setup)
    # do something with the result
    # ...
    response = client.dispose(result)
    print(response)  # should print `ok`
    ```
    &#34;&#34;&#34;
    if entity is None:
        return
    arg = {&#39;@type&#39;: type(entity).__name__, &#39;@id&#39;: entity.id}
    _, err = self.__post(&#39;dispose&#39;, arg)
    if err:
        log.error(&#39;failed to dispose object: %s&#39;, err)</code></pre>
</details>
</dd>
<dt id="olca.ipc.Client.excel_export"><code class="name flex">
<span>def <span class="ident">excel_export</span></span>(<span>self, result: <a title="olca.schema.SimpleResult" href="schema.html#olca.schema.SimpleResult">SimpleResult</a>, path: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Export the given result to an Excel file with the given path.</p>
<p>:param result: The result that should be exported.
:param path: The path of the Excel file to which the result should be
written.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def excel_export(self, result: schema.SimpleResult, path: str):
    &#34;&#34;&#34;Export the given result to an Excel file with the given path.

    :param result: The result that should be exported.
    :param path: The path of the Excel file to which the result should be
                 written.
    &#34;&#34;&#34;
    abs_path = os.path.abspath(path)
    params = {
        &#39;@id&#39;: result.id,
        &#39;path&#39;: abs_path
    }
    _, err = self.__post(&#39;export/excel&#39;, params)
    if err:
        log.error(&#39;Excel export to %s failed: %s&#39;, path, err)</code></pre>
</details>
</dd>
<dt id="olca.ipc.Client.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>self, model_type: Union[Type[~E], str], name: str) ‑> Optional[<a title="olca.schema.Ref" href="schema.html#olca.schema.Ref">Ref</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Searches for a data set with the given type and name.</p>
<p>:param model_type: The class of the data set, e.g. <code>olca.Flow</code>.
:param name: The name of the data set.
:return: The reference to the first data set with the given name and
type from the databases or <code>None</code> if there is no such data
set in the database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find(self, model_type: ModelType, name: str) -&gt; Optional[schema.Ref]:
    &#34;&#34;&#34;Searches for a data set with the given type and name.

    :param model_type: The class of the data set, e.g. `olca.Flow`.
    :param name: The name of the data set.
    :return: The reference to the first data set with the given name and
             type from the databases or ``None`` if there is no such data
             set in the database.
    &#34;&#34;&#34;
    for d in self.get_descriptors(model_type):
        if d.name == name:
            return d</code></pre>
</details>
</dd>
<dt id="olca.ipc.Client.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, model_type: Type[~E], uid='', name='') ‑> Optional[~E]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, model_type: Type[E],
        uid=&#39;&#39;, name=&#39;&#39;) -&gt; Optional[E]:
    params = {&#39;@type&#39;: _model_type(model_type)}
    if uid != &#39;&#39;:
        params[&#39;@id&#39;] = uid
    if name != &#39;&#39;:
        params[&#39;name&#39;] = name
    result, err = self.__post(&#39;get/model&#39;, params)
    if err:
        log.error(&#39;failed to get entity of type %s: %s&#39;,
                  model_type, err)
        return None
    return _model_class(model_type).from_json(result)</code></pre>
</details>
</dd>
<dt id="olca.ipc.Client.get_all"><code class="name flex">
<span>def <span class="ident">get_all</span></span>(<span>self, model_type: Type[~E]) ‑> Iterator[~E]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a generator for all instances of the given type from the
database. Note that this will first fetch the complete JSON list from
the IPC server and thus should be only used when a small amount of
instances is expected as return value.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python">import olca

client = olca.Client()
currencies = client.get_all(olca.Currency)
for c in currencies:
    print(c.name)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all(self, model_type: Type[E]) -&gt; Iterator[E]:
    &#34;&#34;&#34;
    Returns a generator for all instances of the given type from the
    database. Note that this will first fetch the complete JSON list from
    the IPC server and thus should be only used when a small amount of
    instances is expected as return value.

    Example
    -------
    ```python
    import olca

    client = olca.Client()
    currencies = client.get_all(olca.Currency)
    for c in currencies:
        print(c.name)
    ```
    &#34;&#34;&#34;
    params = {&#39;@type&#39;: model_type.__name__}
    result, err = self.__post(&#39;get/models&#39;, params)
    if err:
        log.error(&#39;failed to get all of type %s: %s&#39;,
                  model_type, err)
    clazz = _model_class(model_type)
    for r in result:
        yield clazz.from_json(r)</code></pre>
</details>
</dd>
<dt id="olca.ipc.Client.get_descriptor"><code class="name flex">
<span>def <span class="ident">get_descriptor</span></span>(<span>self, model_type: Union[Type[~E], str], uid='', name='') ‑> Optional[<a title="olca.schema.Ref" href="schema.html#olca.schema.Ref">Ref</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get a descriptor of the model with the given ID or name from the database.</p>
<p>Models like product systems can be very large but often we just need
a reference to a model (e.g. in a calculation setup). In this case
this method can be useful.</p>
<p>since: openLCA 2.0</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>model_type</code></strong> :&ensp;<code>ModelType</code></dt>
<dd>The type of the model, e.g. olca.ProductSystem or <code>'ProductSystem'</code></dd>
<dt><strong><code>uid</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The ID of the model.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the model.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>schema.Ref</code></dt>
<dd>The descriptor of the model.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python">import olca

client = olca.Client()
system_ref = client.get_descriptor(
    olca.ProductSystem,
    'f50ee15a-968f-4316-a160-4c7741284c62')
print(system_ref.to_json())
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_descriptor(self, model_type: ModelType,
                   uid=&#39;&#39;, name=&#39;&#39;) -&gt; Optional[schema.Ref]:
    &#34;&#34;&#34;
    Get a descriptor of the model with the given ID or name from the database.

    Models like product systems can be very large but often we just need
    a reference to a model (e.g. in a calculation setup). In this case
    this method can be useful.

    since: openLCA 2.0

    Parameters
    ----------
    model_type: ModelType
        The type of the model, e.g. olca.ProductSystem or `&#39;ProductSystem&#39;`
    uid: str, optional
        The ID of the model.
    name: str, optional
        The name of the model.

    Returns
    -------
    schema.Ref
        The descriptor of the model.

    Example
    -------
    ```python
    import olca

    client = olca.Client()
    system_ref = client.get_descriptor(
        olca.ProductSystem,
        &#39;f50ee15a-968f-4316-a160-4c7741284c62&#39;)
    print(system_ref.to_json())
    ```
    &#34;&#34;&#34;

    params = {&#39;@type&#39;: _model_type(model_type)}
    if uid != &#39;&#39;:
        params[&#39;@id&#39;] = uid
    if name != &#39;&#39;:
        params[&#39;name&#39;] = name
    result, err = self.__post(&#39;get/descriptor&#39;, params)
    if err:
        log.error(&#39;failed to get descriptor: %s&#39;, err)
        return None
    return schema.Ref.from_json(result)</code></pre>
</details>
</dd>
<dt id="olca.ipc.Client.get_descriptors"><code class="name flex">
<span>def <span class="ident">get_descriptors</span></span>(<span>self, model_type: Union[Type[~E], str]) ‑> Iterator[<a title="olca.schema.Ref" href="schema.html#olca.schema.Ref">Ref</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the descriptors of the entities with the type from the database.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>model_type</code></strong> :&ensp;<code>ModelType</code></dt>
<dd>The model type, e.g. olca.Flow or <code>'Flow'</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Iterator[schema.Ref]</code></dt>
<dd>An iterator with Ref objects.</dd>
</dl>
<h2 id="example">Example:</h2>
<pre><code class="language-python">import olca

with olca.Client() as client:
    for a in client.get_descriptors('Actor'):
        print('found Actor: %s' % a.name)
    for s in client.get_descriptors(olca.Source):
        print('found Source: %s' % s.name)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_descriptors(self, model_type: ModelType) -&gt; Iterator[schema.Ref]:
    &#34;&#34;&#34;
    Get the descriptors of the entities with the type from the database.

    Parameters
    ----------
    model_type: ModelType
        The model type, e.g. olca.Flow or `&#39;Flow&#39;`

    Returns
    -------
    Iterator[schema.Ref]
        An iterator with Ref objects.

    Example:
    --------
    ```python
    import olca

    with olca.Client() as client:
        for a in client.get_descriptors(&#39;Actor&#39;):
            print(&#39;found Actor: %s&#39; % a.name)
        for s in client.get_descriptors(olca.Source):
            print(&#39;found Source: %s&#39; % s.name)
    ```

    &#34;&#34;&#34;
    params = {&#39;@type&#39;: _model_type(model_type)}
    result, err = self.__post(&#39;get/descriptors&#39;, params)
    if err:
        log.error(&#39;failed to get descriptors of type %s: %s&#39;,
                  model_type, err)
        return []
    for r in result:
        yield schema.Ref.from_json(r)</code></pre>
</details>
</dd>
<dt id="olca.ipc.Client.get_providers_of"><code class="name flex">
<span>def <span class="ident">get_providers_of</span></span>(<span>self, flow: Union[<a title="olca.schema.Ref" href="schema.html#olca.schema.Ref">Ref</a>, <a title="olca.schema.Flow" href="schema.html#olca.schema.Flow">Flow</a>]) ‑> Iterator[<a title="olca.schema.Ref" href="schema.html#olca.schema.Ref">Ref</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the providers for the given flow.</p>
<p>For products, these are the processes that have an output of the given
product. For waste flows, these are the waste treatment processes that
have this flow on the input side. Elementary flows do not have a
provider.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>flow</code></strong> :&ensp;<code>Union[schema.Ref, schema.Flow]</code></dt>
<dd>The flow or reference to the flow for which the providers should be
returned.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python">steel = client.get('Flow', 'Steel')
for provider in client.get_providers_of(steel):
    print(provider.name)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_providers_of(self, flow: Union[schema.Ref, schema.Flow]) \
        -&gt; Iterator[schema.Ref]:
    &#34;&#34;&#34;
    Get the providers for the given flow.

    For products, these are the processes that have an output of the given
    product. For waste flows, these are the waste treatment processes that
    have this flow on the input side. Elementary flows do not have a
    provider.

    Parameters
    ----------
    flow: Union[schema.Ref, schema.Flow]
        The flow or reference to the flow for which the providers should be
        returned.

    Example
    -------
    ```python
    steel = client.get(&#39;Flow&#39;, &#39;Steel&#39;)
    for provider in client.get_providers_of(steel):
        print(provider.name)
    ```
    &#34;&#34;&#34;
    params = {
        &#39;@type&#39;: &#39;Flow&#39;,
        &#39;@id&#39;: flow.id,
        &#39;name&#39;: flow.name,
    }
    providers, err = self.__post(&#39;get/providers&#39;, params)
    if err:
        log.error(&#39;failed to get providers: %s&#39;, err)
        return []
    for obj in providers:
        yield schema.Ref.from_json(obj)</code></pre>
</details>
</dd>
<dt id="olca.ipc.Client.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, model: ~E)</span>
</code></dt>
<dd>
<div class="desc"><p>Inserts the given model into the database of the IPC server.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python">import olca
import uuid

flow = olca.Flow()
flow.name = 'CO2'
flow.id = str(uuid.uuid4())
flow.flow_type = olca.FlowType.ELEMENTARY_FLOW
prop = olca.FlowPropertyFactor()
prop.flow_property = olca.ref(
    olca.FlowProperty,
    '93a60a56-a3c8-11da-a746-0800200b9a66',
    'Mass'
)
prop.conversion_factor = 1.0
prop.reference_flow_property = True
flow.flow_properties = [prop]
response = olca.Client().insert(flow)
print(response)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert(self, model: E):
    &#34;&#34;&#34;
    Inserts the given model into the database of the IPC server.

    Example
    -------
    ```python
    import olca
    import uuid

    flow = olca.Flow()
    flow.name = &#39;CO2&#39;
    flow.id = str(uuid.uuid4())
    flow.flow_type = olca.FlowType.ELEMENTARY_FLOW
    prop = olca.FlowPropertyFactor()
    prop.flow_property = olca.ref(
        olca.FlowProperty,
        &#39;93a60a56-a3c8-11da-a746-0800200b9a66&#39;,
        &#39;Mass&#39;
    )
    prop.conversion_factor = 1.0
    prop.reference_flow_property = True
    flow.flow_properties = [prop]
    response = olca.Client().insert(flow)
    print(response)
    ```

    &#34;&#34;&#34;
    if model is None:
        return
    json = model.to_json()
    resp, err = self.__post(&#39;insert/model&#39;, json)
    if err:
        log.error(&#39;failed to insert model: %s&#39;, err)
        return err
    return resp</code></pre>
</details>
</dd>
<dt id="olca.ipc.Client.lci_inputs"><code class="name flex">
<span>def <span class="ident">lci_inputs</span></span>(<span>self, result: <a title="olca.schema.SimpleResult" href="schema.html#olca.schema.SimpleResult">SimpleResult</a>) ‑> List[<a title="olca.schema.FlowResult" href="schema.html#olca.schema.FlowResult">FlowResult</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the inputs of the given inventory result.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python">result = client.calculate(setup)
# print the first input
print(client.lci_inputs(result)[0])
client.dispose(result)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lci_inputs(self, result: schema.SimpleResult) -&gt; List[schema.FlowResult]:
    &#34;&#34;&#34;
    Returns the inputs of the given inventory result.

    Example
    -------
    ```python
    result = client.calculate(setup)
    # print the first input
    print(client.lci_inputs(result)[0])
    client.dispose(result)
    ```
    &#34;&#34;&#34;
    raw, err = self.__post(&#39;get/inventory/inputs&#39;, {
        &#39;resultId&#39;: result.id,
    })
    if err:
        log.error(&#39;failed to get LCI inputs&#39;)
        return []
    return [schema.FlowResult.from_json(it) for it in raw]</code></pre>
</details>
</dd>
<dt id="olca.ipc.Client.lci_location_contributions"><code class="name flex">
<span>def <span class="ident">lci_location_contributions</span></span>(<span>self, result: <a title="olca.schema.SimpleResult" href="schema.html#olca.schema.SimpleResult">SimpleResult</a>, flow: <a title="olca.schema.Ref" href="schema.html#olca.schema.Ref">Ref</a>) ‑> List[<a title="olca.ipc.ContributionItem" href="#olca.ipc.ContributionItem">ContributionItem</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the contributions of the result of the given flow by location.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>result</code></strong> :&ensp;<code><a title="olca.schema.SimpleResult" href="schema.html#olca.schema.SimpleResult">SimpleResult</a></code></dt>
<dd>The result which needs to be at least a contribution result.</dd>
<dt><strong><code>flow</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="schema.html#olca.schema.Ref">Ref</a></code></dt>
<dd>The (reference of the) flow for which the calculations should be
calculated.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[<a title="olca.ipc.ContributionItem" href="#olca.ipc.ContributionItem">ContributionItem</a>]</code></dt>
<dd>The contributions to the flow result by location.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python"># ...
result = client.calculate(setup)
# select the first output of the LCI result
output = client.lci_outputs(result)[0]
# calculate the location contributions of the flow of that output
cons = client.lci_location_contributions(result, output.flow)
# ...
client.dispose(result)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lci_location_contributions(self, result: schema.SimpleResult,
                               flow: schema.Ref) -&gt; List[ContributionItem]:
    &#34;&#34;&#34;
    Get the contributions of the result of the given flow by location.

    Parameters
    ----------
    result: olca.schema.SimpleResult
        The result which needs to be at least a contribution result.

    flow: olca.schema.Ref
        The (reference of the) flow for which the calculations should be
        calculated.

    Returns
    -------
    list[ContributionItem]
        The contributions to the flow result by location.

    Example
    -------
    ```python
    # ...
    result = client.calculate(setup)
    # select the first output of the LCI result
    output = client.lci_outputs(result)[0]
    # calculate the location contributions of the flow of that output
    cons = client.lci_location_contributions(result, output.flow)
    # ...
    client.dispose(result)
    ```
    &#34;&#34;&#34;
    raw, err = self.__post(&#39;get/inventory/contributions/locations&#39;, {
        &#39;resultId&#39;: result.id,
        &#39;flow&#39;: flow.to_json(),
    })
    if err:
        log.error(&#39;failed to ger contributions by location&#39;)
        return []
    return [ContributionItem.from_json(it) for it in raw]</code></pre>
</details>
</dd>
<dt id="olca.ipc.Client.lci_outputs"><code class="name flex">
<span>def <span class="ident">lci_outputs</span></span>(<span>self, result: <a title="olca.schema.SimpleResult" href="schema.html#olca.schema.SimpleResult">SimpleResult</a>) ‑> List[dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the outputs of the given inventory result.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python">result = client.calculate(setup)
# print the first output
print(client.lci_outputs(result)[0])
client.dispose(result)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lci_outputs(self, result: schema.SimpleResult) -&gt; List[dict]:
    &#34;&#34;&#34;
    Returns the outputs of the given inventory result.

    Example
    -------
    ```python
    result = client.calculate(setup)
    # print the first output
    print(client.lci_outputs(result)[0])
    client.dispose(result)
    ```
    &#34;&#34;&#34;
    raw, err = self.__post(&#39;get/inventory/outputs&#39;, {
        &#39;resultId&#39;: result.id,
    })
    if err:
        log.error(&#39;failed to get LCI outputs: %s&#39;, err)
        return []
    return [schema.FlowResult.from_json(it) for it in raw]</code></pre>
</details>
</dd>
<dt id="olca.ipc.Client.lci_total_requirements"><code class="name flex">
<span>def <span class="ident">lci_total_requirements</span></span>(<span>self, result: <a title="olca.schema.SimpleResult" href="schema.html#olca.schema.SimpleResult">SimpleResult</a>) ‑> List[<a title="olca.ipc.ProductResult" href="#olca.ipc.ProductResult">ProductResult</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the total requirements of the given result.</p>
<p>The total requirements are the product amounts that are required to
fulfill the demand of the product system. As our technology matrix
<span><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span> is indexed symmetrically (means rows and columns refer to the
same process-product pair) our product amounts are on the diagonal of
the technology matrix and the total requirements can be calculated by
the following equation where <span><span class="MathJax_Preview">s</span><script type="math/tex">s</script></span> is the scaling vector (
<span><span class="MathJax_Preview">\odot</span><script type="math/tex">\odot</script></span> denotes element-wise multiplication):</p>
<p><span><span class="MathJax_Preview">t = diag(A) \odot s</span><script type="math/tex; mode=display">t = diag(A) \odot s</script></span></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>result</code></strong> :&ensp;<code><a title="olca.schema.SimpleResult" href="schema.html#olca.schema.SimpleResult">SimpleResult</a></code></dt>
<dd>The simple result from which the total requirements should be
returned.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python">import olca

client = olca.Client()
setup = olca.CalculationSetup()
setup.calculation_type = olca.CalculationType.UPSTREAM_ANALYSIS
setup.product_system = olca.ref(
    olca.ProductSystem,
    '7d1cbce0-b5b3-47ba-95b5-014ab3c7f569'
)
setup.amount = 1.0
result = client.calculate(setup)
print(client.lci_total_requirements(result)[0])
client.dispose(result)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lci_total_requirements(self, result: schema.SimpleResult) -&gt; List[ProductResult]:
    &#34;&#34;&#34;
    Returns the total requirements of the given result.

    The total requirements are the product amounts that are required to
    fulfill the demand of the product system. As our technology matrix
    \\(A\\) is indexed symmetrically (means rows and columns refer to the
    same process-product pair) our product amounts are on the diagonal of
    the technology matrix and the total requirements can be calculated by
    the following equation where \\(s\\) is the scaling vector (
    \\(\\odot\\) denotes element-wise multiplication):

    $$t = diag(A) \odot s$$

    Parameters
    ----------
    result: olca.schema.SimpleResult
        The simple result from which the total requirements should be
        returned.

    Example
    -------
    ```python
    import olca

    client = olca.Client()
    setup = olca.CalculationSetup()
    setup.calculation_type = olca.CalculationType.UPSTREAM_ANALYSIS
    setup.product_system = olca.ref(
        olca.ProductSystem,
        &#39;7d1cbce0-b5b3-47ba-95b5-014ab3c7f569&#39;
    )
    setup.amount = 1.0
    result = client.calculate(setup)
    print(client.lci_total_requirements(result)[0])
    client.dispose(result)
    ```
    &#34;&#34;&#34;

    raw, err = self.__post(&#39;get/inventory/total_requirements&#39;, {
        &#39;resultId&#39;: result.id
    })
    if err:
        log.error(&#39;failed to get total requirements %s&#39;, err)
        return []
    return [ProductResult.from_json(it) for it in raw]</code></pre>
</details>
</dd>
<dt id="olca.ipc.Client.lcia"><code class="name flex">
<span>def <span class="ident">lcia</span></span>(<span>self, result: <a title="olca.schema.SimpleResult" href="schema.html#olca.schema.SimpleResult">SimpleResult</a>) ‑> List[<a title="olca.schema.ImpactResult" href="schema.html#olca.schema.ImpactResult">ImpactResult</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the LCIA result of the given result.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>result</code></strong> :&ensp;<code><a title="olca.schema.SimpleResult" href="schema.html#olca.schema.SimpleResult">SimpleResult</a></code></dt>
<dd>The result from which the LCIA result should be returned.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python"># ...
result = client.calculate(setup)
lcia = client.lcia(result)
# ...
client.dispose(result)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lcia(self, result: schema.SimpleResult) -&gt; List[schema.ImpactResult]:
    &#34;&#34;&#34;
    Returns the LCIA result of the given result.

    Parameters
    ----------
    result: olca.schema.SimpleResult
        The result from which the LCIA result should be returned.

    Example
    -------
    ```python
    # ...
    result = client.calculate(setup)
    lcia = client.lcia(result)
    # ...
    client.dispose(result)
    ```
    &#34;&#34;&#34;

    raw, err = self.__post(&#39;get/impacts&#39;, {
        &#39;resultId&#39;: result.id,
    })
    if err:
        log.error(&#39;failed to get impact results: %s&#39;, err)
        return []
    return [schema.ImpactResult.from_json(it) for it in raw]</code></pre>
</details>
</dd>
<dt id="olca.ipc.Client.lcia_flow_contributions"><code class="name flex">
<span>def <span class="ident">lcia_flow_contributions</span></span>(<span>self, result: <a title="olca.schema.SimpleResult" href="schema.html#olca.schema.SimpleResult">SimpleResult</a>, impact: <a title="olca.schema.Ref" href="schema.html#olca.schema.Ref">Ref</a>) ‑> List[<a title="olca.ipc.ContributionItem" href="#olca.ipc.ContributionItem">ContributionItem</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the flow contributions to the result of the given impact category.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>result</code></strong> :&ensp;<code><a title="olca.schema.SimpleResult" href="schema.html#olca.schema.SimpleResult">SimpleResult</a></code></dt>
<dd>The result.</dd>
<dt><strong><code>impact</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="schema.html#olca.schema.Ref">Ref</a></code></dt>
<dd>The (reference to the) LCIA category.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python"># ...
result = client.calculate(setup)
# select the first LCIA result
impact_result = client.lcia(result)[0]
# get the flow contributions to the LCIA category of that result
cons = client.lcia_flow_contributions(
    result, impact_result.impact_category)
# ...
client.dispose(result)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lcia_flow_contributions(self, result: schema.SimpleResult,
                            impact: schema.Ref) -&gt; List[ContributionItem]:
    &#34;&#34;&#34;
    Get the flow contributions to the result of the given impact category.

    Parameters
    ----------
    result: olca.schema.SimpleResult
        The result.

    impact: olca.schema.Ref
        The (reference to the) LCIA category.

    Example
    -------
    ```python
    # ...
    result = client.calculate(setup)
    # select the first LCIA result
    impact_result = client.lcia(result)[0]
    # get the flow contributions to the LCIA category of that result
    cons = client.lcia_flow_contributions(
        result, impact_result.impact_category)
    # ...
    client.dispose(result)
    ```
    &#34;&#34;&#34;

    raw, err = self.__post(&#39;get/impacts/contributions/flows&#39;, {
        &#39;resultId&#39;: result.id,
        &#39;impactCategory&#39;: impact.to_json(),
    })
    if err:
        log.error(&#39;failed to get contribution items: %s&#39;, err)
        return []
    return [ContributionItem.from_json(it) for it in raw]</code></pre>
</details>
</dd>
<dt id="olca.ipc.Client.lcia_location_contributions"><code class="name flex">
<span>def <span class="ident">lcia_location_contributions</span></span>(<span>self, result: <a title="olca.schema.SimpleResult" href="schema.html#olca.schema.SimpleResult">SimpleResult</a>, impact: <a title="olca.schema.Ref" href="schema.html#olca.schema.Ref">Ref</a>) ‑> List[<a title="olca.ipc.ContributionItem" href="#olca.ipc.ContributionItem">ContributionItem</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the contributions to the result of the given impact category by
locations.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>result</code></strong> :&ensp;<code><a title="olca.schema.SimpleResult" href="schema.html#olca.schema.SimpleResult">SimpleResult</a></code></dt>
<dd>The result.</dd>
<dt><strong><code>impact</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="schema.html#olca.schema.Ref">Ref</a></code></dt>
<dd>The (reference to the) LCIA category.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python"># ...
result = client.calculate(setup)
# select the first LCIA result
impact_result = client.lcia(result)[0]
# get the flow contributions to the LCIA category of that result
cons = client.lcia_location_contributions(
    result, impact_result.impact_category)
# ...
client.dispose(result)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lcia_location_contributions(self, result: schema.SimpleResult,
                                impact: schema.Ref) -&gt; List[ContributionItem]:
    &#34;&#34;&#34;
    Get the contributions to the result of the given impact category by
    locations.

    Parameters
    ----------
    result: olca.schema.SimpleResult
        The result.

    impact: olca.schema.Ref
        The (reference to the) LCIA category.


    Example
    -------
    ```python
    # ...
    result = client.calculate(setup)
    # select the first LCIA result
    impact_result = client.lcia(result)[0]
    # get the flow contributions to the LCIA category of that result
    cons = client.lcia_location_contributions(
        result, impact_result.impact_category)
    # ...
    client.dispose(result)
    ```
    &#34;&#34;&#34;

    raw, err = self.__post(&#39;get/impacts/contributions/locations&#39;, {
        &#39;resultId&#39;: result.id,
        &#39;impactCategory&#39;: impact.to_json(),
    })
    if err:
        log.error(&#39;Failed to get contribution items: %s&#39;, err)
        return []
    return [ContributionItem.from_json(it) for it in raw]</code></pre>
</details>
</dd>
<dt id="olca.ipc.Client.lcia_process_contributions"><code class="name flex">
<span>def <span class="ident">lcia_process_contributions</span></span>(<span>self, result: <a title="olca.schema.SimpleResult" href="schema.html#olca.schema.SimpleResult">SimpleResult</a>, impact: <a title="olca.schema.Ref" href="schema.html#olca.schema.Ref">Ref</a>) ‑> List[<a title="olca.ipc.ContributionItem" href="#olca.ipc.ContributionItem">ContributionItem</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the contributions to the result of the given impact category by
processes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>result</code></strong> :&ensp;<code><a title="olca.schema.SimpleResult" href="schema.html#olca.schema.SimpleResult">SimpleResult</a></code></dt>
<dd>The result.</dd>
<dt><strong><code>impact</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="schema.html#olca.schema.Ref">Ref</a></code></dt>
<dd>The (reference to the) LCIA category.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python"># ...
result = client.calculate(setup)
# select the first LCIA result
impact_result = client.lcia(result)[0]
# get the flow contributions to the LCIA category of that result
cons = client.lcia_process_contributions(
    result, impact_result.impact_category)
# ...
client.dispose(result)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lcia_process_contributions(self, result: schema.SimpleResult,
                               impact: schema.Ref) -&gt; List[ContributionItem]:
    &#34;&#34;&#34;
    Get the contributions to the result of the given impact category by
    processes.

    Parameters
    ----------
    result: olca.schema.SimpleResult
        The result.

    impact: olca.schema.Ref
        The (reference to the) LCIA category.


    Example
    -------
    ```python
    # ...
    result = client.calculate(setup)
    # select the first LCIA result
    impact_result = client.lcia(result)[0]
    # get the flow contributions to the LCIA category of that result
    cons = client.lcia_process_contributions(
        result, impact_result.impact_category)
    # ...
    client.dispose(result)
    ```
    &#34;&#34;&#34;

    raw, err = self.__post(&#39;get/impacts/contributions/processes&#39;, {
        &#39;resultId&#39;: result.id,
        &#39;impactCategory&#39;: impact.to_json(),
    })
    if err:
        log.error(&#39;Failed to get contribution items: %s&#39;, err)
        return []
    return [ContributionItem.from_json(it) for it in raw]</code></pre>
</details>
</dd>
<dt id="olca.ipc.Client.next_simulation"><code class="name flex">
<span>def <span class="ident">next_simulation</span></span>(<span>self, simulator: <a title="olca.schema.Ref" href="schema.html#olca.schema.Ref">Ref</a>) ‑> <a title="olca.schema.SimpleResult" href="schema.html#olca.schema.SimpleResult">SimpleResult</a></span>
</code></dt>
<dd>
<div class="desc"><p>Runs the next Monte-Carlo simulation with the given simulator reference.
It returns the result of the simulation. Note that this result is not
cached (the simulator is cached).
See <a href="#olca.ipc.Client.simulator">the simulator example</a>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>simulator</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="schema.html#olca.schema.Ref">Ref</a></code></dt>
<dd>The reference to the simulator which is called to run the next
simulation step.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def next_simulation(self, simulator: schema.Ref) -&gt; schema.SimpleResult:
    &#34;&#34;&#34;
    Runs the next Monte-Carlo simulation with the given simulator reference.
    It returns the result of the simulation. Note that this result is not
    cached (the simulator is cached).
    See [the simulator example](#olca.ipc.Client.simulator).

    Parameters
    ----------
    simulator: olca.schema.Ref
        The reference to the simulator which is called to run the next
        simulation step.

    &#34;&#34;&#34;
    if simulator is None:
        raise ValueError(&#39;No simulator given&#39;)
    resp, err = self.__post(&#39;next/simulation&#39;, simulator.to_json())
    if err:
        log.error(&#39;failed to get simulation result: %s&#39;, err)
        return schema.SimpleResult()
    return schema.SimpleResult.from_json(resp)</code></pre>
</details>
</dd>
<dt id="olca.ipc.Client.shutdown_server"><code class="name flex">
<span>def <span class="ident">shutdown_server</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Close the database and shutdown the server.</p>
<p>This method is probably most useful when running a headless server
(a server without openLCA user interface).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shutdown_server(self):
    &#34;&#34;&#34;
    Close the database and shutdown the server.

    This method is probably most useful when running a headless server
    (a server without openLCA user interface).
    &#34;&#34;&#34;
    _, err = self.__post(&#39;runtime/shutdown&#39;, None)
    if err:
        log.error(&#39;failed to shutdown server: %s&#39;, err)</code></pre>
</details>
</dd>
<dt id="olca.ipc.Client.simulator"><code class="name flex">
<span>def <span class="ident">simulator</span></span>(<span>self, setup: <a title="olca.schema.CalculationSetup" href="schema.html#olca.schema.CalculationSetup">CalculationSetup</a>) ‑> <a title="olca.schema.Ref" href="schema.html#olca.schema.Ref">Ref</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a simulator to run Monte-Carlo simulations for the given setup.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>setup</code></strong> :&ensp;<code><a title="olca.schema.CalculationSetup" href="schema.html#olca.schema.CalculationSetup">CalculationSetup</a></code></dt>
<dd>The calculation setup that should be used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="olca.schema.Ref" href="schema.html#olca.schema.Ref">Ref</a></code></dt>
<dd>A reference to an simulator instance.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python">import olca

client = olca.Client()
# creating the calculation setup
setup = olca.CalculationSetup()
setup.calculation_type = olca.CalculationType.MONTE_CARLO_SIMULATION
setup.impact_method = client.find(olca.ImpactMethod, 'TRACI [v2.1, February 2014]')
setup.product_system = client.find(olca.ProductSystem, 'compost plant, open')
setup.amount = 1.0

# create the simulator
simulator = client.simulator(setup)

for i in range(0, 10):
    result = client.next_simulation(simulator)
    first_impact = result.impact_results[0]
    print('iteration %i: result for %s = %4.4f' %
          (i, first_impact.impact_category.name, first_impact.value))
    # we do not have to dispose the result here (it is not cached
    # in openLCA); but we need to dispose the simulator later (see below)

# export the complete result of all simulations
client.excel_export(simulator, 'simulation_result.xlsx')

# the result remains accessible (for exports etc.) until
# you dispose it, which you should always do when you do
# not need it anymore
client.dispose(simulator)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulator(self, setup: schema.CalculationSetup) -&gt; schema.Ref:
    &#34;&#34;&#34;
    Create a simulator to run Monte-Carlo simulations for the given setup.

    Parameters
    ----------

    setup: olca.schema.CalculationSetup
        The calculation setup that should be used.

    Returns
    -------

    olca.schema.Ref
        A reference to an simulator instance.

    Example
    -------
    ```python
    import olca

    client = olca.Client()
    # creating the calculation setup
    setup = olca.CalculationSetup()
    setup.calculation_type = olca.CalculationType.MONTE_CARLO_SIMULATION
    setup.impact_method = client.find(olca.ImpactMethod, &#39;TRACI [v2.1, February 2014]&#39;)
    setup.product_system = client.find(olca.ProductSystem, &#39;compost plant, open&#39;)
    setup.amount = 1.0

    # create the simulator
    simulator = client.simulator(setup)

    for i in range(0, 10):
        result = client.next_simulation(simulator)
        first_impact = result.impact_results[0]
        print(&#39;iteration %i: result for %s = %4.4f&#39; %
              (i, first_impact.impact_category.name, first_impact.value))
        # we do not have to dispose the result here (it is not cached
        # in openLCA); but we need to dispose the simulator later (see below)

    # export the complete result of all simulations
    client.excel_export(simulator, &#39;simulation_result.xlsx&#39;)

    # the result remains accessible (for exports etc.) until
    # you dispose it, which you should always do when you do
    # not need it anymore
    client.dispose(simulator)
    ```
    &#34;&#34;&#34;
    resp, err = self.__post(&#39;simulator&#39;, setup.to_json())
    if err:
        log.error(&#39;failed to create simulator: %s&#39;, err)
        return schema.Ref()
    return schema.Ref.from_json(resp)</code></pre>
</details>
</dd>
<dt id="olca.ipc.Client.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, model: ~E)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the given model in the database of the IPC server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, model: E):
    &#34;&#34;&#34;
    Update the given model in the database of the IPC server.
    &#34;&#34;&#34;
    if model is None:
        return
    json = model.to_json()
    resp, err = self.__post(&#39;update/model&#39;, json)
    if err:
        log.error(&#39;failed to update model: %s&#39;, err)
        return err
    return resp</code></pre>
</details>
</dd>
<dt id="olca.ipc.Client.upstream_tree_of"><code class="name flex">
<span>def <span class="ident">upstream_tree_of</span></span>(<span>self, result: <a title="olca.schema.SimpleResult" href="schema.html#olca.schema.SimpleResult">SimpleResult</a>, ref: <a title="olca.schema.Ref" href="schema.html#olca.schema.Ref">Ref</a>, max_depth=5, min_contribution=0.1, max_recursion_depth=3) ‑> Optional[<a title="olca.upstream_tree.UpstreamTree" href="upstream_tree.html#olca.upstream_tree.UpstreamTree">UpstreamTree</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get an upstream tree for an impact category or flow.</p>
<p>This function is only available in openLCA 2.x.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>result</code></strong> :&ensp;<code><a title="olca.schema.SimpleResult" href="schema.html#olca.schema.SimpleResult">SimpleResult</a></code></dt>
<dd>The previously calculated result. This needs to be an upstream
result.</dd>
<dt><strong><code>ref</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="schema.html#olca.schema.Ref">Ref</a></code></dt>
<dd>The result reference of the upstream tree: a flow or impact
category reference.</dd>
<dt><strong><code>max_depth</code></strong> :&ensp;<code>int</code></dt>
<dd>The maximum number of levels of the tree. A value &lt; 0 means
unlimited. In this case reasonable recursion limits are
required if the underlying product system has cycles.</dd>
<dt><strong><code>min_contribution</code></strong> :&ensp;<code>float</code></dt>
<dd>In addition to the maximum tree depth, this parameter describes
the minimum upstream contribution of a node in the tree. A value
&lt; 0 means that there is no minimum contribution.</dd>
<dt><strong><code>max_recursion_depth</code></strong> :&ensp;<code>int</code></dt>
<dd>When the max. tree depth is unlimited and the underlying product
system has cycles, this parameter indicates how often a process
can occur in a tree path. It defines the maximum number of
expansions of a loop in a tree path.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python">client = olca.Client()

# create the calculation setup and run the calculation
setup = olca.CalculationSetup()
setup.calculation_type = olca.CalculationType.UPSTREAM_ANALYSIS
setup.product_system = olca.ref(
    olca.ProductSystem,
    '7d1cbce0-b5b3-47ba-95b5-014ab3c7f569'
)
setup.impact_method = olca.ref(
    olca.ImpactMethod,
    '99b9d86b-ec6f-4610-ba9f-68ebfe5691dd'
)
setup.amount = 1.0
result = client.calculate(setup)

# calculate the upstream tree and traverse it
impact = olca.ref(
    olca.ImpactCategory,
    '2a26b243-23cb-4f90-baab-239d3d7397fa')
tree = client.upstream_tree_of(result, impact)

def traversal_handler(n: tuple[UpstreamNode, int]):
    (node, depth) = n
    print('%s+ %s %.3f' % (
        '  ' * depth,
        node.product.process.name,
        node.result
    ))

tree.traverse(traversal_handler)

# dispose the result
client.dispose(result)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def upstream_tree_of(self, result: schema.SimpleResult, ref: schema.Ref,
                     max_depth=5, min_contribution=0.1,
                     max_recursion_depth=3) -&gt; Optional[utree.UpstreamTree]:
    &#34;&#34;&#34;
    Get an upstream tree for an impact category or flow.

    This function is only available in openLCA 2.x.

    Parameters
    ----------
    result: olca.schema.SimpleResult
        The previously calculated result. This needs to be an upstream
        result.

    ref: olca.schema.Ref
        The result reference of the upstream tree: a flow or impact
        category reference.

    max_depth: int
        The maximum number of levels of the tree. A value &lt; 0 means
        unlimited. In this case reasonable recursion limits are
        required if the underlying product system has cycles.

    min_contribution: float
        In addition to the maximum tree depth, this parameter describes
        the minimum upstream contribution of a node in the tree. A value
        &lt; 0 means that there is no minimum contribution.

    max_recursion_depth: int
        When the max. tree depth is unlimited and the underlying product
        system has cycles, this parameter indicates how often a process
        can occur in a tree path. It defines the maximum number of
        expansions of a loop in a tree path.

    Example
    -------
    ```python
    client = olca.Client()

    # create the calculation setup and run the calculation
    setup = olca.CalculationSetup()
    setup.calculation_type = olca.CalculationType.UPSTREAM_ANALYSIS
    setup.product_system = olca.ref(
        olca.ProductSystem,
        &#39;7d1cbce0-b5b3-47ba-95b5-014ab3c7f569&#39;
    )
    setup.impact_method = olca.ref(
        olca.ImpactMethod,
        &#39;99b9d86b-ec6f-4610-ba9f-68ebfe5691dd&#39;
    )
    setup.amount = 1.0
    result = client.calculate(setup)

    # calculate the upstream tree and traverse it
    impact = olca.ref(
        olca.ImpactCategory,
        &#39;2a26b243-23cb-4f90-baab-239d3d7397fa&#39;)
    tree = client.upstream_tree_of(result, impact)

    def traversal_handler(n: tuple[UpstreamNode, int]):
        (node, depth) = n
        print(&#39;%s+ %s %.3f&#39; % (
            &#39;  &#39; * depth,
            node.product.process.name,
            node.result
        ))

    tree.traverse(traversal_handler)

    # dispose the result
    client.dispose(result)
    ```
    &#34;&#34;&#34;
    raw, err = self.__post(&#39;get/upstream/tree&#39;, {
        &#39;resultId&#39;: result.id,
        &#39;ref&#39;: ref.to_json(),
        &#39;maxDepth&#39;: max_depth,
        &#39;minContribution&#39;: min_contribution,
        &#39;maxRecursionDepth&#39;: max_recursion_depth
    })
    if err:
        log.error(&#39;Failed to get upstream tree: %s&#39;, err)
        return None
    return utree.UpstreamTree.from_json(raw)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.ipc.ContributionItem"><code class="flex name class">
<span>class <span class="ident">ContributionItem</span></span>
<span>(</span><span>id: str = '', olca_type: str = '', item: Optional[<a title="olca.schema.Ref" href="schema.html#olca.schema.Ref">Ref</a>] = None, amount: Optional[float] = None, share: Optional[float] = None, rest: Optional[bool] = None, unit: Optional[str] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>The ContributionItem type is not an olca-schema type but a return
type of the IPC protocol. However, it implements the same interface
as the olca.schema.Entity type.</p>
<h2 id="attributes">Attributes:</h2>
<p>item: olca.schema.Ref</p>
<p>amount: float</p>
<p>share: float</p>
<p>rest: bool</p>
<p>unit: str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class ContributionItem(schema.Entity):
    &#34;&#34;&#34;
    The ContributionItem type is not an olca-schema type but a return
    type of the IPC protocol. However, it implements the same interface
    as the olca.schema.Entity type.

    Attributes:
    -----------
    item: olca.schema.Ref

    amount: float

    share: float

    rest: bool

    unit: str

    &#34;&#34;&#34;

    item: Optional[schema.Ref] = None
    amount: Optional[float] = None
    share: Optional[float] = None
    rest: Optional[bool] = None
    unit: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ContributionItem, self).to_json()
        if self.item is not None:
            json[&#39;item&#39;] = self.item.to_json()
        if self.amount is not None:
            json[&#39;amount&#39;] = self.amount
        if self.share is not None:
            json[&#39;share&#39;] = self.share
        if self.rest is not None:
            json[&#39;rest&#39;] = self.rest
        if self.unit is not None:
            json[&#39;unit&#39;] = self.unit
        return json

    def read_json(self, json: dict):
        super(ContributionItem, self).read_json(json)
        val = json.get(&#39;item&#39;)
        if val is not None:
            self.item = schema.Ref.from_json(val)
        val = json.get(&#39;amount&#39;)
        if val is not None:
            self.amount = val
        val = json.get(&#39;share&#39;)
        if val is not None:
            self.share = val
        val = json.get(&#39;rest&#39;)
        if val is not None:
            self.rest = val
        val = json.get(&#39;unit&#39;)
        if val is not None:
            self.unit = val

    @staticmethod
    def from_json(json: dict):
        instance = ContributionItem()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="schema.html#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.ipc.ContributionItem.amount"><code class="name">var <span class="ident">amount</span> : Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.ipc.ContributionItem.item"><code class="name">var <span class="ident">item</span> : Optional[<a title="olca.schema.Ref" href="schema.html#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.ipc.ContributionItem.rest"><code class="name">var <span class="ident">rest</span> : Optional[bool]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.ipc.ContributionItem.share"><code class="name">var <span class="ident">share</span> : Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.ipc.ContributionItem.unit"><code class="name">var <span class="ident">unit</span> : Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.ipc.ContributionItem.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = ContributionItem()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.ipc.ContributionItem.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(ContributionItem, self).read_json(json)
    val = json.get(&#39;item&#39;)
    if val is not None:
        self.item = schema.Ref.from_json(val)
    val = json.get(&#39;amount&#39;)
    if val is not None:
        self.amount = val
    val = json.get(&#39;share&#39;)
    if val is not None:
        self.share = val
    val = json.get(&#39;rest&#39;)
    if val is not None:
        self.rest = val
    val = json.get(&#39;unit&#39;)
    if val is not None:
        self.unit = val</code></pre>
</details>
</dd>
<dt id="olca.ipc.ContributionItem.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(ContributionItem, self).to_json()
    if self.item is not None:
        json[&#39;item&#39;] = self.item.to_json()
    if self.amount is not None:
        json[&#39;amount&#39;] = self.amount
    if self.share is not None:
        json[&#39;share&#39;] = self.share
    if self.rest is not None:
        json[&#39;rest&#39;] = self.rest
    if self.unit is not None:
        json[&#39;unit&#39;] = self.unit
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.ipc.ProductResult"><code class="flex name class">
<span>class <span class="ident">ProductResult</span></span>
<span>(</span><span>id: str = '', olca_type: str = '', process: Optional[<a title="olca.schema.Ref" href="schema.html#olca.schema.Ref">Ref</a>] = None, product: Optional[<a title="olca.schema.Ref" href="schema.html#olca.schema.Ref">Ref</a>] = None, amount: Optional[float] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>The ProductResult type is not an olca-schema type but a return
type of the IPC protocol. However, it implements the same interface
as the olca.schema.Entity type.</p>
<h2 id="attributes">Attributes:</h2>
<p>process: olca.schema.Ref</p>
<p>product: olca.schema.Ref</p>
<p>amount: float</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class ProductResult(schema.Entity):
    &#34;&#34;&#34;
    The ProductResult type is not an olca-schema type but a return
    type of the IPC protocol. However, it implements the same interface
    as the olca.schema.Entity type.

    Attributes:
    -----------
    process: olca.schema.Ref

    product: olca.schema.Ref

    amount: float

    &#34;&#34;&#34;
    process: Optional[schema.Ref] = None
    product: Optional[schema.Ref] = None
    amount: Optional[float] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ProductResult, self).to_json()
        if self.process is not None:
            json[&#39;process&#39;] = self.process.to_json()
        if self.product is not None:
            json[&#39;product&#39;] = self.product.to_json()
        if self.amount is not None:
            json[&#39;amount&#39;] = self.amount
        return json

    def read_json(self, json: dict):
        super(ProductResult, self).read_json(json)
        val = json.get(&#39;process&#39;)
        if val is not None:
            self.process = schema.Ref.from_json(val)
        val = json.get(&#39;product&#39;)
        if val is not None:
            self.product = schema.Ref.from_json(val)
        val = json.get(&#39;amount&#39;)
        if val is not None:
            self.amount = val

    @staticmethod
    def from_json(json: dict):
        instance = ProductResult()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="schema.html#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.ipc.ProductResult.amount"><code class="name">var <span class="ident">amount</span> : Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.ipc.ProductResult.process"><code class="name">var <span class="ident">process</span> : Optional[<a title="olca.schema.Ref" href="schema.html#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.ipc.ProductResult.product"><code class="name">var <span class="ident">product</span> : Optional[<a title="olca.schema.Ref" href="schema.html#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.ipc.ProductResult.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = ProductResult()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.ipc.ProductResult.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(ProductResult, self).read_json(json)
    val = json.get(&#39;process&#39;)
    if val is not None:
        self.process = schema.Ref.from_json(val)
    val = json.get(&#39;product&#39;)
    if val is not None:
        self.product = schema.Ref.from_json(val)
    val = json.get(&#39;amount&#39;)
    if val is not None:
        self.amount = val</code></pre>
</details>
</dd>
<dt id="olca.ipc.ProductResult.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(ProductResult, self).to_json()
    if self.process is not None:
        json[&#39;process&#39;] = self.process.to_json()
    if self.product is not None:
        json[&#39;product&#39;] = self.product.to_json()
    if self.amount is not None:
        json[&#39;amount&#39;] = self.amount
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="olca" href="index.html">olca</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="olca.ipc.Client" href="#olca.ipc.Client">Client</a></code></h4>
<ul class="">
<li><code><a title="olca.ipc.Client.calculate" href="#olca.ipc.Client.calculate">calculate</a></code></li>
<li><code><a title="olca.ipc.Client.close" href="#olca.ipc.Client.close">close</a></code></li>
<li><code><a title="olca.ipc.Client.create_product_system" href="#olca.ipc.Client.create_product_system">create_product_system</a></code></li>
<li><code><a title="olca.ipc.Client.delete" href="#olca.ipc.Client.delete">delete</a></code></li>
<li><code><a title="olca.ipc.Client.dispose" href="#olca.ipc.Client.dispose">dispose</a></code></li>
<li><code><a title="olca.ipc.Client.excel_export" href="#olca.ipc.Client.excel_export">excel_export</a></code></li>
<li><code><a title="olca.ipc.Client.find" href="#olca.ipc.Client.find">find</a></code></li>
<li><code><a title="olca.ipc.Client.get" href="#olca.ipc.Client.get">get</a></code></li>
<li><code><a title="olca.ipc.Client.get_all" href="#olca.ipc.Client.get_all">get_all</a></code></li>
<li><code><a title="olca.ipc.Client.get_descriptor" href="#olca.ipc.Client.get_descriptor">get_descriptor</a></code></li>
<li><code><a title="olca.ipc.Client.get_descriptors" href="#olca.ipc.Client.get_descriptors">get_descriptors</a></code></li>
<li><code><a title="olca.ipc.Client.get_providers_of" href="#olca.ipc.Client.get_providers_of">get_providers_of</a></code></li>
<li><code><a title="olca.ipc.Client.insert" href="#olca.ipc.Client.insert">insert</a></code></li>
<li><code><a title="olca.ipc.Client.lci_inputs" href="#olca.ipc.Client.lci_inputs">lci_inputs</a></code></li>
<li><code><a title="olca.ipc.Client.lci_location_contributions" href="#olca.ipc.Client.lci_location_contributions">lci_location_contributions</a></code></li>
<li><code><a title="olca.ipc.Client.lci_outputs" href="#olca.ipc.Client.lci_outputs">lci_outputs</a></code></li>
<li><code><a title="olca.ipc.Client.lci_total_requirements" href="#olca.ipc.Client.lci_total_requirements">lci_total_requirements</a></code></li>
<li><code><a title="olca.ipc.Client.lcia" href="#olca.ipc.Client.lcia">lcia</a></code></li>
<li><code><a title="olca.ipc.Client.lcia_flow_contributions" href="#olca.ipc.Client.lcia_flow_contributions">lcia_flow_contributions</a></code></li>
<li><code><a title="olca.ipc.Client.lcia_location_contributions" href="#olca.ipc.Client.lcia_location_contributions">lcia_location_contributions</a></code></li>
<li><code><a title="olca.ipc.Client.lcia_process_contributions" href="#olca.ipc.Client.lcia_process_contributions">lcia_process_contributions</a></code></li>
<li><code><a title="olca.ipc.Client.next_simulation" href="#olca.ipc.Client.next_simulation">next_simulation</a></code></li>
<li><code><a title="olca.ipc.Client.shutdown_server" href="#olca.ipc.Client.shutdown_server">shutdown_server</a></code></li>
<li><code><a title="olca.ipc.Client.simulator" href="#olca.ipc.Client.simulator">simulator</a></code></li>
<li><code><a title="olca.ipc.Client.update" href="#olca.ipc.Client.update">update</a></code></li>
<li><code><a title="olca.ipc.Client.upstream_tree_of" href="#olca.ipc.Client.upstream_tree_of">upstream_tree_of</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.ipc.ContributionItem" href="#olca.ipc.ContributionItem">ContributionItem</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.ipc.ContributionItem.amount" href="#olca.ipc.ContributionItem.amount">amount</a></code></li>
<li><code><a title="olca.ipc.ContributionItem.from_json" href="#olca.ipc.ContributionItem.from_json">from_json</a></code></li>
<li><code><a title="olca.ipc.ContributionItem.item" href="#olca.ipc.ContributionItem.item">item</a></code></li>
<li><code><a title="olca.ipc.ContributionItem.read_json" href="#olca.ipc.ContributionItem.read_json">read_json</a></code></li>
<li><code><a title="olca.ipc.ContributionItem.rest" href="#olca.ipc.ContributionItem.rest">rest</a></code></li>
<li><code><a title="olca.ipc.ContributionItem.share" href="#olca.ipc.ContributionItem.share">share</a></code></li>
<li><code><a title="olca.ipc.ContributionItem.to_json" href="#olca.ipc.ContributionItem.to_json">to_json</a></code></li>
<li><code><a title="olca.ipc.ContributionItem.unit" href="#olca.ipc.ContributionItem.unit">unit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.ipc.ProductResult" href="#olca.ipc.ProductResult">ProductResult</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.ipc.ProductResult.amount" href="#olca.ipc.ProductResult.amount">amount</a></code></li>
<li><code><a title="olca.ipc.ProductResult.from_json" href="#olca.ipc.ProductResult.from_json">from_json</a></code></li>
<li><code><a title="olca.ipc.ProductResult.process" href="#olca.ipc.ProductResult.process">process</a></code></li>
<li><code><a title="olca.ipc.ProductResult.product" href="#olca.ipc.ProductResult.product">product</a></code></li>
<li><code><a title="olca.ipc.ProductResult.read_json" href="#olca.ipc.ProductResult.read_json">read_json</a></code></li>
<li><code><a title="olca.ipc.ProductResult.to_json" href="#olca.ipc.ProductResult.to_json">to_json</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>