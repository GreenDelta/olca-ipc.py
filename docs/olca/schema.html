<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>olca.schema API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>olca.schema</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># This module contains a Python API of the JSON-LD based
# openLCA data exchange model.package schema.
# For more information see http://greendelta.github.io/olca-schema/

from enum import Enum
from typing import List, Optional


class AllocationType(Enum):
    &#34;&#34;&#34;
    An enumeration type for allocation methods. This type is used to define the
    type of an [AllocationFactor], the default allocation method of a
    multi-functional [Process], or the allocation method in a
    [CalculationSetup].
    &#34;&#34;&#34;

    PHYSICAL_ALLOCATION = &#39;PHYSICAL_ALLOCATION&#39;
    ECONOMIC_ALLOCATION = &#39;ECONOMIC_ALLOCATION&#39;
    CAUSAL_ALLOCATION = &#39;CAUSAL_ALLOCATION&#39;
    USE_DEFAULT_ALLOCATION = &#39;USE_DEFAULT_ALLOCATION&#39;
    NO_ALLOCATION = &#39;NO_ALLOCATION&#39;


class CalculationType(Enum):
    &#34;&#34;&#34;
    An enumeration of the different calculation methods supported by openLCA.
    &#34;&#34;&#34;

    SIMPLE_CALCULATION = &#39;SIMPLE_CALCULATION&#39;
    CONTRIBUTION_ANALYSIS = &#39;CONTRIBUTION_ANALYSIS&#39;
    UPSTREAM_ANALYSIS = &#39;UPSTREAM_ANALYSIS&#39;
    REGIONALIZED_CALCULATION = &#39;REGIONALIZED_CALCULATION&#39;
    MONTE_CARLO_SIMULATION = &#39;MONTE_CARLO_SIMULATION&#39;


class FlowPropertyType(Enum):
    &#34;&#34;&#34;
    An enumeration of flow property types.
    &#34;&#34;&#34;

    ECONOMIC_QUANTITY = &#39;ECONOMIC_QUANTITY&#39;
    PHYSICAL_QUANTITY = &#39;PHYSICAL_QUANTITY&#39;


class FlowType(Enum):
    &#34;&#34;&#34;
    The basic flow types.
    &#34;&#34;&#34;

    ELEMENTARY_FLOW = &#39;ELEMENTARY_FLOW&#39;
    PRODUCT_FLOW = &#39;PRODUCT_FLOW&#39;
    WASTE_FLOW = &#39;WASTE_FLOW&#39;


class ModelType(Enum):
    &#34;&#34;&#34;
    An enumeration of the root entity types.
    &#34;&#34;&#34;

    PROJECT = &#39;PROJECT&#39;
    IMPACT_METHOD = &#39;IMPACT_METHOD&#39;
    IMPACT_CATEGORY = &#39;IMPACT_CATEGORY&#39;
    PRODUCT_SYSTEM = &#39;PRODUCT_SYSTEM&#39;
    PROCESS = &#39;PROCESS&#39;
    FLOW = &#39;FLOW&#39;
    FLOW_PROPERTY = &#39;FLOW_PROPERTY&#39;
    UNIT_GROUP = &#39;UNIT_GROUP&#39;
    UNIT = &#39;UNIT&#39;
    ACTOR = &#39;ACTOR&#39;
    SOURCE = &#39;SOURCE&#39;
    CATEGORY = &#39;CATEGORY&#39;
    LOCATION = &#39;LOCATION&#39;
    NW_SET = &#39;NW_SET&#39;
    SOCIAL_INDICATOR = &#39;SOCIAL_INDICATOR&#39;


class ParameterScope(Enum):
    &#34;&#34;&#34;
    The possible scopes of parameters.
    &#34;&#34;&#34;

    PROCESS_SCOPE = &#39;PROCESS_SCOPE&#39;
    LCIA_METHOD_SCOPE = &#39;LCIA_METHOD_SCOPE&#39;
    GLOBAL_SCOPE = &#39;GLOBAL_SCOPE&#39;


class ProcessType(Enum):
    LCI_RESULT = &#39;LCI_RESULT&#39;
    UNIT_PROCESS = &#39;UNIT_PROCESS&#39;


class UncertaintyType(Enum):
    &#34;&#34;&#34;
    Enumeration of uncertainty distribution types that can be used in
    exchanges, parameters, LCIA factors, etc.
    &#34;&#34;&#34;

    LOG_NORMAL_DISTRIBUTION = &#39;LOG_NORMAL_DISTRIBUTION&#39;
    NORMAL_DISTRIBUTION = &#39;NORMAL_DISTRIBUTION&#39;
    TRIANGLE_DISTRIBUTION = &#39;TRIANGLE_DISTRIBUTION&#39;
    UNIFORM_DISTRIBUTION = &#39;UNIFORM_DISTRIBUTION&#39;


class Entity(object):
    &#34;&#34;&#34;
    The most generic type of the openLCA data model.
    &#34;&#34;&#34;

    def __init__(self):
        self.id: str = &#39;&#39;
        self.olca_type: str = &#39;&#39;

    def to_json(self) -&gt; dict:
        o_type = self.olca_type
        if o_type is None:
            o_type = type(self).__name__
        json = {&#39;@type&#39;: o_type}
        if self.id is not None:
            json[&#39;@id&#39;] = self.id
        return json

    def from_json(self, json: dict):
        self.id = json.get(&#39;@id&#39;)


class AllocationFactor(Entity):
    &#34;&#34;&#34;
    A single allocation factor in a process.

    Attributes
    ----------
    product_exchange: Exchange
        The output product.

    allocation_type: AllocationType
        The type of allocation.

    value: float
        The value of the allocation factor.

    allocated_exchange: Exchange
        An input product or elementary flow exchange which is allocated by this
        factor. This is only valid for causal allocation where allocation
        factors can be assigned to single exchanges.

    &#34;&#34;&#34;

    def __init__(self):
        super(AllocationFactor, self).__init__()
        self.product_exchange: Optional[Exchange] = None
        self.allocation_type: Optional[AllocationType] = None
        self.value: Optional[float] = None
        self.allocated_exchange: Optional[Exchange] = None

    def to_json(self) -&gt; dict:
        json: dict = super(AllocationFactor, self).to_json()
        if self.product_exchange is not None:
            json[&#39;productExchange&#39;] = self.product_exchange.to_json()
        if self.allocation_type is not None:
            json[&#39;allocationType&#39;] = self.allocation_type.value
        if self.value is not None:
            json[&#39;value&#39;] = self.value
        if self.allocated_exchange is not None:
            json[&#39;allocatedExchange&#39;] = self.allocated_exchange.to_json()
        return json

    def from_json(self, json: dict):
        super(AllocationFactor, self).from_json(json)
        val = json.get(&#39;productExchange&#39;)
        if val is not None:
            self.product_exchange = Exchange()
            self.product_exchange.from_json(val)
        val = json.get(&#39;allocationType&#39;)
        if val is not None:
            self.allocation_type = AllocationType(val)
        val = json.get(&#39;value&#39;)
        if val is not None:
            self.value = val
        val = json.get(&#39;allocatedExchange&#39;)
        if val is not None:
            self.allocated_exchange = Exchange()
            self.allocated_exchange.from_json(val)


class CalculationSetup(Entity):
    &#34;&#34;&#34;
    A setup for a product system calculation.

    Attributes
    ----------
    calculation_type: CalculationType
        The type of calculation that should be performed.

    product_system: Ref
        The product system that should be calculated (required).

    impact_method: Ref
        The LCIA method for the calculation (optional).

    with_costs: bool
        Indicates whether life cycle costs should be also calculated
        (optional).

    nw_set: Ref
        The normalisation and weighting set for the calculation (optional).

    allocation_method: AllocationType
        The calculation type to be used in the calculation (optional).

    parameter_redefs: List[ParameterRedef]
        A list of parameter redefinitions to be used in the calculation
        (optional).

    amount: float
        (optional)

    unit: Ref
        (optional)

    flow_property: Ref
        (optional)

    &#34;&#34;&#34;

    def __init__(self):
        super(CalculationSetup, self).__init__()
        self.calculation_type: Optional[CalculationType] = None
        self.product_system: Optional[Ref] = None
        self.impact_method: Optional[Ref] = None
        self.with_costs: Optional[bool] = None
        self.nw_set: Optional[Ref] = None
        self.allocation_method: Optional[AllocationType] = None
        self.parameter_redefs: Optional[List[ParameterRedef]] = None
        self.amount: Optional[float] = None
        self.unit: Optional[Ref] = None
        self.flow_property: Optional[Ref] = None

    def to_json(self) -&gt; dict:
        json: dict = super(CalculationSetup, self).to_json()
        if self.calculation_type is not None:
            json[&#39;calculationType&#39;] = self.calculation_type.value
        if self.product_system is not None:
            json[&#39;productSystem&#39;] = self.product_system.to_json()
        if self.impact_method is not None:
            json[&#39;impactMethod&#39;] = self.impact_method.to_json()
        if self.with_costs is not None:
            json[&#39;withCosts&#39;] = self.with_costs
        if self.nw_set is not None:
            json[&#39;nwSet&#39;] = self.nw_set.to_json()
        if self.allocation_method is not None:
            json[&#39;allocationMethod&#39;] = self.allocation_method.value
        if self.parameter_redefs is not None:
            json[&#39;parameterRedefs&#39;] = []
            for e in self.parameter_redefs:
                json[&#39;parameterRedefs&#39;].append(e.to_json())
        if self.amount is not None:
            json[&#39;amount&#39;] = self.amount
        if self.unit is not None:
            json[&#39;unit&#39;] = self.unit.to_json()
        if self.flow_property is not None:
            json[&#39;flowProperty&#39;] = self.flow_property.to_json()
        return json

    def from_json(self, json: dict):
        super(CalculationSetup, self).from_json(json)
        val = json.get(&#39;calculationType&#39;)
        if val is not None:
            self.calculation_type = CalculationType(val)
        val = json.get(&#39;productSystem&#39;)
        if val is not None:
            self.product_system = Ref()
            self.product_system.from_json(val)
        val = json.get(&#39;impactMethod&#39;)
        if val is not None:
            self.impact_method = Ref()
            self.impact_method.from_json(val)
        val = json.get(&#39;withCosts&#39;)
        if val is not None:
            self.with_costs = val
        val = json.get(&#39;nwSet&#39;)
        if val is not None:
            self.nw_set = Ref()
            self.nw_set.from_json(val)
        val = json.get(&#39;allocationMethod&#39;)
        if val is not None:
            self.allocation_method = AllocationType(val)
        val = json.get(&#39;parameterRedefs&#39;)
        if val is not None:
            self.parameter_redefs = []
            for d in val:
                e = ParameterRedef()
                e.from_json(d)
                self.parameter_redefs.append(e)
        val = json.get(&#39;amount&#39;)
        if val is not None:
            self.amount = val
        val = json.get(&#39;unit&#39;)
        if val is not None:
            self.unit = Ref()
            self.unit.from_json(val)
        val = json.get(&#39;flowProperty&#39;)
        if val is not None:
            self.flow_property = Ref()
            self.flow_property.from_json(val)


class DqIndicator(Entity):
    &#34;&#34;&#34;
    An indicator of a data quality system ([DqSystem]).

    Attributes
    ----------
    name: str

    position: int

    scores: List[DqScore]

    &#34;&#34;&#34;

    def __init__(self):
        super(DqIndicator, self).__init__()
        self.name: Optional[str] = None
        self.position: Optional[int] = None
        self.scores: Optional[List[DqScore]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(DqIndicator, self).to_json()
        if self.name is not None:
            json[&#39;name&#39;] = self.name
        if self.position is not None:
            json[&#39;position&#39;] = self.position
        if self.scores is not None:
            json[&#39;scores&#39;] = []
            for e in self.scores:
                json[&#39;scores&#39;].append(e.to_json())
        return json

    def from_json(self, json: dict):
        super(DqIndicator, self).from_json(json)
        val = json.get(&#39;name&#39;)
        if val is not None:
            self.name = val
        val = json.get(&#39;position&#39;)
        if val is not None:
            self.position = val
        val = json.get(&#39;scores&#39;)
        if val is not None:
            self.scores = []
            for d in val:
                e = DqScore()
                e.from_json(d)
                self.scores.append(e)


class DqScore(Entity):
    &#34;&#34;&#34;
    An score value of an indicator ([DqIndicator]) in a data quality system
    ([DqSystem]).

    Attributes
    ----------
    position: int

    label: str

    description: str

    uncertainty: float

    &#34;&#34;&#34;

    def __init__(self):
        super(DqScore, self).__init__()
        self.position: Optional[int] = None
        self.label: Optional[str] = None
        self.description: Optional[str] = None
        self.uncertainty: Optional[float] = None

    def to_json(self) -&gt; dict:
        json: dict = super(DqScore, self).to_json()
        if self.position is not None:
            json[&#39;position&#39;] = self.position
        if self.label is not None:
            json[&#39;label&#39;] = self.label
        if self.description is not None:
            json[&#39;description&#39;] = self.description
        if self.uncertainty is not None:
            json[&#39;uncertainty&#39;] = self.uncertainty
        return json

    def from_json(self, json: dict):
        super(DqScore, self).from_json(json)
        val = json.get(&#39;position&#39;)
        if val is not None:
            self.position = val
        val = json.get(&#39;label&#39;)
        if val is not None:
            self.label = val
        val = json.get(&#39;description&#39;)
        if val is not None:
            self.description = val
        val = json.get(&#39;uncertainty&#39;)
        if val is not None:
            self.uncertainty = val


class Exchange(Entity):
    &#34;&#34;&#34;
    An Exchange is an input or output of a [Flow] in a [Process]. The amount of
    an exchange is given in a specific unit of a quantity ([FlowProperty]) of
    the flow. The allowed units and flow properties that can be used for a flow
    in an exchange are defined by the flow property information in that flow
    (see also the [FlowPropertyFactor] type).

    Attributes
    ----------
    internal_id: int
        The process internal ID of the exchange. This is used to identify
        exchanges unambiguously within a process (e.g. when linking exchanges
        in a product system where multiple exchanges with the same flow are
        allowed). The value should be &gt;= 1.

    avoided_product: bool
        Indicates whether this exchange is an avoided product.

    flow: FlowRef
        The reference to the flow of the exchange.

    flow_property: Ref
        The quantity in which the amount is given.

    input: bool

    quantitative_reference: bool
        Indicates whether the exchange is the quantitative reference of the
        process.

    base_uncertainty: float

    default_provider: ProcessRef
        A default provider is a [Process] that is linked as the provider of a
        product input or the waste treatment provider of a waste output. It is
        just an optional default setting which can be also ignored when
        building product systems in openLCA. The user is always free to link
        processes in product systems ignoring these defaults (but the flows and
        flow directions have to match of course).

    amount: float

    amount_formula: str

    unit: Ref

    dq_entry: str
        A data quality entry like `(1;3;2;5;1)`. The entry is a vector of data
        quality values that need to match the data quality scheme for flow
        inputs and outputs that is assigned to the [Process]. In such a scheme
        the data quality indicators have fixed positions and the respective
        values in the `dqEntry` vector map to these positions.

    uncertainty: Uncertainty

    description: str
        A general comment about the input or output.

    &#34;&#34;&#34;

    def __init__(self):
        super(Exchange, self).__init__()
        self.internal_id: Optional[int] = None
        self.avoided_product: Optional[bool] = None
        self.flow: Optional[FlowRef] = None
        self.flow_property: Optional[Ref] = None
        self.input: Optional[bool] = None
        self.quantitative_reference: Optional[bool] = None
        self.base_uncertainty: Optional[float] = None
        self.default_provider: Optional[ProcessRef] = None
        self.amount: Optional[float] = None
        self.amount_formula: Optional[str] = None
        self.unit: Optional[Ref] = None
        self.dq_entry: Optional[str] = None
        self.uncertainty: Optional[Uncertainty] = None
        self.description: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Exchange, self).to_json()
        if self.internal_id is not None:
            json[&#39;internalId&#39;] = self.internal_id
        if self.avoided_product is not None:
            json[&#39;avoidedProduct&#39;] = self.avoided_product
        if self.flow is not None:
            json[&#39;flow&#39;] = self.flow.to_json()
        if self.flow_property is not None:
            json[&#39;flowProperty&#39;] = self.flow_property.to_json()
        if self.input is not None:
            json[&#39;input&#39;] = self.input
        if self.quantitative_reference is not None:
            json[&#39;quantitativeReference&#39;] = self.quantitative_reference
        if self.base_uncertainty is not None:
            json[&#39;baseUncertainty&#39;] = self.base_uncertainty
        if self.default_provider is not None:
            json[&#39;defaultProvider&#39;] = self.default_provider.to_json()
        if self.amount is not None:
            json[&#39;amount&#39;] = self.amount
        if self.amount_formula is not None:
            json[&#39;amountFormula&#39;] = self.amount_formula
        if self.unit is not None:
            json[&#39;unit&#39;] = self.unit.to_json()
        if self.dq_entry is not None:
            json[&#39;dqEntry&#39;] = self.dq_entry
        if self.uncertainty is not None:
            json[&#39;uncertainty&#39;] = self.uncertainty.to_json()
        if self.description is not None:
            json[&#39;description&#39;] = self.description
        return json

    def from_json(self, json: dict):
        super(Exchange, self).from_json(json)
        val = json.get(&#39;internalId&#39;)
        if val is not None:
            self.internal_id = val
        val = json.get(&#39;avoidedProduct&#39;)
        if val is not None:
            self.avoided_product = val
        val = json.get(&#39;flow&#39;)
        if val is not None:
            self.flow = FlowRef()
            self.flow.from_json(val)
        val = json.get(&#39;flowProperty&#39;)
        if val is not None:
            self.flow_property = Ref()
            self.flow_property.from_json(val)
        val = json.get(&#39;input&#39;)
        if val is not None:
            self.input = val
        val = json.get(&#39;quantitativeReference&#39;)
        if val is not None:
            self.quantitative_reference = val
        val = json.get(&#39;baseUncertainty&#39;)
        if val is not None:
            self.base_uncertainty = val
        val = json.get(&#39;defaultProvider&#39;)
        if val is not None:
            self.default_provider = ProcessRef()
            self.default_provider.from_json(val)
        val = json.get(&#39;amount&#39;)
        if val is not None:
            self.amount = val
        val = json.get(&#39;amountFormula&#39;)
        if val is not None:
            self.amount_formula = val
        val = json.get(&#39;unit&#39;)
        if val is not None:
            self.unit = Ref()
            self.unit.from_json(val)
        val = json.get(&#39;dqEntry&#39;)
        if val is not None:
            self.dq_entry = val
        val = json.get(&#39;uncertainty&#39;)
        if val is not None:
            self.uncertainty = Uncertainty()
            self.uncertainty.from_json(val)
        val = json.get(&#39;description&#39;)
        if val is not None:
            self.description = val


class FlowMapRef(Entity):
    &#34;&#34;&#34;
    Describes a the source or target flow of a flow mapping in a `FlowMap`.
    Such a flow reference can also optionally specify the unit and flow
    property (quantity) for which the mapping is valid. If the unit and
    quantity are not given, the mapping is based on the reference unit of the
    reference flow property of the respective flow.

    Attributes
    ----------
    flow: FlowRef
        The reference to the flow data set.

    flow_property: Ref
        An optional reference to a flow property of the flow for which the
        mapping is valid.

    unit: Ref
        An optional reference to a unit of the flow for which the mapping is
        valid

    &#34;&#34;&#34;

    def __init__(self):
        super(FlowMapRef, self).__init__()
        self.flow: Optional[FlowRef] = None
        self.flow_property: Optional[Ref] = None
        self.unit: Optional[Ref] = None

    def to_json(self) -&gt; dict:
        json: dict = super(FlowMapRef, self).to_json()
        if self.flow is not None:
            json[&#39;flow&#39;] = self.flow.to_json()
        if self.flow_property is not None:
            json[&#39;flowProperty&#39;] = self.flow_property.to_json()
        if self.unit is not None:
            json[&#39;unit&#39;] = self.unit.to_json()
        return json

    def from_json(self, json: dict):
        super(FlowMapRef, self).from_json(json)
        val = json.get(&#39;flow&#39;)
        if val is not None:
            self.flow = FlowRef()
            self.flow.from_json(val)
        val = json.get(&#39;flowProperty&#39;)
        if val is not None:
            self.flow_property = Ref()
            self.flow_property.from_json(val)
        val = json.get(&#39;unit&#39;)
        if val is not None:
            self.unit = Ref()
            self.unit.from_json(val)


class FlowPropertyFactor(Entity):
    &#34;&#34;&#34;
    A FlowPropertyFactor is a conversion factor between &lt;a
    href=&#34;./FlowProperty.html&#34;&gt;flow properties (quantities)&lt;/a&gt; of a &lt;a
    href=&#34;./Flow.html&#34;&gt;flow&lt;/a&gt;. As an example the amount of the flow &#39;water&#39;
    in a process could be expressed in &#39;kg&#39; mass or &#39;m3&#39; volume. In this case
    the flow water would have two flow property factors: one for the flow
    property &#39;mass&#39; and one for &#39;volume&#39;. Each of these flow properties has a
    reference to a &lt;a href=&#34;./UnitGroup.html&#34;&gt;unit group&lt;/a&gt; which again has a
    reference unit. In the example the flow property &#39;mass&#39; could reference the
    unit group &#39;units of mass&#39; with &#39;kg&#39; as reference unit and volume could
    reference the unit group &#39;units of volume&#39; with &#39;m3&#39; as reference unit. The
    flow property factor is now the conversion factor between these two
    reference units where the factor of the reference flow property of the flow
    is 1. If the reference flow property of &#39;water&#39; in the example would be
    &#39;mass&#39; the respective flow property factor would be 1 and the factor for
    &#39;volume&#39; would be 0.001 (as 1 kg water is 0.001 m3). The amount of water in
    a process can now be also given in liter, tons, grams etc. For this, the
    unit conversion factor of the respective unit group can be used to convert
    into the reference unit (which then can be used to convert to the reference
    unit of another flow property). Another thing to note is that different
    flow properties can refer to the same unit group (e.g. MJ upper calorific
    value and MJ lower calorific value.)

    Attributes
    ----------
    flow_property: Ref
        The flow property (quantity) of the factor.

    conversion_factor: float
        The value of the conversion factor.

    reference_flow_property: bool
        Indicates whether the flow property of the factor is the reference flow
        property of the flow. The reference flow property must have a
        conversion factor of 1.0 and there should be only one reference flow
        property.

    &#34;&#34;&#34;

    def __init__(self):
        super(FlowPropertyFactor, self).__init__()
        self.flow_property: Optional[Ref] = None
        self.conversion_factor: Optional[float] = None
        self.reference_flow_property: Optional[bool] = None

    def to_json(self) -&gt; dict:
        json: dict = super(FlowPropertyFactor, self).to_json()
        if self.flow_property is not None:
            json[&#39;flowProperty&#39;] = self.flow_property.to_json()
        if self.conversion_factor is not None:
            json[&#39;conversionFactor&#39;] = self.conversion_factor
        if self.reference_flow_property is not None:
            json[&#39;referenceFlowProperty&#39;] = self.reference_flow_property
        return json

    def from_json(self, json: dict):
        super(FlowPropertyFactor, self).from_json(json)
        val = json.get(&#39;flowProperty&#39;)
        if val is not None:
            self.flow_property = Ref()
            self.flow_property.from_json(val)
        val = json.get(&#39;conversionFactor&#39;)
        if val is not None:
            self.conversion_factor = val
        val = json.get(&#39;referenceFlowProperty&#39;)
        if val is not None:
            self.reference_flow_property = val


class FlowResult(Entity):
    &#34;&#34;&#34;
    A result value for a flow; given in the reference unit of the flow.

    Attributes
    ----------
    flow: FlowRef
        The flow reference.

    input: bool
        Indicates whether the flow is an input or not.

    value: float
        The value of the flow amount.

    &#34;&#34;&#34;

    def __init__(self):
        super(FlowResult, self).__init__()
        self.flow: Optional[FlowRef] = None
        self.input: Optional[bool] = None
        self.value: Optional[float] = None

    def to_json(self) -&gt; dict:
        json: dict = super(FlowResult, self).to_json()
        if self.flow is not None:
            json[&#39;flow&#39;] = self.flow.to_json()
        if self.input is not None:
            json[&#39;input&#39;] = self.input
        if self.value is not None:
            json[&#39;value&#39;] = self.value
        return json

    def from_json(self, json: dict):
        super(FlowResult, self).from_json(json)
        val = json.get(&#39;flow&#39;)
        if val is not None:
            self.flow = FlowRef()
            self.flow.from_json(val)
        val = json.get(&#39;input&#39;)
        if val is not None:
            self.input = val
        val = json.get(&#39;value&#39;)
        if val is not None:
            self.value = val


class ImpactFactor(Entity):
    &#34;&#34;&#34;
    A single characterisation factor of a LCIA category for a flow.

    Attributes
    ----------
    flow: FlowRef
        The [Flow] of the impact assessment factor.

    flow_property: Ref
        The quantity of the flow to which the LCIA factor is related (e.g.
        Mass).

    unit: Ref
        The flow unit to which the LCIA factor is related (e.g. kg).

    value: float
        The value of the impact assessment factor.

    formula: str
        A mathematical formula for calculating the value of the LCIA factor.

    uncertainty: Uncertainty
        The uncertainty distribution of the factors&#39; value.

    &#34;&#34;&#34;

    def __init__(self):
        super(ImpactFactor, self).__init__()
        self.flow: Optional[FlowRef] = None
        self.flow_property: Optional[Ref] = None
        self.unit: Optional[Ref] = None
        self.value: Optional[float] = None
        self.formula: Optional[str] = None
        self.uncertainty: Optional[Uncertainty] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ImpactFactor, self).to_json()
        if self.flow is not None:
            json[&#39;flow&#39;] = self.flow.to_json()
        if self.flow_property is not None:
            json[&#39;flowProperty&#39;] = self.flow_property.to_json()
        if self.unit is not None:
            json[&#39;unit&#39;] = self.unit.to_json()
        if self.value is not None:
            json[&#39;value&#39;] = self.value
        if self.formula is not None:
            json[&#39;formula&#39;] = self.formula
        if self.uncertainty is not None:
            json[&#39;uncertainty&#39;] = self.uncertainty.to_json()
        return json

    def from_json(self, json: dict):
        super(ImpactFactor, self).from_json(json)
        val = json.get(&#39;flow&#39;)
        if val is not None:
            self.flow = FlowRef()
            self.flow.from_json(val)
        val = json.get(&#39;flowProperty&#39;)
        if val is not None:
            self.flow_property = Ref()
            self.flow_property.from_json(val)
        val = json.get(&#39;unit&#39;)
        if val is not None:
            self.unit = Ref()
            self.unit.from_json(val)
        val = json.get(&#39;value&#39;)
        if val is not None:
            self.value = val
        val = json.get(&#39;formula&#39;)
        if val is not None:
            self.formula = val
        val = json.get(&#39;uncertainty&#39;)
        if val is not None:
            self.uncertainty = Uncertainty()
            self.uncertainty.from_json(val)


class ImpactResult(Entity):
    &#34;&#34;&#34;
    A result value for an impact assessment category.

    Attributes
    ----------
    impact_category: ImpactCategoryRef
        The reference to the impact assessment category.

    value: float
        The value of the flow amount.

    &#34;&#34;&#34;

    def __init__(self):
        super(ImpactResult, self).__init__()
        self.impact_category: Optional[ImpactCategoryRef] = None
        self.value: Optional[float] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ImpactResult, self).to_json()
        if self.impact_category is not None:
            json[&#39;impactCategory&#39;] = self.impact_category.to_json()
        if self.value is not None:
            json[&#39;value&#39;] = self.value
        return json

    def from_json(self, json: dict):
        super(ImpactResult, self).from_json(json)
        val = json.get(&#39;impactCategory&#39;)
        if val is not None:
            self.impact_category = ImpactCategoryRef()
            self.impact_category.from_json(val)
        val = json.get(&#39;value&#39;)
        if val is not None:
            self.value = val


class Parameter(Entity):
    &#34;&#34;&#34;


    Attributes
    ----------
    name: str
        The name of the parameter.

    description: str
        A description of the parameter.

    parameter_scope: ParameterScope
        The scope where the parameter is valid.

    input_parameter: bool
        Indicates whether the parameter is an input parameter (true) or a
        dependent/calculated parameter (false). A parameter can have a formula
        if it is not an input parameter.

    value: float
        The parameter value.

    formula: str
        A mathematical expression to calculate the parameter value.

    external_source: str
        A reference to an external source where the parameter is defined (e.g.
        an Excel table, shapefile, etc.).

    source_type: str
        Indicates the type of the source if an external source is defined for
        the parameter.

    uncertainty: Uncertainty
        An uncertainty distribution of the parameter value. This is only valid
        for input parameters.

    &#34;&#34;&#34;

    def __init__(self):
        super(Parameter, self).__init__()
        self.name: Optional[str] = None
        self.description: Optional[str] = None
        self.parameter_scope: Optional[ParameterScope] = None
        self.input_parameter: Optional[bool] = None
        self.value: Optional[float] = None
        self.formula: Optional[str] = None
        self.external_source: Optional[str] = None
        self.source_type: Optional[str] = None
        self.uncertainty: Optional[Uncertainty] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Parameter, self).to_json()
        if self.name is not None:
            json[&#39;name&#39;] = self.name
        if self.description is not None:
            json[&#39;description&#39;] = self.description
        if self.parameter_scope is not None:
            json[&#39;parameterScope&#39;] = self.parameter_scope.value
        if self.input_parameter is not None:
            json[&#39;inputParameter&#39;] = self.input_parameter
        if self.value is not None:
            json[&#39;value&#39;] = self.value
        if self.formula is not None:
            json[&#39;formula&#39;] = self.formula
        if self.external_source is not None:
            json[&#39;externalSource&#39;] = self.external_source
        if self.source_type is not None:
            json[&#39;sourceType&#39;] = self.source_type
        if self.uncertainty is not None:
            json[&#39;uncertainty&#39;] = self.uncertainty.to_json()
        return json

    def from_json(self, json: dict):
        super(Parameter, self).from_json(json)
        val = json.get(&#39;name&#39;)
        if val is not None:
            self.name = val
        val = json.get(&#39;description&#39;)
        if val is not None:
            self.description = val
        val = json.get(&#39;parameterScope&#39;)
        if val is not None:
            self.parameter_scope = ParameterScope(val)
        val = json.get(&#39;inputParameter&#39;)
        if val is not None:
            self.input_parameter = val
        val = json.get(&#39;value&#39;)
        if val is not None:
            self.value = val
        val = json.get(&#39;formula&#39;)
        if val is not None:
            self.formula = val
        val = json.get(&#39;externalSource&#39;)
        if val is not None:
            self.external_source = val
        val = json.get(&#39;sourceType&#39;)
        if val is not None:
            self.source_type = val
        val = json.get(&#39;uncertainty&#39;)
        if val is not None:
            self.uncertainty = Uncertainty()
            self.uncertainty.from_json(val)


class ParameterRedef(Entity):
    &#34;&#34;&#34;
    A redefinition of a parameter in a product system.

    Attributes
    ----------
    name: str
        The parameter name.

    value: float
        The (new) value of the parameter.

    context: Ref
        The context of the paramater (a process or LCIA method). If no context
        is provided it is assumed that this is a redefinition of a global
        parameter.

    &#34;&#34;&#34;

    def __init__(self):
        super(ParameterRedef, self).__init__()
        self.name: Optional[str] = None
        self.value: Optional[float] = None
        self.context: Optional[Ref] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ParameterRedef, self).to_json()
        if self.name is not None:
            json[&#39;name&#39;] = self.name
        if self.value is not None:
            json[&#39;value&#39;] = self.value
        if self.context is not None:
            json[&#39;context&#39;] = self.context.to_json()
        return json

    def from_json(self, json: dict):
        super(ParameterRedef, self).from_json(json)
        val = json.get(&#39;name&#39;)
        if val is not None:
            self.name = val
        val = json.get(&#39;value&#39;)
        if val is not None:
            self.value = val
        val = json.get(&#39;context&#39;)
        if val is not None:
            self.context = Ref()
            self.context.from_json(val)


class ProcessDocumentation(Entity):
    &#34;&#34;&#34;


    Attributes
    ----------
    time_description: str

    valid_until: str

    valid_from: str

    technology_description: str

    data_collection_description: str

    completeness_description: str

    data_selection_description: str

    review_details: str

    data_treatment_description: str

    inventory_method_description: str

    modeling_constants_description: str

    reviewer: Ref

    sampling_description: str

    sources: List[Ref]

    restrictions_description: str

    copyright: bool

    creation_date: str

    data_documentor: Ref

    data_generator: Ref

    data_set_owner: Ref

    intended_application: str

    project_description: str

    publication: Ref

    geography_description: str

    &#34;&#34;&#34;

    def __init__(self):
        super(ProcessDocumentation, self).__init__()
        self.time_description: Optional[str] = None
        self.valid_until: Optional[str] = None
        self.valid_from: Optional[str] = None
        self.technology_description: Optional[str] = None
        self.data_collection_description: Optional[str] = None
        self.completeness_description: Optional[str] = None
        self.data_selection_description: Optional[str] = None
        self.review_details: Optional[str] = None
        self.data_treatment_description: Optional[str] = None
        self.inventory_method_description: Optional[str] = None
        self.modeling_constants_description: Optional[str] = None
        self.reviewer: Optional[Ref] = None
        self.sampling_description: Optional[str] = None
        self.sources: Optional[List[Ref]] = None
        self.restrictions_description: Optional[str] = None
        self.copyright: Optional[bool] = None
        self.creation_date: Optional[str] = None
        self.data_documentor: Optional[Ref] = None
        self.data_generator: Optional[Ref] = None
        self.data_set_owner: Optional[Ref] = None
        self.intended_application: Optional[str] = None
        self.project_description: Optional[str] = None
        self.publication: Optional[Ref] = None
        self.geography_description: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ProcessDocumentation, self).to_json()
        if self.time_description is not None:
            json[&#39;timeDescription&#39;] = self.time_description
        if self.valid_until is not None:
            json[&#39;validUntil&#39;] = self.valid_until
        if self.valid_from is not None:
            json[&#39;validFrom&#39;] = self.valid_from
        if self.technology_description is not None:
            json[&#39;technologyDescription&#39;] = self.technology_description
        if self.data_collection_description is not None:
            json[&#39;dataCollectionDescription&#39;] = self.data_collection_description
        if self.completeness_description is not None:
            json[&#39;completenessDescription&#39;] = self.completeness_description
        if self.data_selection_description is not None:
            json[&#39;dataSelectionDescription&#39;] = self.data_selection_description
        if self.review_details is not None:
            json[&#39;reviewDetails&#39;] = self.review_details
        if self.data_treatment_description is not None:
            json[&#39;dataTreatmentDescription&#39;] = self.data_treatment_description
        if self.inventory_method_description is not None:
            json[&#39;inventoryMethodDescription&#39;] = self.inventory_method_description
        if self.modeling_constants_description is not None:
            json[&#39;modelingConstantsDescription&#39;] = self.modeling_constants_description
        if self.reviewer is not None:
            json[&#39;reviewer&#39;] = self.reviewer.to_json()
        if self.sampling_description is not None:
            json[&#39;samplingDescription&#39;] = self.sampling_description
        if self.sources is not None:
            json[&#39;sources&#39;] = []
            for e in self.sources:
                json[&#39;sources&#39;].append(e.to_json())
        if self.restrictions_description is not None:
            json[&#39;restrictionsDescription&#39;] = self.restrictions_description
        if self.copyright is not None:
            json[&#39;copyright&#39;] = self.copyright
        if self.creation_date is not None:
            json[&#39;creationDate&#39;] = self.creation_date
        if self.data_documentor is not None:
            json[&#39;dataDocumentor&#39;] = self.data_documentor.to_json()
        if self.data_generator is not None:
            json[&#39;dataGenerator&#39;] = self.data_generator.to_json()
        if self.data_set_owner is not None:
            json[&#39;dataSetOwner&#39;] = self.data_set_owner.to_json()
        if self.intended_application is not None:
            json[&#39;intendedApplication&#39;] = self.intended_application
        if self.project_description is not None:
            json[&#39;projectDescription&#39;] = self.project_description
        if self.publication is not None:
            json[&#39;publication&#39;] = self.publication.to_json()
        if self.geography_description is not None:
            json[&#39;geographyDescription&#39;] = self.geography_description
        return json

    def from_json(self, json: dict):
        super(ProcessDocumentation, self).from_json(json)
        val = json.get(&#39;timeDescription&#39;)
        if val is not None:
            self.time_description = val
        val = json.get(&#39;validUntil&#39;)
        if val is not None:
            self.valid_until = val
        val = json.get(&#39;validFrom&#39;)
        if val is not None:
            self.valid_from = val
        val = json.get(&#39;technologyDescription&#39;)
        if val is not None:
            self.technology_description = val
        val = json.get(&#39;dataCollectionDescription&#39;)
        if val is not None:
            self.data_collection_description = val
        val = json.get(&#39;completenessDescription&#39;)
        if val is not None:
            self.completeness_description = val
        val = json.get(&#39;dataSelectionDescription&#39;)
        if val is not None:
            self.data_selection_description = val
        val = json.get(&#39;reviewDetails&#39;)
        if val is not None:
            self.review_details = val
        val = json.get(&#39;dataTreatmentDescription&#39;)
        if val is not None:
            self.data_treatment_description = val
        val = json.get(&#39;inventoryMethodDescription&#39;)
        if val is not None:
            self.inventory_method_description = val
        val = json.get(&#39;modelingConstantsDescription&#39;)
        if val is not None:
            self.modeling_constants_description = val
        val = json.get(&#39;reviewer&#39;)
        if val is not None:
            self.reviewer = Ref()
            self.reviewer.from_json(val)
        val = json.get(&#39;samplingDescription&#39;)
        if val is not None:
            self.sampling_description = val
        val = json.get(&#39;sources&#39;)
        if val is not None:
            self.sources = []
            for d in val:
                e = Ref()
                e.from_json(d)
                self.sources.append(e)
        val = json.get(&#39;restrictionsDescription&#39;)
        if val is not None:
            self.restrictions_description = val
        val = json.get(&#39;copyright&#39;)
        if val is not None:
            self.copyright = val
        val = json.get(&#39;creationDate&#39;)
        if val is not None:
            self.creation_date = val
        val = json.get(&#39;dataDocumentor&#39;)
        if val is not None:
            self.data_documentor = Ref()
            self.data_documentor.from_json(val)
        val = json.get(&#39;dataGenerator&#39;)
        if val is not None:
            self.data_generator = Ref()
            self.data_generator.from_json(val)
        val = json.get(&#39;dataSetOwner&#39;)
        if val is not None:
            self.data_set_owner = Ref()
            self.data_set_owner.from_json(val)
        val = json.get(&#39;intendedApplication&#39;)
        if val is not None:
            self.intended_application = val
        val = json.get(&#39;projectDescription&#39;)
        if val is not None:
            self.project_description = val
        val = json.get(&#39;publication&#39;)
        if val is not None:
            self.publication = Ref()
            self.publication.from_json(val)
        val = json.get(&#39;geographyDescription&#39;)
        if val is not None:
            self.geography_description = val


class ProcessLink(Entity):
    &#34;&#34;&#34;
    A process link is a connection between two processes in a product system.

    Attributes
    ----------
    provider: Ref
        The descriptor of the process that provides a product or a waste
        treatment.

    flow: Ref
        The descriptor of the flow that is exchanged between the two processes.

    process: Ref
        The descriptor of the process that is linked to the provider.

    exchange: Exchange
        The exchange of the linked process (this is useful if the linked
        process has multiple exchanges with the same flow that are linked to
        different provides, e.g. in an electricity mix).

    &#34;&#34;&#34;

    def __init__(self):
        super(ProcessLink, self).__init__()
        self.provider: Optional[Ref] = None
        self.flow: Optional[Ref] = None
        self.process: Optional[Ref] = None
        self.exchange: Optional[Exchange] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ProcessLink, self).to_json()
        if self.provider is not None:
            json[&#39;provider&#39;] = self.provider.to_json()
        if self.flow is not None:
            json[&#39;flow&#39;] = self.flow.to_json()
        if self.process is not None:
            json[&#39;process&#39;] = self.process.to_json()
        if self.exchange is not None:
            json[&#39;exchange&#39;] = self.exchange.to_json()
        return json

    def from_json(self, json: dict):
        super(ProcessLink, self).from_json(json)
        val = json.get(&#39;provider&#39;)
        if val is not None:
            self.provider = Ref()
            self.provider.from_json(val)
        val = json.get(&#39;flow&#39;)
        if val is not None:
            self.flow = Ref()
            self.flow.from_json(val)
        val = json.get(&#39;process&#39;)
        if val is not None:
            self.process = Ref()
            self.process.from_json(val)
        val = json.get(&#39;exchange&#39;)
        if val is not None:
            self.exchange = Exchange()
            self.exchange.from_json(val)


class RootEntity(Entity):
    &#34;&#34;&#34;
    A standalone item in a database like a location, unit group, flow, or
    process. A root entity can be unambiguously identified by its id (the
    JSON-LD @id field), version, and lastChange fields.

    Attributes
    ----------
    name: str
        The name of the entity.

    description: str
        The description of the entity.

    version: str
        A version number in MAJOR.MINOR.PATCH format where the MINOR and PATCH
        fields are optional and the fields may have leading zeros (so 01.00.00
        is the same as 1.0.0 or 1).

    last_change: str
        The timestamp when the entity was changed the last time.

    &#34;&#34;&#34;

    def __init__(self):
        super(RootEntity, self).__init__()
        self.name: Optional[str] = None
        self.description: Optional[str] = None
        self.version: Optional[str] = None
        self.last_change: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(RootEntity, self).to_json()
        if self.name is not None:
            json[&#39;name&#39;] = self.name
        if self.description is not None:
            json[&#39;description&#39;] = self.description
        if self.version is not None:
            json[&#39;version&#39;] = self.version
        if self.last_change is not None:
            json[&#39;lastChange&#39;] = self.last_change
        return json

    def from_json(self, json: dict):
        super(RootEntity, self).from_json(json)
        val = json.get(&#39;name&#39;)
        if val is not None:
            self.name = val
        val = json.get(&#39;description&#39;)
        if val is not None:
            self.description = val
        val = json.get(&#39;version&#39;)
        if val is not None:
            self.version = val
        val = json.get(&#39;lastChange&#39;)
        if val is not None:
            self.last_change = val


class SimpleResult(Entity):
    &#34;&#34;&#34;


    Attributes
    ----------
    flow_results: List[FlowResult]

    impact_results: List[ImpactResult]

    &#34;&#34;&#34;

    def __init__(self):
        super(SimpleResult, self).__init__()
        self.flow_results: Optional[List[FlowResult]] = None
        self.impact_results: Optional[List[ImpactResult]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(SimpleResult, self).to_json()
        if self.flow_results is not None:
            json[&#39;flowResults&#39;] = []
            for e in self.flow_results:
                json[&#39;flowResults&#39;].append(e.to_json())
        if self.impact_results is not None:
            json[&#39;impactResults&#39;] = []
            for e in self.impact_results:
                json[&#39;impactResults&#39;].append(e.to_json())
        return json

    def from_json(self, json: dict):
        super(SimpleResult, self).from_json(json)
        val = json.get(&#39;flowResults&#39;)
        if val is not None:
            self.flow_results = []
            for d in val:
                e = FlowResult()
                e.from_json(d)
                self.flow_results.append(e)
        val = json.get(&#39;impactResults&#39;)
        if val is not None:
            self.impact_results = []
            for d in val:
                e = ImpactResult()
                e.from_json(d)
                self.impact_results.append(e)


class Uncertainty(Entity):
    &#34;&#34;&#34;
    Defines the parameter values of an uncertainty distribution. Depending on
    the uncertainty distribution type different parameters could be used.

    Attributes
    ----------
    distribution_type: UncertaintyType
        The uncertainty distribution type

    mean: float
        The arithmetic mean (used for normal distributions).

    mean_formula: str
        A mathematical formula for the arithmetic mean.

    geom_mean: float
        The geometric mean value (used for log-normal distributions).

    geom_mean_formula: str
        A mathematical formula for the geometric mean.

    minimum: float
        The minimum value (used for uniform and triangle distributions).

    minimum_formula: str
        A mathematical formula for the minimum value.

    sd: float
        The arithmetic standard deviation (used for normal distributions).

    sd_formula: str
        A mathematical formula for the arithmetic standard deviation.

    geom_sd: float
        The geometric standard deviation (used for log-normal distributions).

    geom_sd_formula: str
        A mathematical formula for the geometric standard deviation.

    mode: float
        The most likely value (used for triangle distributions).

    mode_formula: str
        A mathematical formula for the most likely value.

    maximum: float
        The maximum value (used for uniform and triangle distributions).

    maximum_formula: str
        A mathematical formula for the maximum value.

    &#34;&#34;&#34;

    def __init__(self):
        super(Uncertainty, self).__init__()
        self.distribution_type: Optional[UncertaintyType] = None
        self.mean: Optional[float] = None
        self.mean_formula: Optional[str] = None
        self.geom_mean: Optional[float] = None
        self.geom_mean_formula: Optional[str] = None
        self.minimum: Optional[float] = None
        self.minimum_formula: Optional[str] = None
        self.sd: Optional[float] = None
        self.sd_formula: Optional[str] = None
        self.geom_sd: Optional[float] = None
        self.geom_sd_formula: Optional[str] = None
        self.mode: Optional[float] = None
        self.mode_formula: Optional[str] = None
        self.maximum: Optional[float] = None
        self.maximum_formula: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Uncertainty, self).to_json()
        if self.distribution_type is not None:
            json[&#39;distributionType&#39;] = self.distribution_type.value
        if self.mean is not None:
            json[&#39;mean&#39;] = self.mean
        if self.mean_formula is not None:
            json[&#39;meanFormula&#39;] = self.mean_formula
        if self.geom_mean is not None:
            json[&#39;geomMean&#39;] = self.geom_mean
        if self.geom_mean_formula is not None:
            json[&#39;geomMeanFormula&#39;] = self.geom_mean_formula
        if self.minimum is not None:
            json[&#39;minimum&#39;] = self.minimum
        if self.minimum_formula is not None:
            json[&#39;minimumFormula&#39;] = self.minimum_formula
        if self.sd is not None:
            json[&#39;sd&#39;] = self.sd
        if self.sd_formula is not None:
            json[&#39;sdFormula&#39;] = self.sd_formula
        if self.geom_sd is not None:
            json[&#39;geomSd&#39;] = self.geom_sd
        if self.geom_sd_formula is not None:
            json[&#39;geomSdFormula&#39;] = self.geom_sd_formula
        if self.mode is not None:
            json[&#39;mode&#39;] = self.mode
        if self.mode_formula is not None:
            json[&#39;modeFormula&#39;] = self.mode_formula
        if self.maximum is not None:
            json[&#39;maximum&#39;] = self.maximum
        if self.maximum_formula is not None:
            json[&#39;maximumFormula&#39;] = self.maximum_formula
        return json

    def from_json(self, json: dict):
        super(Uncertainty, self).from_json(json)
        val = json.get(&#39;distributionType&#39;)
        if val is not None:
            self.distribution_type = UncertaintyType(val)
        val = json.get(&#39;mean&#39;)
        if val is not None:
            self.mean = val
        val = json.get(&#39;meanFormula&#39;)
        if val is not None:
            self.mean_formula = val
        val = json.get(&#39;geomMean&#39;)
        if val is not None:
            self.geom_mean = val
        val = json.get(&#39;geomMeanFormula&#39;)
        if val is not None:
            self.geom_mean_formula = val
        val = json.get(&#39;minimum&#39;)
        if val is not None:
            self.minimum = val
        val = json.get(&#39;minimumFormula&#39;)
        if val is not None:
            self.minimum_formula = val
        val = json.get(&#39;sd&#39;)
        if val is not None:
            self.sd = val
        val = json.get(&#39;sdFormula&#39;)
        if val is not None:
            self.sd_formula = val
        val = json.get(&#39;geomSd&#39;)
        if val is not None:
            self.geom_sd = val
        val = json.get(&#39;geomSdFormula&#39;)
        if val is not None:
            self.geom_sd_formula = val
        val = json.get(&#39;mode&#39;)
        if val is not None:
            self.mode = val
        val = json.get(&#39;modeFormula&#39;)
        if val is not None:
            self.mode_formula = val
        val = json.get(&#39;maximum&#39;)
        if val is not None:
            self.maximum = val
        val = json.get(&#39;maximumFormula&#39;)
        if val is not None:
            self.maximum_formula = val


class CategorizedEntity(RootEntity):
    &#34;&#34;&#34;
    A root entity which can have a category.

    Attributes
    ----------
    category: Ref
        The category of the entity.

    &#34;&#34;&#34;

    def __init__(self):
        super(CategorizedEntity, self).__init__()
        self.category: Optional[Ref] = None

    def to_json(self) -&gt; dict:
        json: dict = super(CategorizedEntity, self).to_json()
        if self.category is not None:
            json[&#39;category&#39;] = self.category.to_json()
        return json

    def from_json(self, json: dict):
        super(CategorizedEntity, self).from_json(json)
        val = json.get(&#39;category&#39;)
        if val is not None:
            self.category = Ref()
            self.category.from_json(val)


class FlowMap(RootEntity):
    &#34;&#34;&#34;
    A crosswalk of flows from a source flow list to a target flow list.

    Attributes
    ----------
    source: Ref
        The reference (id, name, description) of the source flow list.

    target: Ref
        The reference (id, name, description) of the target flow list.

    mappings: List[FlowMapEntry]
        A list of flow mappings from flows in a source flow list to flows in a
        target flow list.

    &#34;&#34;&#34;

    def __init__(self):
        super(FlowMap, self).__init__()
        self.source: Optional[Ref] = None
        self.target: Optional[Ref] = None
        self.mappings: Optional[List[FlowMapEntry]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(FlowMap, self).to_json()
        if self.source is not None:
            json[&#39;source&#39;] = self.source.to_json()
        if self.target is not None:
            json[&#39;target&#39;] = self.target.to_json()
        if self.mappings is not None:
            json[&#39;mappings&#39;] = []
            for e in self.mappings:
                json[&#39;mappings&#39;].append(e.to_json())
        return json

    def from_json(self, json: dict):
        super(FlowMap, self).from_json(json)
        val = json.get(&#39;source&#39;)
        if val is not None:
            self.source = Ref()
            self.source.from_json(val)
        val = json.get(&#39;target&#39;)
        if val is not None:
            self.target = Ref()
            self.target.from_json(val)
        val = json.get(&#39;mappings&#39;)
        if val is not None:
            self.mappings = []
            for d in val:
                e = FlowMapEntry()
                e.from_json(d)
                self.mappings.append(e)


class FlowMapEntry(RootEntity):
    &#34;&#34;&#34;
    A mapping from one flow to another.

    Attributes
    ----------
    from_: FlowMapRef
        The flow, flow property, and unit of the source flow.

    to: FlowMapRef
        The flow, flow property, and unit of the target flow.

    conversion_factor: float
        The factor to convert the original source flow to the target flow.

    &#34;&#34;&#34;

    def __init__(self):
        super(FlowMapEntry, self).__init__()
        self.from_: Optional[FlowMapRef] = None
        self.to: Optional[FlowMapRef] = None
        self.conversion_factor: Optional[float] = None

    def to_json(self) -&gt; dict:
        json: dict = super(FlowMapEntry, self).to_json()
        if self.from_ is not None:
            json[&#39;from&#39;] = self.from_.to_json()
        if self.to is not None:
            json[&#39;to&#39;] = self.to.to_json()
        if self.conversion_factor is not None:
            json[&#39;conversionFactor&#39;] = self.conversion_factor
        return json

    def from_json(self, json: dict):
        super(FlowMapEntry, self).from_json(json)
        val = json.get(&#39;from&#39;)
        if val is not None:
            self.from_ = FlowMapRef()
            self.from_.from_json(val)
        val = json.get(&#39;to&#39;)
        if val is not None:
            self.to = FlowMapRef()
            self.to.from_json(val)
        val = json.get(&#39;conversionFactor&#39;)
        if val is not None:
            self.conversion_factor = val


class ImpactCategory(RootEntity):
    &#34;&#34;&#34;
    A LCIA category of a LCIA method (see ImpactMethod) which groups a set of
    characterisation factors

    Attributes
    ----------
    reference_unit_name: str
        The name of the reference unit of the LCIA category (e.g. kg CO2-eq.).

    impact_factors: List[ImpactFactor]
        The characterisation factors of the LCIA category.

    &#34;&#34;&#34;

    def __init__(self):
        super(ImpactCategory, self).__init__()
        self.reference_unit_name: Optional[str] = None
        self.impact_factors: Optional[List[ImpactFactor]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ImpactCategory, self).to_json()
        if self.reference_unit_name is not None:
            json[&#39;referenceUnitName&#39;] = self.reference_unit_name
        if self.impact_factors is not None:
            json[&#39;impactFactors&#39;] = []
            for e in self.impact_factors:
                json[&#39;impactFactors&#39;].append(e.to_json())
        return json

    def from_json(self, json: dict):
        super(ImpactCategory, self).from_json(json)
        val = json.get(&#39;referenceUnitName&#39;)
        if val is not None:
            self.reference_unit_name = val
        val = json.get(&#39;impactFactors&#39;)
        if val is not None:
            self.impact_factors = []
            for d in val:
                e = ImpactFactor()
                e.from_json(d)
                self.impact_factors.append(e)


class Location(RootEntity):
    &#34;&#34;&#34;
    A location like a country, state, city, etc.

    Attributes
    ----------
    code: str
        The code of the location (e.g. an ISO 2-letter country code).

    latitude: float
        The average latitude of the location.

    longitude: float
        The average longitude of the location.

    kml: str
        KML data of the location.

    &#34;&#34;&#34;

    def __init__(self):
        super(Location, self).__init__()
        self.code: Optional[str] = None
        self.latitude: Optional[float] = None
        self.longitude: Optional[float] = None
        self.kml: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Location, self).to_json()
        if self.code is not None:
            json[&#39;code&#39;] = self.code
        if self.latitude is not None:
            json[&#39;latitude&#39;] = self.latitude
        if self.longitude is not None:
            json[&#39;longitude&#39;] = self.longitude
        if self.kml is not None:
            json[&#39;kml&#39;] = self.kml
        return json

    def from_json(self, json: dict):
        super(Location, self).from_json(json)
        val = json.get(&#39;code&#39;)
        if val is not None:
            self.code = val
        val = json.get(&#39;latitude&#39;)
        if val is not None:
            self.latitude = val
        val = json.get(&#39;longitude&#39;)
        if val is not None:
            self.longitude = val
        val = json.get(&#39;kml&#39;)
        if val is not None:
            self.kml = val


class Ref(RootEntity):
    &#34;&#34;&#34;
    A Ref is a reference to a [RootEntity]. When serializing an entity (e.g. a
    [Process]) that references another standalone entity (e.g. a [Flow] in an
    [Exchange]) we do not want to write the complete referenced entity into the
    serialized JSON object but just a reference. However, the reference
    contains some meta-data like name, category path etc. that are useful to
    display.

    Attributes
    ----------
    category_path: List[str]
        The full path of the category of the referenced entity from top to
        bottom, e.g. `&#34;Elementary flows&#34;, &#34;Emissions to air&#34;, &#34;unspecified&#34;`.

    &#34;&#34;&#34;

    def __init__(self):
        super(Ref, self).__init__()
        self.category_path: Optional[List[str]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Ref, self).to_json()
        if self.category_path is not None:
            json[&#39;categoryPath&#39;] = []
            for e in self.category_path:
                json[&#39;categoryPath&#39;].append(e)
        return json

    def from_json(self, json: dict):
        super(Ref, self).from_json(json)
        val = json.get(&#39;categoryPath&#39;)
        if val is not None:
            self.category_path = []
            for d in val:
                e = d
                self.category_path.append(e)


class Unit(RootEntity):
    &#34;&#34;&#34;
    An unit of measure

    Attributes
    ----------
    conversion_factor: float
        The conversion factor to the reference unit of the unit group to which
        this unit belongs.

    reference_unit: bool
        Indicates whether the unit is the reference unit of the unit group to
        which this unit belongs. If it is the reference unit the conversion
        factor must be 1.0. There should be always only one reference unit in a
        unit group. The reference unit is used to convert amounts given in one
        unit to amounts given in another unit of the respective unit group.

    synonyms: List[str]
        A list of synonyms for the unit.

    &#34;&#34;&#34;

    def __init__(self):
        super(Unit, self).__init__()
        self.conversion_factor: Optional[float] = None
        self.reference_unit: Optional[bool] = None
        self.synonyms: Optional[List[str]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Unit, self).to_json()
        if self.conversion_factor is not None:
            json[&#39;conversionFactor&#39;] = self.conversion_factor
        if self.reference_unit is not None:
            json[&#39;referenceUnit&#39;] = self.reference_unit
        if self.synonyms is not None:
            json[&#39;synonyms&#39;] = []
            for e in self.synonyms:
                json[&#39;synonyms&#39;].append(e)
        return json

    def from_json(self, json: dict):
        super(Unit, self).from_json(json)
        val = json.get(&#39;conversionFactor&#39;)
        if val is not None:
            self.conversion_factor = val
        val = json.get(&#39;referenceUnit&#39;)
        if val is not None:
            self.reference_unit = val
        val = json.get(&#39;synonyms&#39;)
        if val is not None:
            self.synonyms = []
            for d in val:
                e = d
                self.synonyms.append(e)


class Actor(CategorizedEntity):
    &#34;&#34;&#34;
    An actor is a person or organisation.

    Attributes
    ----------
    address: str

    city: str

    country: str

    email: str

    telefax: str

    telephone: str

    website: str

    zip_code: str

    &#34;&#34;&#34;

    def __init__(self):
        super(Actor, self).__init__()
        self.address: Optional[str] = None
        self.city: Optional[str] = None
        self.country: Optional[str] = None
        self.email: Optional[str] = None
        self.telefax: Optional[str] = None
        self.telephone: Optional[str] = None
        self.website: Optional[str] = None
        self.zip_code: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Actor, self).to_json()
        if self.address is not None:
            json[&#39;address&#39;] = self.address
        if self.city is not None:
            json[&#39;city&#39;] = self.city
        if self.country is not None:
            json[&#39;country&#39;] = self.country
        if self.email is not None:
            json[&#39;email&#39;] = self.email
        if self.telefax is not None:
            json[&#39;telefax&#39;] = self.telefax
        if self.telephone is not None:
            json[&#39;telephone&#39;] = self.telephone
        if self.website is not None:
            json[&#39;website&#39;] = self.website
        if self.zip_code is not None:
            json[&#39;zipCode&#39;] = self.zip_code
        return json

    def from_json(self, json: dict):
        super(Actor, self).from_json(json)
        val = json.get(&#39;address&#39;)
        if val is not None:
            self.address = val
        val = json.get(&#39;city&#39;)
        if val is not None:
            self.city = val
        val = json.get(&#39;country&#39;)
        if val is not None:
            self.country = val
        val = json.get(&#39;email&#39;)
        if val is not None:
            self.email = val
        val = json.get(&#39;telefax&#39;)
        if val is not None:
            self.telefax = val
        val = json.get(&#39;telephone&#39;)
        if val is not None:
            self.telephone = val
        val = json.get(&#39;website&#39;)
        if val is not None:
            self.website = val
        val = json.get(&#39;zipCode&#39;)
        if val is not None:
            self.zip_code = val


class Category(CategorizedEntity):
    &#34;&#34;&#34;
    A category is used for the categorisation of types like processes, flows,
    etc. The tricky thing is that the `Category` class inherits also from the
    [CategorizedEntity] type so that a category can have a category attribute
    which is then the parent category of this category (uff).

    Attributes
    ----------
    model_type: ModelType
        The type of models that can be linked to the category.

    &#34;&#34;&#34;

    def __init__(self):
        super(Category, self).__init__()
        self.model_type: Optional[ModelType] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Category, self).to_json()
        if self.model_type is not None:
            json[&#39;modelType&#39;] = self.model_type.value
        return json

    def from_json(self, json: dict):
        super(Category, self).from_json(json)
        val = json.get(&#39;modelType&#39;)
        if val is not None:
            self.model_type = ModelType(val)


class DqSystem(CategorizedEntity):
    &#34;&#34;&#34;
    A data quality system.

    Attributes
    ----------
    has_uncertainties: bool

    source: Ref

    indicators: List[DqIndicator]

    &#34;&#34;&#34;

    def __init__(self):
        super(DqSystem, self).__init__()
        self.has_uncertainties: Optional[bool] = None
        self.source: Optional[Ref] = None
        self.indicators: Optional[List[DqIndicator]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(DqSystem, self).to_json()
        if self.has_uncertainties is not None:
            json[&#39;hasUncertainties&#39;] = self.has_uncertainties
        if self.source is not None:
            json[&#39;source&#39;] = self.source.to_json()
        if self.indicators is not None:
            json[&#39;indicators&#39;] = []
            for e in self.indicators:
                json[&#39;indicators&#39;].append(e.to_json())
        return json

    def from_json(self, json: dict):
        super(DqSystem, self).from_json(json)
        val = json.get(&#39;hasUncertainties&#39;)
        if val is not None:
            self.has_uncertainties = val
        val = json.get(&#39;source&#39;)
        if val is not None:
            self.source = Ref()
            self.source.from_json(val)
        val = json.get(&#39;indicators&#39;)
        if val is not None:
            self.indicators = []
            for d in val:
                e = DqIndicator()
                e.from_json(d)
                self.indicators.append(e)


class Flow(CategorizedEntity):
    &#34;&#34;&#34;
    Everything that can be an input or output of a process (e.g. a substance, a
    product, a waste, a service etc.)

    Attributes
    ----------
    flow_type: FlowType
        The type of the flow. Note that this type is more a descriptor of how
        the flow is handled in calculations.

    cas: str
        A CAS number of the flow.

    formula: str
        A chemical formula of the flow.

    flow_properties: List[FlowPropertyFactor]
        The flow properties (quantities) in which amounts of the flow can be
        expressed together with conversion factors between these flow flow
        properties.

    location: Ref
        The location of the flow. Normally the location of a flow is defined by
        the process location where the flow is an input or output. However,
        some data formats define a location as a property of a flow.

    &#34;&#34;&#34;

    def __init__(self):
        super(Flow, self).__init__()
        self.flow_type: Optional[FlowType] = None
        self.cas: Optional[str] = None
        self.formula: Optional[str] = None
        self.flow_properties: Optional[List[FlowPropertyFactor]] = None
        self.location: Optional[Ref] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Flow, self).to_json()
        if self.flow_type is not None:
            json[&#39;flowType&#39;] = self.flow_type.value
        if self.cas is not None:
            json[&#39;cas&#39;] = self.cas
        if self.formula is not None:
            json[&#39;formula&#39;] = self.formula
        if self.flow_properties is not None:
            json[&#39;flowProperties&#39;] = []
            for e in self.flow_properties:
                json[&#39;flowProperties&#39;].append(e.to_json())
        if self.location is not None:
            json[&#39;location&#39;] = self.location.to_json()
        return json

    def from_json(self, json: dict):
        super(Flow, self).from_json(json)
        val = json.get(&#39;flowType&#39;)
        if val is not None:
            self.flow_type = FlowType(val)
        val = json.get(&#39;cas&#39;)
        if val is not None:
            self.cas = val
        val = json.get(&#39;formula&#39;)
        if val is not None:
            self.formula = val
        val = json.get(&#39;flowProperties&#39;)
        if val is not None:
            self.flow_properties = []
            for d in val:
                e = FlowPropertyFactor()
                e.from_json(d)
                self.flow_properties.append(e)
        val = json.get(&#39;location&#39;)
        if val is not None:
            self.location = Ref()
            self.location.from_json(val)


class FlowProperty(CategorizedEntity):
    &#34;&#34;&#34;
    A flow property is a quantity that can be used to express amounts of a
    flow.

    Attributes
    ----------
    flow_property_type: FlowPropertyType
        The type of the flow property

    unit_group: Ref
        The units of measure that can be used to express quantities of the flow
        property.

    &#34;&#34;&#34;

    def __init__(self):
        super(FlowProperty, self).__init__()
        self.flow_property_type: Optional[FlowPropertyType] = None
        self.unit_group: Optional[Ref] = None

    def to_json(self) -&gt; dict:
        json: dict = super(FlowProperty, self).to_json()
        if self.flow_property_type is not None:
            json[&#39;flowPropertyType&#39;] = self.flow_property_type.value
        if self.unit_group is not None:
            json[&#39;unitGroup&#39;] = self.unit_group.to_json()
        return json

    def from_json(self, json: dict):
        super(FlowProperty, self).from_json(json)
        val = json.get(&#39;flowPropertyType&#39;)
        if val is not None:
            self.flow_property_type = FlowPropertyType(val)
        val = json.get(&#39;unitGroup&#39;)
        if val is not None:
            self.unit_group = Ref()
            self.unit_group.from_json(val)


class FlowRef(Ref):
    &#34;&#34;&#34;
    A reference to a [Flow] data set.

    Attributes
    ----------
    ref_unit: str
        The name (symbol) of the reference unit of the flow.

    location: str
        The location name or code of the flow. Typically, this is only used for
        product flows in databases like ecoinvent.

    flow_type: FlowType
        The type of the flow.

    &#34;&#34;&#34;

    def __init__(self):
        super(FlowRef, self).__init__()
        self.ref_unit: Optional[str] = None
        self.location: Optional[str] = None
        self.flow_type: Optional[FlowType] = None

    def to_json(self) -&gt; dict:
        json: dict = super(FlowRef, self).to_json()
        if self.ref_unit is not None:
            json[&#39;refUnit&#39;] = self.ref_unit
        if self.location is not None:
            json[&#39;location&#39;] = self.location
        if self.flow_type is not None:
            json[&#39;flowType&#39;] = self.flow_type.value
        return json

    def from_json(self, json: dict):
        super(FlowRef, self).from_json(json)
        val = json.get(&#39;refUnit&#39;)
        if val is not None:
            self.ref_unit = val
        val = json.get(&#39;location&#39;)
        if val is not None:
            self.location = val
        val = json.get(&#39;flowType&#39;)
        if val is not None:
            self.flow_type = FlowType(val)


class ImpactCategoryRef(Ref):
    &#34;&#34;&#34;
    A reference to a [ImpactCategory] data set.

    Attributes
    ----------
    ref_unit: str
        The name (symbol) of the reference unit of the impact category.

    &#34;&#34;&#34;

    def __init__(self):
        super(ImpactCategoryRef, self).__init__()
        self.ref_unit: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ImpactCategoryRef, self).to_json()
        if self.ref_unit is not None:
            json[&#39;refUnit&#39;] = self.ref_unit
        return json

    def from_json(self, json: dict):
        super(ImpactCategoryRef, self).from_json(json)
        val = json.get(&#39;refUnit&#39;)
        if val is not None:
            self.ref_unit = val


class ImpactMethod(CategorizedEntity):
    &#34;&#34;&#34;
    A impact assessment method.

    Attributes
    ----------
    impact_categories: List[ImpactCategoryRef]
        The LCIA categories of the method.

    parameters: List[Parameter]
        A set of method specific parameters which can be used in formulas of
        the characterisation factors in this method.

    &#34;&#34;&#34;

    def __init__(self):
        super(ImpactMethod, self).__init__()
        self.impact_categories: Optional[List[ImpactCategoryRef]] = None
        self.parameters: Optional[List[Parameter]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ImpactMethod, self).to_json()
        if self.impact_categories is not None:
            json[&#39;impactCategories&#39;] = []
            for e in self.impact_categories:
                json[&#39;impactCategories&#39;].append(e.to_json())
        if self.parameters is not None:
            json[&#39;parameters&#39;] = []
            for e in self.parameters:
                json[&#39;parameters&#39;].append(e.to_json())
        return json

    def from_json(self, json: dict):
        super(ImpactMethod, self).from_json(json)
        val = json.get(&#39;impactCategories&#39;)
        if val is not None:
            self.impact_categories = []
            for d in val:
                e = ImpactCategoryRef()
                e.from_json(d)
                self.impact_categories.append(e)
        val = json.get(&#39;parameters&#39;)
        if val is not None:
            self.parameters = []
            for d in val:
                e = Parameter()
                e.from_json(d)
                self.parameters.append(e)


class Process(CategorizedEntity):
    &#34;&#34;&#34;


    Attributes
    ----------
    default_allocation_method: AllocationType

    allocation_factors: List[AllocationFactor]

    exchanges: List[Exchange]
        The inputs and outputs of the process.

    location: Location

    parameters: List[Parameter]

    process_documentation: ProcessDocumentation

    process_type: ProcessType

    dq_system: Ref
        A reference to a data quality system ([DqSystem]) with which the
        overall quality of the process can be assessed.

    exchange_dq_system: Ref
        A reference to a data quality system ([DqSystem]) with which the
        quality of individual inputs and outputs ([Exchange]s) of the process
        can be assessed.

    social_dq_system: Ref
        A reference to a data quality system ([DqSystem]) with which the
        quality of individual social aspects of the process can be assessed.

    dq_entry: str
        A data quality entry like `(1;3;2;5;1)`. The entry is a vector of data
        quality values that need to match the overall data quality system of
        the process (the system that is stored in the `dqSystem` property). In
        such a system the data quality indicators have fixed positions and the
        respective values in the `dqEntry` vector map to these positions.

    &#34;&#34;&#34;

    def __init__(self):
        super(Process, self).__init__()
        self.default_allocation_method: Optional[AllocationType] = None
        self.allocation_factors: Optional[List[AllocationFactor]] = None
        self.exchanges: Optional[List[Exchange]] = None
        self.location: Optional[Location] = None
        self.parameters: Optional[List[Parameter]] = None
        self.process_documentation: Optional[ProcessDocumentation] = None
        self.process_type: Optional[ProcessType] = None
        self.dq_system: Optional[Ref] = None
        self.exchange_dq_system: Optional[Ref] = None
        self.social_dq_system: Optional[Ref] = None
        self.dq_entry: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Process, self).to_json()
        if self.default_allocation_method is not None:
            json[&#39;defaultAllocationMethod&#39;] = self.default_allocation_method.value
        if self.allocation_factors is not None:
            json[&#39;allocationFactors&#39;] = []
            for e in self.allocation_factors:
                json[&#39;allocationFactors&#39;].append(e.to_json())
        if self.exchanges is not None:
            json[&#39;exchanges&#39;] = []
            for e in self.exchanges:
                json[&#39;exchanges&#39;].append(e.to_json())
        if self.location is not None:
            json[&#39;location&#39;] = self.location.to_json()
        if self.parameters is not None:
            json[&#39;parameters&#39;] = []
            for e in self.parameters:
                json[&#39;parameters&#39;].append(e.to_json())
        if self.process_documentation is not None:
            json[&#39;processDocumentation&#39;] = self.process_documentation.to_json()
        if self.process_type is not None:
            json[&#39;processType&#39;] = self.process_type.value
        if self.dq_system is not None:
            json[&#39;dqSystem&#39;] = self.dq_system.to_json()
        if self.exchange_dq_system is not None:
            json[&#39;exchangeDqSystem&#39;] = self.exchange_dq_system.to_json()
        if self.social_dq_system is not None:
            json[&#39;socialDqSystem&#39;] = self.social_dq_system.to_json()
        if self.dq_entry is not None:
            json[&#39;dqEntry&#39;] = self.dq_entry
        return json

    def from_json(self, json: dict):
        super(Process, self).from_json(json)
        val = json.get(&#39;defaultAllocationMethod&#39;)
        if val is not None:
            self.default_allocation_method = AllocationType(val)
        val = json.get(&#39;allocationFactors&#39;)
        if val is not None:
            self.allocation_factors = []
            for d in val:
                e = AllocationFactor()
                e.from_json(d)
                self.allocation_factors.append(e)
        val = json.get(&#39;exchanges&#39;)
        if val is not None:
            self.exchanges = []
            for d in val:
                e = Exchange()
                e.from_json(d)
                self.exchanges.append(e)
        val = json.get(&#39;location&#39;)
        if val is not None:
            self.location = Location()
            self.location.from_json(val)
        val = json.get(&#39;parameters&#39;)
        if val is not None:
            self.parameters = []
            for d in val:
                e = Parameter()
                e.from_json(d)
                self.parameters.append(e)
        val = json.get(&#39;processDocumentation&#39;)
        if val is not None:
            self.process_documentation = ProcessDocumentation()
            self.process_documentation.from_json(val)
        val = json.get(&#39;processType&#39;)
        if val is not None:
            self.process_type = ProcessType(val)
        val = json.get(&#39;dqSystem&#39;)
        if val is not None:
            self.dq_system = Ref()
            self.dq_system.from_json(val)
        val = json.get(&#39;exchangeDqSystem&#39;)
        if val is not None:
            self.exchange_dq_system = Ref()
            self.exchange_dq_system.from_json(val)
        val = json.get(&#39;socialDqSystem&#39;)
        if val is not None:
            self.social_dq_system = Ref()
            self.social_dq_system.from_json(val)
        val = json.get(&#39;dqEntry&#39;)
        if val is not None:
            self.dq_entry = val


class ProcessRef(Ref):
    &#34;&#34;&#34;
    A reference to a [Process] data set.

    Attributes
    ----------
    location: str
        The location name or code of the process.

    process_type: ProcessType
        The type of the process.

    &#34;&#34;&#34;

    def __init__(self):
        super(ProcessRef, self).__init__()
        self.location: Optional[str] = None
        self.process_type: Optional[ProcessType] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ProcessRef, self).to_json()
        if self.location is not None:
            json[&#39;location&#39;] = self.location
        if self.process_type is not None:
            json[&#39;processType&#39;] = self.process_type.value
        return json

    def from_json(self, json: dict):
        super(ProcessRef, self).from_json(json)
        val = json.get(&#39;location&#39;)
        if val is not None:
            self.location = val
        val = json.get(&#39;processType&#39;)
        if val is not None:
            self.process_type = ProcessType(val)


class ProductSystem(CategorizedEntity):
    &#34;&#34;&#34;
    A product system describes the supply chain of a product (the functional
    unit) ...

    Attributes
    ----------
    processes: List[ProcessRef]
        The descriptors of all processes that are contained in the product
        system.

    reference_process: ProcessRef
        The descriptor of the process that provides the flow of the functional
        unit of the product system.

    reference_exchange: Exchange
        The exchange of the reference processes (typically the product output)
        that provides the flow of the functional unit of the product system.

    target_amount: float
        The flow amount of the functional unit of the product system.

    target_unit: Ref
        The unit in which the flow amount of the functional unit is given.

    target_flow_property: Ref
        The flow property in which the flow amount of the functional unit is
        given.

    process_links: List[ProcessLink]
        The process links of the product system.

    &#34;&#34;&#34;

    def __init__(self):
        super(ProductSystem, self).__init__()
        self.processes: Optional[List[ProcessRef]] = None
        self.reference_process: Optional[ProcessRef] = None
        self.reference_exchange: Optional[Exchange] = None
        self.target_amount: Optional[float] = None
        self.target_unit: Optional[Ref] = None
        self.target_flow_property: Optional[Ref] = None
        self.process_links: Optional[List[ProcessLink]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ProductSystem, self).to_json()
        if self.processes is not None:
            json[&#39;processes&#39;] = []
            for e in self.processes:
                json[&#39;processes&#39;].append(e.to_json())
        if self.reference_process is not None:
            json[&#39;referenceProcess&#39;] = self.reference_process.to_json()
        if self.reference_exchange is not None:
            json[&#39;referenceExchange&#39;] = self.reference_exchange.to_json()
        if self.target_amount is not None:
            json[&#39;targetAmount&#39;] = self.target_amount
        if self.target_unit is not None:
            json[&#39;targetUnit&#39;] = self.target_unit.to_json()
        if self.target_flow_property is not None:
            json[&#39;targetFlowProperty&#39;] = self.target_flow_property.to_json()
        if self.process_links is not None:
            json[&#39;processLinks&#39;] = []
            for e in self.process_links:
                json[&#39;processLinks&#39;].append(e.to_json())
        return json

    def from_json(self, json: dict):
        super(ProductSystem, self).from_json(json)
        val = json.get(&#39;processes&#39;)
        if val is not None:
            self.processes = []
            for d in val:
                e = ProcessRef()
                e.from_json(d)
                self.processes.append(e)
        val = json.get(&#39;referenceProcess&#39;)
        if val is not None:
            self.reference_process = ProcessRef()
            self.reference_process.from_json(val)
        val = json.get(&#39;referenceExchange&#39;)
        if val is not None:
            self.reference_exchange = Exchange()
            self.reference_exchange.from_json(val)
        val = json.get(&#39;targetAmount&#39;)
        if val is not None:
            self.target_amount = val
        val = json.get(&#39;targetUnit&#39;)
        if val is not None:
            self.target_unit = Ref()
            self.target_unit.from_json(val)
        val = json.get(&#39;targetFlowProperty&#39;)
        if val is not None:
            self.target_flow_property = Ref()
            self.target_flow_property.from_json(val)
        val = json.get(&#39;processLinks&#39;)
        if val is not None:
            self.process_links = []
            for d in val:
                e = ProcessLink()
                e.from_json(d)
                self.process_links.append(e)


class SocialIndicator(CategorizedEntity):
    &#34;&#34;&#34;


    Attributes
    ----------
    activity_variable: str
        The name of the activity variable of the indicator.

    activity_quantity: Ref
        The quantity of the activity variable.

    activity_unit: Ref
        The unit of the activity variable.

    unit_of_measurement: str
        The unit in which the indicator is measured.

    evaluation_scheme: str
        Documentation of the evaluation scheme of the indicator.

    &#34;&#34;&#34;

    def __init__(self):
        super(SocialIndicator, self).__init__()
        self.activity_variable: Optional[str] = None
        self.activity_quantity: Optional[Ref] = None
        self.activity_unit: Optional[Ref] = None
        self.unit_of_measurement: Optional[str] = None
        self.evaluation_scheme: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(SocialIndicator, self).to_json()
        if self.activity_variable is not None:
            json[&#39;activityVariable&#39;] = self.activity_variable
        if self.activity_quantity is not None:
            json[&#39;activityQuantity&#39;] = self.activity_quantity.to_json()
        if self.activity_unit is not None:
            json[&#39;activityUnit&#39;] = self.activity_unit.to_json()
        if self.unit_of_measurement is not None:
            json[&#39;unitOfMeasurement&#39;] = self.unit_of_measurement
        if self.evaluation_scheme is not None:
            json[&#39;evaluationScheme&#39;] = self.evaluation_scheme
        return json

    def from_json(self, json: dict):
        super(SocialIndicator, self).from_json(json)
        val = json.get(&#39;activityVariable&#39;)
        if val is not None:
            self.activity_variable = val
        val = json.get(&#39;activityQuantity&#39;)
        if val is not None:
            self.activity_quantity = Ref()
            self.activity_quantity.from_json(val)
        val = json.get(&#39;activityUnit&#39;)
        if val is not None:
            self.activity_unit = Ref()
            self.activity_unit.from_json(val)
        val = json.get(&#39;unitOfMeasurement&#39;)
        if val is not None:
            self.unit_of_measurement = val
        val = json.get(&#39;evaluationScheme&#39;)
        if val is not None:
            self.evaluation_scheme = val


class Source(CategorizedEntity):
    &#34;&#34;&#34;
    A source is a literature reference.

    Attributes
    ----------
    doi: str
        The digital object identifier of the source (see
        http://en.wikipedia.org/wiki/Digital_object_identifier).

    text_reference: str
        The full text reference of the source.

    year: int
        The publication year of the source.

    external_file: str
        A direct link (relative or absolute URL) to the source file.

    &#34;&#34;&#34;

    def __init__(self):
        super(Source, self).__init__()
        self.doi: Optional[str] = None
        self.text_reference: Optional[str] = None
        self.year: Optional[int] = None
        self.external_file: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Source, self).to_json()
        if self.doi is not None:
            json[&#39;doi&#39;] = self.doi
        if self.text_reference is not None:
            json[&#39;textReference&#39;] = self.text_reference
        if self.year is not None:
            json[&#39;year&#39;] = self.year
        if self.external_file is not None:
            json[&#39;externalFile&#39;] = self.external_file
        return json

    def from_json(self, json: dict):
        super(Source, self).from_json(json)
        val = json.get(&#39;doi&#39;)
        if val is not None:
            self.doi = val
        val = json.get(&#39;textReference&#39;)
        if val is not None:
            self.text_reference = val
        val = json.get(&#39;year&#39;)
        if val is not None:
            self.year = val
        val = json.get(&#39;externalFile&#39;)
        if val is not None:
            self.external_file = val


class UnitGroup(CategorizedEntity):
    &#34;&#34;&#34;
    A group of units that can be converted into each other.

    Attributes
    ----------
    default_flow_property: Ref
        Some LCA data formats do not have the concept of flow properties or
        quantities. This field provides a default link to a flow property for
        units that are contained in this group.

    units: List[Unit]
        The units of the unit group.

    &#34;&#34;&#34;

    def __init__(self):
        super(UnitGroup, self).__init__()
        self.default_flow_property: Optional[Ref] = None
        self.units: Optional[List[Unit]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(UnitGroup, self).to_json()
        if self.default_flow_property is not None:
            json[&#39;defaultFlowProperty&#39;] = self.default_flow_property.to_json()
        if self.units is not None:
            json[&#39;units&#39;] = []
            for e in self.units:
                json[&#39;units&#39;].append(e.to_json())
        return json

    def from_json(self, json: dict):
        super(UnitGroup, self).from_json(json)
        val = json.get(&#39;defaultFlowProperty&#39;)
        if val is not None:
            self.default_flow_property = Ref()
            self.default_flow_property.from_json(val)
        val = json.get(&#39;units&#39;)
        if val is not None:
            self.units = []
            for d in val:
                e = Unit()
                e.from_json(d)
                self.units.append(e)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="olca.schema.Actor"><code class="flex name class">
<span>class <span class="ident">Actor</span></span>
</code></dt>
<dd>
<div class="desc"><p>An actor is a person or organisation.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>address</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>city</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>country</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>email</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>telefax</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>telephone</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>website</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>zip_code</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Actor(CategorizedEntity):
    &#34;&#34;&#34;
    An actor is a person or organisation.

    Attributes
    ----------
    address: str

    city: str

    country: str

    email: str

    telefax: str

    telephone: str

    website: str

    zip_code: str

    &#34;&#34;&#34;

    def __init__(self):
        super(Actor, self).__init__()
        self.address: Optional[str] = None
        self.city: Optional[str] = None
        self.country: Optional[str] = None
        self.email: Optional[str] = None
        self.telefax: Optional[str] = None
        self.telephone: Optional[str] = None
        self.website: Optional[str] = None
        self.zip_code: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Actor, self).to_json()
        if self.address is not None:
            json[&#39;address&#39;] = self.address
        if self.city is not None:
            json[&#39;city&#39;] = self.city
        if self.country is not None:
            json[&#39;country&#39;] = self.country
        if self.email is not None:
            json[&#39;email&#39;] = self.email
        if self.telefax is not None:
            json[&#39;telefax&#39;] = self.telefax
        if self.telephone is not None:
            json[&#39;telephone&#39;] = self.telephone
        if self.website is not None:
            json[&#39;website&#39;] = self.website
        if self.zip_code is not None:
            json[&#39;zipCode&#39;] = self.zip_code
        return json

    def from_json(self, json: dict):
        super(Actor, self).from_json(json)
        val = json.get(&#39;address&#39;)
        if val is not None:
            self.address = val
        val = json.get(&#39;city&#39;)
        if val is not None:
            self.city = val
        val = json.get(&#39;country&#39;)
        if val is not None:
            self.country = val
        val = json.get(&#39;email&#39;)
        if val is not None:
            self.email = val
        val = json.get(&#39;telefax&#39;)
        if val is not None:
            self.telefax = val
        val = json.get(&#39;telephone&#39;)
        if val is not None:
            self.telephone = val
        val = json.get(&#39;website&#39;)
        if val is not None:
            self.website = val
        val = json.get(&#39;zipCode&#39;)
        if val is not None:
            self.zip_code = val</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.CategorizedEntity" href="#olca.schema.CategorizedEntity">CategorizedEntity</a></li>
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.Actor.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(Actor, self).from_json(json)
    val = json.get(&#39;address&#39;)
    if val is not None:
        self.address = val
    val = json.get(&#39;city&#39;)
    if val is not None:
        self.city = val
    val = json.get(&#39;country&#39;)
    if val is not None:
        self.country = val
    val = json.get(&#39;email&#39;)
    if val is not None:
        self.email = val
    val = json.get(&#39;telefax&#39;)
    if val is not None:
        self.telefax = val
    val = json.get(&#39;telephone&#39;)
    if val is not None:
        self.telephone = val
    val = json.get(&#39;website&#39;)
    if val is not None:
        self.website = val
    val = json.get(&#39;zipCode&#39;)
    if val is not None:
        self.zip_code = val</code></pre>
</details>
</dd>
<dt id="olca.schema.Actor.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(Actor, self).to_json()
    if self.address is not None:
        json[&#39;address&#39;] = self.address
    if self.city is not None:
        json[&#39;city&#39;] = self.city
    if self.country is not None:
        json[&#39;country&#39;] = self.country
    if self.email is not None:
        json[&#39;email&#39;] = self.email
    if self.telefax is not None:
        json[&#39;telefax&#39;] = self.telefax
    if self.telephone is not None:
        json[&#39;telephone&#39;] = self.telephone
    if self.website is not None:
        json[&#39;website&#39;] = self.website
    if self.zip_code is not None:
        json[&#39;zipCode&#39;] = self.zip_code
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.AllocationFactor"><code class="flex name class">
<span>class <span class="ident">AllocationFactor</span></span>
</code></dt>
<dd>
<div class="desc"><p>A single allocation factor in a process.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>product_exchange</code></strong> :&ensp;<code><a title="olca.schema.Exchange" href="#olca.schema.Exchange">Exchange</a></code></dt>
<dd>The output product.</dd>
<dt><strong><code>allocation_type</code></strong> :&ensp;<code><a title="olca.schema.AllocationType" href="#olca.schema.AllocationType">AllocationType</a></code></dt>
<dd>The type of allocation.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value of the allocation factor.</dd>
<dt><strong><code>allocated_exchange</code></strong> :&ensp;<code><a title="olca.schema.Exchange" href="#olca.schema.Exchange">Exchange</a></code></dt>
<dd>An input product or elementary flow exchange which is allocated by this
factor. This is only valid for causal allocation where allocation
factors can be assigned to single exchanges.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AllocationFactor(Entity):
    &#34;&#34;&#34;
    A single allocation factor in a process.

    Attributes
    ----------
    product_exchange: Exchange
        The output product.

    allocation_type: AllocationType
        The type of allocation.

    value: float
        The value of the allocation factor.

    allocated_exchange: Exchange
        An input product or elementary flow exchange which is allocated by this
        factor. This is only valid for causal allocation where allocation
        factors can be assigned to single exchanges.

    &#34;&#34;&#34;

    def __init__(self):
        super(AllocationFactor, self).__init__()
        self.product_exchange: Optional[Exchange] = None
        self.allocation_type: Optional[AllocationType] = None
        self.value: Optional[float] = None
        self.allocated_exchange: Optional[Exchange] = None

    def to_json(self) -&gt; dict:
        json: dict = super(AllocationFactor, self).to_json()
        if self.product_exchange is not None:
            json[&#39;productExchange&#39;] = self.product_exchange.to_json()
        if self.allocation_type is not None:
            json[&#39;allocationType&#39;] = self.allocation_type.value
        if self.value is not None:
            json[&#39;value&#39;] = self.value
        if self.allocated_exchange is not None:
            json[&#39;allocatedExchange&#39;] = self.allocated_exchange.to_json()
        return json

    def from_json(self, json: dict):
        super(AllocationFactor, self).from_json(json)
        val = json.get(&#39;productExchange&#39;)
        if val is not None:
            self.product_exchange = Exchange()
            self.product_exchange.from_json(val)
        val = json.get(&#39;allocationType&#39;)
        if val is not None:
            self.allocation_type = AllocationType(val)
        val = json.get(&#39;value&#39;)
        if val is not None:
            self.value = val
        val = json.get(&#39;allocatedExchange&#39;)
        if val is not None:
            self.allocated_exchange = Exchange()
            self.allocated_exchange.from_json(val)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.AllocationFactor.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(AllocationFactor, self).from_json(json)
    val = json.get(&#39;productExchange&#39;)
    if val is not None:
        self.product_exchange = Exchange()
        self.product_exchange.from_json(val)
    val = json.get(&#39;allocationType&#39;)
    if val is not None:
        self.allocation_type = AllocationType(val)
    val = json.get(&#39;value&#39;)
    if val is not None:
        self.value = val
    val = json.get(&#39;allocatedExchange&#39;)
    if val is not None:
        self.allocated_exchange = Exchange()
        self.allocated_exchange.from_json(val)</code></pre>
</details>
</dd>
<dt id="olca.schema.AllocationFactor.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(AllocationFactor, self).to_json()
    if self.product_exchange is not None:
        json[&#39;productExchange&#39;] = self.product_exchange.to_json()
    if self.allocation_type is not None:
        json[&#39;allocationType&#39;] = self.allocation_type.value
    if self.value is not None:
        json[&#39;value&#39;] = self.value
    if self.allocated_exchange is not None:
        json[&#39;allocatedExchange&#39;] = self.allocated_exchange.to_json()
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.AllocationType"><code class="flex name class">
<span>class <span class="ident">AllocationType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration type for allocation methods. This type is used to define the
type of an [AllocationFactor], the default allocation method of a
multi-functional [Process], or the allocation method in a
[CalculationSetup].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AllocationType(Enum):
    &#34;&#34;&#34;
    An enumeration type for allocation methods. This type is used to define the
    type of an [AllocationFactor], the default allocation method of a
    multi-functional [Process], or the allocation method in a
    [CalculationSetup].
    &#34;&#34;&#34;

    PHYSICAL_ALLOCATION = &#39;PHYSICAL_ALLOCATION&#39;
    ECONOMIC_ALLOCATION = &#39;ECONOMIC_ALLOCATION&#39;
    CAUSAL_ALLOCATION = &#39;CAUSAL_ALLOCATION&#39;
    USE_DEFAULT_ALLOCATION = &#39;USE_DEFAULT_ALLOCATION&#39;
    NO_ALLOCATION = &#39;NO_ALLOCATION&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.AllocationType.CAUSAL_ALLOCATION"><code class="name">var <span class="ident">CAUSAL_ALLOCATION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.AllocationType.ECONOMIC_ALLOCATION"><code class="name">var <span class="ident">ECONOMIC_ALLOCATION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.AllocationType.NO_ALLOCATION"><code class="name">var <span class="ident">NO_ALLOCATION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.AllocationType.PHYSICAL_ALLOCATION"><code class="name">var <span class="ident">PHYSICAL_ALLOCATION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.AllocationType.USE_DEFAULT_ALLOCATION"><code class="name">var <span class="ident">USE_DEFAULT_ALLOCATION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="olca.schema.CalculationSetup"><code class="flex name class">
<span>class <span class="ident">CalculationSetup</span></span>
</code></dt>
<dd>
<div class="desc"><p>A setup for a product system calculation.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>calculation_type</code></strong> :&ensp;<code><a title="olca.schema.CalculationType" href="#olca.schema.CalculationType">CalculationType</a></code></dt>
<dd>The type of calculation that should be performed.</dd>
<dt><strong><code>product_system</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The product system that should be calculated (required).</dd>
<dt><strong><code>impact_method</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The LCIA method for the calculation (optional).</dd>
<dt><strong><code>with_costs</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates whether life cycle costs should be also calculated
(optional).</dd>
<dt><strong><code>nw_set</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The normalisation and weighting set for the calculation (optional).</dd>
<dt><strong><code>allocation_method</code></strong> :&ensp;<code><a title="olca.schema.AllocationType" href="#olca.schema.AllocationType">AllocationType</a></code></dt>
<dd>The calculation type to be used in the calculation (optional).</dd>
<dt><strong><code>parameter_redefs</code></strong> :&ensp;<code>List[<a title="olca.schema.ParameterRedef" href="#olca.schema.ParameterRedef">ParameterRedef</a>]</code></dt>
<dd>A list of parameter redefinitions to be used in the calculation
(optional).</dd>
<dt><strong><code>amount</code></strong> :&ensp;<code>float</code></dt>
<dd>(optional)</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>(optional)</dd>
<dt><strong><code>flow_property</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>(optional)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CalculationSetup(Entity):
    &#34;&#34;&#34;
    A setup for a product system calculation.

    Attributes
    ----------
    calculation_type: CalculationType
        The type of calculation that should be performed.

    product_system: Ref
        The product system that should be calculated (required).

    impact_method: Ref
        The LCIA method for the calculation (optional).

    with_costs: bool
        Indicates whether life cycle costs should be also calculated
        (optional).

    nw_set: Ref
        The normalisation and weighting set for the calculation (optional).

    allocation_method: AllocationType
        The calculation type to be used in the calculation (optional).

    parameter_redefs: List[ParameterRedef]
        A list of parameter redefinitions to be used in the calculation
        (optional).

    amount: float
        (optional)

    unit: Ref
        (optional)

    flow_property: Ref
        (optional)

    &#34;&#34;&#34;

    def __init__(self):
        super(CalculationSetup, self).__init__()
        self.calculation_type: Optional[CalculationType] = None
        self.product_system: Optional[Ref] = None
        self.impact_method: Optional[Ref] = None
        self.with_costs: Optional[bool] = None
        self.nw_set: Optional[Ref] = None
        self.allocation_method: Optional[AllocationType] = None
        self.parameter_redefs: Optional[List[ParameterRedef]] = None
        self.amount: Optional[float] = None
        self.unit: Optional[Ref] = None
        self.flow_property: Optional[Ref] = None

    def to_json(self) -&gt; dict:
        json: dict = super(CalculationSetup, self).to_json()
        if self.calculation_type is not None:
            json[&#39;calculationType&#39;] = self.calculation_type.value
        if self.product_system is not None:
            json[&#39;productSystem&#39;] = self.product_system.to_json()
        if self.impact_method is not None:
            json[&#39;impactMethod&#39;] = self.impact_method.to_json()
        if self.with_costs is not None:
            json[&#39;withCosts&#39;] = self.with_costs
        if self.nw_set is not None:
            json[&#39;nwSet&#39;] = self.nw_set.to_json()
        if self.allocation_method is not None:
            json[&#39;allocationMethod&#39;] = self.allocation_method.value
        if self.parameter_redefs is not None:
            json[&#39;parameterRedefs&#39;] = []
            for e in self.parameter_redefs:
                json[&#39;parameterRedefs&#39;].append(e.to_json())
        if self.amount is not None:
            json[&#39;amount&#39;] = self.amount
        if self.unit is not None:
            json[&#39;unit&#39;] = self.unit.to_json()
        if self.flow_property is not None:
            json[&#39;flowProperty&#39;] = self.flow_property.to_json()
        return json

    def from_json(self, json: dict):
        super(CalculationSetup, self).from_json(json)
        val = json.get(&#39;calculationType&#39;)
        if val is not None:
            self.calculation_type = CalculationType(val)
        val = json.get(&#39;productSystem&#39;)
        if val is not None:
            self.product_system = Ref()
            self.product_system.from_json(val)
        val = json.get(&#39;impactMethod&#39;)
        if val is not None:
            self.impact_method = Ref()
            self.impact_method.from_json(val)
        val = json.get(&#39;withCosts&#39;)
        if val is not None:
            self.with_costs = val
        val = json.get(&#39;nwSet&#39;)
        if val is not None:
            self.nw_set = Ref()
            self.nw_set.from_json(val)
        val = json.get(&#39;allocationMethod&#39;)
        if val is not None:
            self.allocation_method = AllocationType(val)
        val = json.get(&#39;parameterRedefs&#39;)
        if val is not None:
            self.parameter_redefs = []
            for d in val:
                e = ParameterRedef()
                e.from_json(d)
                self.parameter_redefs.append(e)
        val = json.get(&#39;amount&#39;)
        if val is not None:
            self.amount = val
        val = json.get(&#39;unit&#39;)
        if val is not None:
            self.unit = Ref()
            self.unit.from_json(val)
        val = json.get(&#39;flowProperty&#39;)
        if val is not None:
            self.flow_property = Ref()
            self.flow_property.from_json(val)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.CalculationSetup.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(CalculationSetup, self).from_json(json)
    val = json.get(&#39;calculationType&#39;)
    if val is not None:
        self.calculation_type = CalculationType(val)
    val = json.get(&#39;productSystem&#39;)
    if val is not None:
        self.product_system = Ref()
        self.product_system.from_json(val)
    val = json.get(&#39;impactMethod&#39;)
    if val is not None:
        self.impact_method = Ref()
        self.impact_method.from_json(val)
    val = json.get(&#39;withCosts&#39;)
    if val is not None:
        self.with_costs = val
    val = json.get(&#39;nwSet&#39;)
    if val is not None:
        self.nw_set = Ref()
        self.nw_set.from_json(val)
    val = json.get(&#39;allocationMethod&#39;)
    if val is not None:
        self.allocation_method = AllocationType(val)
    val = json.get(&#39;parameterRedefs&#39;)
    if val is not None:
        self.parameter_redefs = []
        for d in val:
            e = ParameterRedef()
            e.from_json(d)
            self.parameter_redefs.append(e)
    val = json.get(&#39;amount&#39;)
    if val is not None:
        self.amount = val
    val = json.get(&#39;unit&#39;)
    if val is not None:
        self.unit = Ref()
        self.unit.from_json(val)
    val = json.get(&#39;flowProperty&#39;)
    if val is not None:
        self.flow_property = Ref()
        self.flow_property.from_json(val)</code></pre>
</details>
</dd>
<dt id="olca.schema.CalculationSetup.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(CalculationSetup, self).to_json()
    if self.calculation_type is not None:
        json[&#39;calculationType&#39;] = self.calculation_type.value
    if self.product_system is not None:
        json[&#39;productSystem&#39;] = self.product_system.to_json()
    if self.impact_method is not None:
        json[&#39;impactMethod&#39;] = self.impact_method.to_json()
    if self.with_costs is not None:
        json[&#39;withCosts&#39;] = self.with_costs
    if self.nw_set is not None:
        json[&#39;nwSet&#39;] = self.nw_set.to_json()
    if self.allocation_method is not None:
        json[&#39;allocationMethod&#39;] = self.allocation_method.value
    if self.parameter_redefs is not None:
        json[&#39;parameterRedefs&#39;] = []
        for e in self.parameter_redefs:
            json[&#39;parameterRedefs&#39;].append(e.to_json())
    if self.amount is not None:
        json[&#39;amount&#39;] = self.amount
    if self.unit is not None:
        json[&#39;unit&#39;] = self.unit.to_json()
    if self.flow_property is not None:
        json[&#39;flowProperty&#39;] = self.flow_property.to_json()
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.CalculationType"><code class="flex name class">
<span>class <span class="ident">CalculationType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration of the different calculation methods supported by openLCA.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CalculationType(Enum):
    &#34;&#34;&#34;
    An enumeration of the different calculation methods supported by openLCA.
    &#34;&#34;&#34;

    SIMPLE_CALCULATION = &#39;SIMPLE_CALCULATION&#39;
    CONTRIBUTION_ANALYSIS = &#39;CONTRIBUTION_ANALYSIS&#39;
    UPSTREAM_ANALYSIS = &#39;UPSTREAM_ANALYSIS&#39;
    REGIONALIZED_CALCULATION = &#39;REGIONALIZED_CALCULATION&#39;
    MONTE_CARLO_SIMULATION = &#39;MONTE_CARLO_SIMULATION&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.CalculationType.CONTRIBUTION_ANALYSIS"><code class="name">var <span class="ident">CONTRIBUTION_ANALYSIS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.CalculationType.MONTE_CARLO_SIMULATION"><code class="name">var <span class="ident">MONTE_CARLO_SIMULATION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.CalculationType.REGIONALIZED_CALCULATION"><code class="name">var <span class="ident">REGIONALIZED_CALCULATION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.CalculationType.SIMPLE_CALCULATION"><code class="name">var <span class="ident">SIMPLE_CALCULATION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.CalculationType.UPSTREAM_ANALYSIS"><code class="name">var <span class="ident">UPSTREAM_ANALYSIS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="olca.schema.CategorizedEntity"><code class="flex name class">
<span>class <span class="ident">CategorizedEntity</span></span>
</code></dt>
<dd>
<div class="desc"><p>A root entity which can have a category.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>category</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The category of the entity.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CategorizedEntity(RootEntity):
    &#34;&#34;&#34;
    A root entity which can have a category.

    Attributes
    ----------
    category: Ref
        The category of the entity.

    &#34;&#34;&#34;

    def __init__(self):
        super(CategorizedEntity, self).__init__()
        self.category: Optional[Ref] = None

    def to_json(self) -&gt; dict:
        json: dict = super(CategorizedEntity, self).to_json()
        if self.category is not None:
            json[&#39;category&#39;] = self.category.to_json()
        return json

    def from_json(self, json: dict):
        super(CategorizedEntity, self).from_json(json)
        val = json.get(&#39;category&#39;)
        if val is not None:
            self.category = Ref()
            self.category.from_json(val)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="olca.schema.Actor" href="#olca.schema.Actor">Actor</a></li>
<li><a title="olca.schema.Category" href="#olca.schema.Category">Category</a></li>
<li><a title="olca.schema.DqSystem" href="#olca.schema.DqSystem">DqSystem</a></li>
<li><a title="olca.schema.Flow" href="#olca.schema.Flow">Flow</a></li>
<li><a title="olca.schema.FlowProperty" href="#olca.schema.FlowProperty">FlowProperty</a></li>
<li><a title="olca.schema.ImpactMethod" href="#olca.schema.ImpactMethod">ImpactMethod</a></li>
<li><a title="olca.schema.Process" href="#olca.schema.Process">Process</a></li>
<li><a title="olca.schema.ProductSystem" href="#olca.schema.ProductSystem">ProductSystem</a></li>
<li><a title="olca.schema.SocialIndicator" href="#olca.schema.SocialIndicator">SocialIndicator</a></li>
<li><a title="olca.schema.Source" href="#olca.schema.Source">Source</a></li>
<li><a title="olca.schema.UnitGroup" href="#olca.schema.UnitGroup">UnitGroup</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.CategorizedEntity.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(CategorizedEntity, self).from_json(json)
    val = json.get(&#39;category&#39;)
    if val is not None:
        self.category = Ref()
        self.category.from_json(val)</code></pre>
</details>
</dd>
<dt id="olca.schema.CategorizedEntity.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(CategorizedEntity, self).to_json()
    if self.category is not None:
        json[&#39;category&#39;] = self.category.to_json()
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.Category"><code class="flex name class">
<span>class <span class="ident">Category</span></span>
</code></dt>
<dd>
<div class="desc"><p>A category is used for the categorisation of types like processes, flows,
etc. The tricky thing is that the <code><a title="olca.schema.Category" href="#olca.schema.Category">Category</a></code> class inherits also from the
[CategorizedEntity] type so that a category can have a category attribute
which is then the parent category of this category (uff).</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>model_type</code></strong> :&ensp;<code><a title="olca.schema.ModelType" href="#olca.schema.ModelType">ModelType</a></code></dt>
<dd>The type of models that can be linked to the category.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Category(CategorizedEntity):
    &#34;&#34;&#34;
    A category is used for the categorisation of types like processes, flows,
    etc. The tricky thing is that the `Category` class inherits also from the
    [CategorizedEntity] type so that a category can have a category attribute
    which is then the parent category of this category (uff).

    Attributes
    ----------
    model_type: ModelType
        The type of models that can be linked to the category.

    &#34;&#34;&#34;

    def __init__(self):
        super(Category, self).__init__()
        self.model_type: Optional[ModelType] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Category, self).to_json()
        if self.model_type is not None:
            json[&#39;modelType&#39;] = self.model_type.value
        return json

    def from_json(self, json: dict):
        super(Category, self).from_json(json)
        val = json.get(&#39;modelType&#39;)
        if val is not None:
            self.model_type = ModelType(val)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.CategorizedEntity" href="#olca.schema.CategorizedEntity">CategorizedEntity</a></li>
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.Category.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(Category, self).from_json(json)
    val = json.get(&#39;modelType&#39;)
    if val is not None:
        self.model_type = ModelType(val)</code></pre>
</details>
</dd>
<dt id="olca.schema.Category.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(Category, self).to_json()
    if self.model_type is not None:
        json[&#39;modelType&#39;] = self.model_type.value
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.DqIndicator"><code class="flex name class">
<span>class <span class="ident">DqIndicator</span></span>
</code></dt>
<dd>
<div class="desc"><p>An indicator of a data quality system ([DqSystem]).</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>scores</code></strong> :&ensp;<code>List[<a title="olca.schema.DqScore" href="#olca.schema.DqScore">DqScore</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DqIndicator(Entity):
    &#34;&#34;&#34;
    An indicator of a data quality system ([DqSystem]).

    Attributes
    ----------
    name: str

    position: int

    scores: List[DqScore]

    &#34;&#34;&#34;

    def __init__(self):
        super(DqIndicator, self).__init__()
        self.name: Optional[str] = None
        self.position: Optional[int] = None
        self.scores: Optional[List[DqScore]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(DqIndicator, self).to_json()
        if self.name is not None:
            json[&#39;name&#39;] = self.name
        if self.position is not None:
            json[&#39;position&#39;] = self.position
        if self.scores is not None:
            json[&#39;scores&#39;] = []
            for e in self.scores:
                json[&#39;scores&#39;].append(e.to_json())
        return json

    def from_json(self, json: dict):
        super(DqIndicator, self).from_json(json)
        val = json.get(&#39;name&#39;)
        if val is not None:
            self.name = val
        val = json.get(&#39;position&#39;)
        if val is not None:
            self.position = val
        val = json.get(&#39;scores&#39;)
        if val is not None:
            self.scores = []
            for d in val:
                e = DqScore()
                e.from_json(d)
                self.scores.append(e)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.DqIndicator.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(DqIndicator, self).from_json(json)
    val = json.get(&#39;name&#39;)
    if val is not None:
        self.name = val
    val = json.get(&#39;position&#39;)
    if val is not None:
        self.position = val
    val = json.get(&#39;scores&#39;)
    if val is not None:
        self.scores = []
        for d in val:
            e = DqScore()
            e.from_json(d)
            self.scores.append(e)</code></pre>
</details>
</dd>
<dt id="olca.schema.DqIndicator.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(DqIndicator, self).to_json()
    if self.name is not None:
        json[&#39;name&#39;] = self.name
    if self.position is not None:
        json[&#39;position&#39;] = self.position
    if self.scores is not None:
        json[&#39;scores&#39;] = []
        for e in self.scores:
            json[&#39;scores&#39;].append(e.to_json())
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.DqScore"><code class="flex name class">
<span>class <span class="ident">DqScore</span></span>
</code></dt>
<dd>
<div class="desc"><p>An score value of an indicator ([DqIndicator]) in a data quality system
([DqSystem]).</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>label</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>uncertainty</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DqScore(Entity):
    &#34;&#34;&#34;
    An score value of an indicator ([DqIndicator]) in a data quality system
    ([DqSystem]).

    Attributes
    ----------
    position: int

    label: str

    description: str

    uncertainty: float

    &#34;&#34;&#34;

    def __init__(self):
        super(DqScore, self).__init__()
        self.position: Optional[int] = None
        self.label: Optional[str] = None
        self.description: Optional[str] = None
        self.uncertainty: Optional[float] = None

    def to_json(self) -&gt; dict:
        json: dict = super(DqScore, self).to_json()
        if self.position is not None:
            json[&#39;position&#39;] = self.position
        if self.label is not None:
            json[&#39;label&#39;] = self.label
        if self.description is not None:
            json[&#39;description&#39;] = self.description
        if self.uncertainty is not None:
            json[&#39;uncertainty&#39;] = self.uncertainty
        return json

    def from_json(self, json: dict):
        super(DqScore, self).from_json(json)
        val = json.get(&#39;position&#39;)
        if val is not None:
            self.position = val
        val = json.get(&#39;label&#39;)
        if val is not None:
            self.label = val
        val = json.get(&#39;description&#39;)
        if val is not None:
            self.description = val
        val = json.get(&#39;uncertainty&#39;)
        if val is not None:
            self.uncertainty = val</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.DqScore.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(DqScore, self).from_json(json)
    val = json.get(&#39;position&#39;)
    if val is not None:
        self.position = val
    val = json.get(&#39;label&#39;)
    if val is not None:
        self.label = val
    val = json.get(&#39;description&#39;)
    if val is not None:
        self.description = val
    val = json.get(&#39;uncertainty&#39;)
    if val is not None:
        self.uncertainty = val</code></pre>
</details>
</dd>
<dt id="olca.schema.DqScore.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(DqScore, self).to_json()
    if self.position is not None:
        json[&#39;position&#39;] = self.position
    if self.label is not None:
        json[&#39;label&#39;] = self.label
    if self.description is not None:
        json[&#39;description&#39;] = self.description
    if self.uncertainty is not None:
        json[&#39;uncertainty&#39;] = self.uncertainty
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.DqSystem"><code class="flex name class">
<span>class <span class="ident">DqSystem</span></span>
</code></dt>
<dd>
<div class="desc"><p>A data quality system.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>has_uncertainties</code></strong> :&ensp;<code>bool</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>source</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>indicators</code></strong> :&ensp;<code>List[<a title="olca.schema.DqIndicator" href="#olca.schema.DqIndicator">DqIndicator</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DqSystem(CategorizedEntity):
    &#34;&#34;&#34;
    A data quality system.

    Attributes
    ----------
    has_uncertainties: bool

    source: Ref

    indicators: List[DqIndicator]

    &#34;&#34;&#34;

    def __init__(self):
        super(DqSystem, self).__init__()
        self.has_uncertainties: Optional[bool] = None
        self.source: Optional[Ref] = None
        self.indicators: Optional[List[DqIndicator]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(DqSystem, self).to_json()
        if self.has_uncertainties is not None:
            json[&#39;hasUncertainties&#39;] = self.has_uncertainties
        if self.source is not None:
            json[&#39;source&#39;] = self.source.to_json()
        if self.indicators is not None:
            json[&#39;indicators&#39;] = []
            for e in self.indicators:
                json[&#39;indicators&#39;].append(e.to_json())
        return json

    def from_json(self, json: dict):
        super(DqSystem, self).from_json(json)
        val = json.get(&#39;hasUncertainties&#39;)
        if val is not None:
            self.has_uncertainties = val
        val = json.get(&#39;source&#39;)
        if val is not None:
            self.source = Ref()
            self.source.from_json(val)
        val = json.get(&#39;indicators&#39;)
        if val is not None:
            self.indicators = []
            for d in val:
                e = DqIndicator()
                e.from_json(d)
                self.indicators.append(e)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.CategorizedEntity" href="#olca.schema.CategorizedEntity">CategorizedEntity</a></li>
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.DqSystem.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(DqSystem, self).from_json(json)
    val = json.get(&#39;hasUncertainties&#39;)
    if val is not None:
        self.has_uncertainties = val
    val = json.get(&#39;source&#39;)
    if val is not None:
        self.source = Ref()
        self.source.from_json(val)
    val = json.get(&#39;indicators&#39;)
    if val is not None:
        self.indicators = []
        for d in val:
            e = DqIndicator()
            e.from_json(d)
            self.indicators.append(e)</code></pre>
</details>
</dd>
<dt id="olca.schema.DqSystem.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(DqSystem, self).to_json()
    if self.has_uncertainties is not None:
        json[&#39;hasUncertainties&#39;] = self.has_uncertainties
    if self.source is not None:
        json[&#39;source&#39;] = self.source.to_json()
    if self.indicators is not None:
        json[&#39;indicators&#39;] = []
        for e in self.indicators:
            json[&#39;indicators&#39;].append(e.to_json())
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.Entity"><code class="flex name class">
<span>class <span class="ident">Entity</span></span>
</code></dt>
<dd>
<div class="desc"><p>The most generic type of the openLCA data model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Entity(object):
    &#34;&#34;&#34;
    The most generic type of the openLCA data model.
    &#34;&#34;&#34;

    def __init__(self):
        self.id: str = &#39;&#39;
        self.olca_type: str = &#39;&#39;

    def to_json(self) -&gt; dict:
        o_type = self.olca_type
        if o_type is None:
            o_type = type(self).__name__
        json = {&#39;@type&#39;: o_type}
        if self.id is not None:
            json[&#39;@id&#39;] = self.id
        return json

    def from_json(self, json: dict):
        self.id = json.get(&#39;@id&#39;)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="olca.schema.AllocationFactor" href="#olca.schema.AllocationFactor">AllocationFactor</a></li>
<li><a title="olca.schema.CalculationSetup" href="#olca.schema.CalculationSetup">CalculationSetup</a></li>
<li><a title="olca.schema.DqIndicator" href="#olca.schema.DqIndicator">DqIndicator</a></li>
<li><a title="olca.schema.DqScore" href="#olca.schema.DqScore">DqScore</a></li>
<li><a title="olca.schema.Exchange" href="#olca.schema.Exchange">Exchange</a></li>
<li><a title="olca.schema.FlowMapRef" href="#olca.schema.FlowMapRef">FlowMapRef</a></li>
<li><a title="olca.schema.FlowPropertyFactor" href="#olca.schema.FlowPropertyFactor">FlowPropertyFactor</a></li>
<li><a title="olca.schema.FlowResult" href="#olca.schema.FlowResult">FlowResult</a></li>
<li><a title="olca.schema.ImpactFactor" href="#olca.schema.ImpactFactor">ImpactFactor</a></li>
<li><a title="olca.schema.ImpactResult" href="#olca.schema.ImpactResult">ImpactResult</a></li>
<li><a title="olca.schema.Parameter" href="#olca.schema.Parameter">Parameter</a></li>
<li><a title="olca.schema.ParameterRedef" href="#olca.schema.ParameterRedef">ParameterRedef</a></li>
<li><a title="olca.schema.ProcessDocumentation" href="#olca.schema.ProcessDocumentation">ProcessDocumentation</a></li>
<li><a title="olca.schema.ProcessLink" href="#olca.schema.ProcessLink">ProcessLink</a></li>
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.SimpleResult" href="#olca.schema.SimpleResult">SimpleResult</a></li>
<li><a title="olca.schema.Uncertainty" href="#olca.schema.Uncertainty">Uncertainty</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.Entity.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    self.id = json.get(&#39;@id&#39;)</code></pre>
</details>
</dd>
<dt id="olca.schema.Entity.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    o_type = self.olca_type
    if o_type is None:
        o_type = type(self).__name__
    json = {&#39;@type&#39;: o_type}
    if self.id is not None:
        json[&#39;@id&#39;] = self.id
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.Exchange"><code class="flex name class">
<span>class <span class="ident">Exchange</span></span>
</code></dt>
<dd>
<div class="desc"><p>An Exchange is an input or output of a [Flow] in a [Process]. The amount of
an exchange is given in a specific unit of a quantity ([FlowProperty]) of
the flow. The allowed units and flow properties that can be used for a flow
in an exchange are defined by the flow property information in that flow
(see also the [FlowPropertyFactor] type).</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>internal_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The process internal ID of the exchange. This is used to identify
exchanges unambiguously within a process (e.g. when linking exchanges
in a product system where multiple exchanges with the same flow are
allowed). The value should be &gt;= 1.</dd>
<dt><strong><code>avoided_product</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates whether this exchange is an avoided product.</dd>
<dt><strong><code>flow</code></strong> :&ensp;<code><a title="olca.schema.FlowRef" href="#olca.schema.FlowRef">FlowRef</a></code></dt>
<dd>The reference to the flow of the exchange.</dd>
<dt><strong><code>flow_property</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The quantity in which the amount is given.</dd>
<dt><strong><code>input</code></strong> :&ensp;<code>bool</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>quantitative_reference</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates whether the exchange is the quantitative reference of the
process.</dd>
<dt><strong><code>base_uncertainty</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>default_provider</code></strong> :&ensp;<code><a title="olca.schema.ProcessRef" href="#olca.schema.ProcessRef">ProcessRef</a></code></dt>
<dd>A default provider is a [Process] that is linked as the provider of a
product input or the waste treatment provider of a waste output. It is
just an optional default setting which can be also ignored when
building product systems in openLCA. The user is always free to link
processes in product systems ignoring these defaults (but the flows and
flow directions have to match of course).</dd>
<dt><strong><code>amount</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>amount_formula</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>dq_entry</code></strong> :&ensp;<code>str</code></dt>
<dd>A data quality entry like <code>(1;3;2;5;1)</code>. The entry is a vector of data
quality values that need to match the data quality scheme for flow
inputs and outputs that is assigned to the [Process]. In such a scheme
the data quality indicators have fixed positions and the respective
values in the <code>dqEntry</code> vector map to these positions.</dd>
<dt><strong><code>uncertainty</code></strong> :&ensp;<code><a title="olca.schema.Uncertainty" href="#olca.schema.Uncertainty">Uncertainty</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code></dt>
<dd>A general comment about the input or output.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Exchange(Entity):
    &#34;&#34;&#34;
    An Exchange is an input or output of a [Flow] in a [Process]. The amount of
    an exchange is given in a specific unit of a quantity ([FlowProperty]) of
    the flow. The allowed units and flow properties that can be used for a flow
    in an exchange are defined by the flow property information in that flow
    (see also the [FlowPropertyFactor] type).

    Attributes
    ----------
    internal_id: int
        The process internal ID of the exchange. This is used to identify
        exchanges unambiguously within a process (e.g. when linking exchanges
        in a product system where multiple exchanges with the same flow are
        allowed). The value should be &gt;= 1.

    avoided_product: bool
        Indicates whether this exchange is an avoided product.

    flow: FlowRef
        The reference to the flow of the exchange.

    flow_property: Ref
        The quantity in which the amount is given.

    input: bool

    quantitative_reference: bool
        Indicates whether the exchange is the quantitative reference of the
        process.

    base_uncertainty: float

    default_provider: ProcessRef
        A default provider is a [Process] that is linked as the provider of a
        product input or the waste treatment provider of a waste output. It is
        just an optional default setting which can be also ignored when
        building product systems in openLCA. The user is always free to link
        processes in product systems ignoring these defaults (but the flows and
        flow directions have to match of course).

    amount: float

    amount_formula: str

    unit: Ref

    dq_entry: str
        A data quality entry like `(1;3;2;5;1)`. The entry is a vector of data
        quality values that need to match the data quality scheme for flow
        inputs and outputs that is assigned to the [Process]. In such a scheme
        the data quality indicators have fixed positions and the respective
        values in the `dqEntry` vector map to these positions.

    uncertainty: Uncertainty

    description: str
        A general comment about the input or output.

    &#34;&#34;&#34;

    def __init__(self):
        super(Exchange, self).__init__()
        self.internal_id: Optional[int] = None
        self.avoided_product: Optional[bool] = None
        self.flow: Optional[FlowRef] = None
        self.flow_property: Optional[Ref] = None
        self.input: Optional[bool] = None
        self.quantitative_reference: Optional[bool] = None
        self.base_uncertainty: Optional[float] = None
        self.default_provider: Optional[ProcessRef] = None
        self.amount: Optional[float] = None
        self.amount_formula: Optional[str] = None
        self.unit: Optional[Ref] = None
        self.dq_entry: Optional[str] = None
        self.uncertainty: Optional[Uncertainty] = None
        self.description: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Exchange, self).to_json()
        if self.internal_id is not None:
            json[&#39;internalId&#39;] = self.internal_id
        if self.avoided_product is not None:
            json[&#39;avoidedProduct&#39;] = self.avoided_product
        if self.flow is not None:
            json[&#39;flow&#39;] = self.flow.to_json()
        if self.flow_property is not None:
            json[&#39;flowProperty&#39;] = self.flow_property.to_json()
        if self.input is not None:
            json[&#39;input&#39;] = self.input
        if self.quantitative_reference is not None:
            json[&#39;quantitativeReference&#39;] = self.quantitative_reference
        if self.base_uncertainty is not None:
            json[&#39;baseUncertainty&#39;] = self.base_uncertainty
        if self.default_provider is not None:
            json[&#39;defaultProvider&#39;] = self.default_provider.to_json()
        if self.amount is not None:
            json[&#39;amount&#39;] = self.amount
        if self.amount_formula is not None:
            json[&#39;amountFormula&#39;] = self.amount_formula
        if self.unit is not None:
            json[&#39;unit&#39;] = self.unit.to_json()
        if self.dq_entry is not None:
            json[&#39;dqEntry&#39;] = self.dq_entry
        if self.uncertainty is not None:
            json[&#39;uncertainty&#39;] = self.uncertainty.to_json()
        if self.description is not None:
            json[&#39;description&#39;] = self.description
        return json

    def from_json(self, json: dict):
        super(Exchange, self).from_json(json)
        val = json.get(&#39;internalId&#39;)
        if val is not None:
            self.internal_id = val
        val = json.get(&#39;avoidedProduct&#39;)
        if val is not None:
            self.avoided_product = val
        val = json.get(&#39;flow&#39;)
        if val is not None:
            self.flow = FlowRef()
            self.flow.from_json(val)
        val = json.get(&#39;flowProperty&#39;)
        if val is not None:
            self.flow_property = Ref()
            self.flow_property.from_json(val)
        val = json.get(&#39;input&#39;)
        if val is not None:
            self.input = val
        val = json.get(&#39;quantitativeReference&#39;)
        if val is not None:
            self.quantitative_reference = val
        val = json.get(&#39;baseUncertainty&#39;)
        if val is not None:
            self.base_uncertainty = val
        val = json.get(&#39;defaultProvider&#39;)
        if val is not None:
            self.default_provider = ProcessRef()
            self.default_provider.from_json(val)
        val = json.get(&#39;amount&#39;)
        if val is not None:
            self.amount = val
        val = json.get(&#39;amountFormula&#39;)
        if val is not None:
            self.amount_formula = val
        val = json.get(&#39;unit&#39;)
        if val is not None:
            self.unit = Ref()
            self.unit.from_json(val)
        val = json.get(&#39;dqEntry&#39;)
        if val is not None:
            self.dq_entry = val
        val = json.get(&#39;uncertainty&#39;)
        if val is not None:
            self.uncertainty = Uncertainty()
            self.uncertainty.from_json(val)
        val = json.get(&#39;description&#39;)
        if val is not None:
            self.description = val</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.Exchange.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(Exchange, self).from_json(json)
    val = json.get(&#39;internalId&#39;)
    if val is not None:
        self.internal_id = val
    val = json.get(&#39;avoidedProduct&#39;)
    if val is not None:
        self.avoided_product = val
    val = json.get(&#39;flow&#39;)
    if val is not None:
        self.flow = FlowRef()
        self.flow.from_json(val)
    val = json.get(&#39;flowProperty&#39;)
    if val is not None:
        self.flow_property = Ref()
        self.flow_property.from_json(val)
    val = json.get(&#39;input&#39;)
    if val is not None:
        self.input = val
    val = json.get(&#39;quantitativeReference&#39;)
    if val is not None:
        self.quantitative_reference = val
    val = json.get(&#39;baseUncertainty&#39;)
    if val is not None:
        self.base_uncertainty = val
    val = json.get(&#39;defaultProvider&#39;)
    if val is not None:
        self.default_provider = ProcessRef()
        self.default_provider.from_json(val)
    val = json.get(&#39;amount&#39;)
    if val is not None:
        self.amount = val
    val = json.get(&#39;amountFormula&#39;)
    if val is not None:
        self.amount_formula = val
    val = json.get(&#39;unit&#39;)
    if val is not None:
        self.unit = Ref()
        self.unit.from_json(val)
    val = json.get(&#39;dqEntry&#39;)
    if val is not None:
        self.dq_entry = val
    val = json.get(&#39;uncertainty&#39;)
    if val is not None:
        self.uncertainty = Uncertainty()
        self.uncertainty.from_json(val)
    val = json.get(&#39;description&#39;)
    if val is not None:
        self.description = val</code></pre>
</details>
</dd>
<dt id="olca.schema.Exchange.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(Exchange, self).to_json()
    if self.internal_id is not None:
        json[&#39;internalId&#39;] = self.internal_id
    if self.avoided_product is not None:
        json[&#39;avoidedProduct&#39;] = self.avoided_product
    if self.flow is not None:
        json[&#39;flow&#39;] = self.flow.to_json()
    if self.flow_property is not None:
        json[&#39;flowProperty&#39;] = self.flow_property.to_json()
    if self.input is not None:
        json[&#39;input&#39;] = self.input
    if self.quantitative_reference is not None:
        json[&#39;quantitativeReference&#39;] = self.quantitative_reference
    if self.base_uncertainty is not None:
        json[&#39;baseUncertainty&#39;] = self.base_uncertainty
    if self.default_provider is not None:
        json[&#39;defaultProvider&#39;] = self.default_provider.to_json()
    if self.amount is not None:
        json[&#39;amount&#39;] = self.amount
    if self.amount_formula is not None:
        json[&#39;amountFormula&#39;] = self.amount_formula
    if self.unit is not None:
        json[&#39;unit&#39;] = self.unit.to_json()
    if self.dq_entry is not None:
        json[&#39;dqEntry&#39;] = self.dq_entry
    if self.uncertainty is not None:
        json[&#39;uncertainty&#39;] = self.uncertainty.to_json()
    if self.description is not None:
        json[&#39;description&#39;] = self.description
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.Flow"><code class="flex name class">
<span>class <span class="ident">Flow</span></span>
</code></dt>
<dd>
<div class="desc"><p>Everything that can be an input or output of a process (e.g. a substance, a
product, a waste, a service etc.)</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>flow_type</code></strong> :&ensp;<code><a title="olca.schema.FlowType" href="#olca.schema.FlowType">FlowType</a></code></dt>
<dd>The type of the flow. Note that this type is more a descriptor of how
the flow is handled in calculations.</dd>
<dt><strong><code>cas</code></strong> :&ensp;<code>str</code></dt>
<dd>A CAS number of the flow.</dd>
<dt><strong><code>formula</code></strong> :&ensp;<code>str</code></dt>
<dd>A chemical formula of the flow.</dd>
<dt><strong><code>flow_properties</code></strong> :&ensp;<code>List[<a title="olca.schema.FlowPropertyFactor" href="#olca.schema.FlowPropertyFactor">FlowPropertyFactor</a>]</code></dt>
<dd>The flow properties (quantities) in which amounts of the flow can be
expressed together with conversion factors between these flow flow
properties.</dd>
<dt><strong><code>location</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The location of the flow. Normally the location of a flow is defined by
the process location where the flow is an input or output. However,
some data formats define a location as a property of a flow.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Flow(CategorizedEntity):
    &#34;&#34;&#34;
    Everything that can be an input or output of a process (e.g. a substance, a
    product, a waste, a service etc.)

    Attributes
    ----------
    flow_type: FlowType
        The type of the flow. Note that this type is more a descriptor of how
        the flow is handled in calculations.

    cas: str
        A CAS number of the flow.

    formula: str
        A chemical formula of the flow.

    flow_properties: List[FlowPropertyFactor]
        The flow properties (quantities) in which amounts of the flow can be
        expressed together with conversion factors between these flow flow
        properties.

    location: Ref
        The location of the flow. Normally the location of a flow is defined by
        the process location where the flow is an input or output. However,
        some data formats define a location as a property of a flow.

    &#34;&#34;&#34;

    def __init__(self):
        super(Flow, self).__init__()
        self.flow_type: Optional[FlowType] = None
        self.cas: Optional[str] = None
        self.formula: Optional[str] = None
        self.flow_properties: Optional[List[FlowPropertyFactor]] = None
        self.location: Optional[Ref] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Flow, self).to_json()
        if self.flow_type is not None:
            json[&#39;flowType&#39;] = self.flow_type.value
        if self.cas is not None:
            json[&#39;cas&#39;] = self.cas
        if self.formula is not None:
            json[&#39;formula&#39;] = self.formula
        if self.flow_properties is not None:
            json[&#39;flowProperties&#39;] = []
            for e in self.flow_properties:
                json[&#39;flowProperties&#39;].append(e.to_json())
        if self.location is not None:
            json[&#39;location&#39;] = self.location.to_json()
        return json

    def from_json(self, json: dict):
        super(Flow, self).from_json(json)
        val = json.get(&#39;flowType&#39;)
        if val is not None:
            self.flow_type = FlowType(val)
        val = json.get(&#39;cas&#39;)
        if val is not None:
            self.cas = val
        val = json.get(&#39;formula&#39;)
        if val is not None:
            self.formula = val
        val = json.get(&#39;flowProperties&#39;)
        if val is not None:
            self.flow_properties = []
            for d in val:
                e = FlowPropertyFactor()
                e.from_json(d)
                self.flow_properties.append(e)
        val = json.get(&#39;location&#39;)
        if val is not None:
            self.location = Ref()
            self.location.from_json(val)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.CategorizedEntity" href="#olca.schema.CategorizedEntity">CategorizedEntity</a></li>
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.Flow.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(Flow, self).from_json(json)
    val = json.get(&#39;flowType&#39;)
    if val is not None:
        self.flow_type = FlowType(val)
    val = json.get(&#39;cas&#39;)
    if val is not None:
        self.cas = val
    val = json.get(&#39;formula&#39;)
    if val is not None:
        self.formula = val
    val = json.get(&#39;flowProperties&#39;)
    if val is not None:
        self.flow_properties = []
        for d in val:
            e = FlowPropertyFactor()
            e.from_json(d)
            self.flow_properties.append(e)
    val = json.get(&#39;location&#39;)
    if val is not None:
        self.location = Ref()
        self.location.from_json(val)</code></pre>
</details>
</dd>
<dt id="olca.schema.Flow.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(Flow, self).to_json()
    if self.flow_type is not None:
        json[&#39;flowType&#39;] = self.flow_type.value
    if self.cas is not None:
        json[&#39;cas&#39;] = self.cas
    if self.formula is not None:
        json[&#39;formula&#39;] = self.formula
    if self.flow_properties is not None:
        json[&#39;flowProperties&#39;] = []
        for e in self.flow_properties:
            json[&#39;flowProperties&#39;].append(e.to_json())
    if self.location is not None:
        json[&#39;location&#39;] = self.location.to_json()
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.FlowMap"><code class="flex name class">
<span>class <span class="ident">FlowMap</span></span>
</code></dt>
<dd>
<div class="desc"><p>A crosswalk of flows from a source flow list to a target flow list.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>source</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The reference (id, name, description) of the source flow list.</dd>
<dt><strong><code>target</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The reference (id, name, description) of the target flow list.</dd>
<dt><strong><code>mappings</code></strong> :&ensp;<code>List[<a title="olca.schema.FlowMapEntry" href="#olca.schema.FlowMapEntry">FlowMapEntry</a>]</code></dt>
<dd>A list of flow mappings from flows in a source flow list to flows in a
target flow list.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FlowMap(RootEntity):
    &#34;&#34;&#34;
    A crosswalk of flows from a source flow list to a target flow list.

    Attributes
    ----------
    source: Ref
        The reference (id, name, description) of the source flow list.

    target: Ref
        The reference (id, name, description) of the target flow list.

    mappings: List[FlowMapEntry]
        A list of flow mappings from flows in a source flow list to flows in a
        target flow list.

    &#34;&#34;&#34;

    def __init__(self):
        super(FlowMap, self).__init__()
        self.source: Optional[Ref] = None
        self.target: Optional[Ref] = None
        self.mappings: Optional[List[FlowMapEntry]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(FlowMap, self).to_json()
        if self.source is not None:
            json[&#39;source&#39;] = self.source.to_json()
        if self.target is not None:
            json[&#39;target&#39;] = self.target.to_json()
        if self.mappings is not None:
            json[&#39;mappings&#39;] = []
            for e in self.mappings:
                json[&#39;mappings&#39;].append(e.to_json())
        return json

    def from_json(self, json: dict):
        super(FlowMap, self).from_json(json)
        val = json.get(&#39;source&#39;)
        if val is not None:
            self.source = Ref()
            self.source.from_json(val)
        val = json.get(&#39;target&#39;)
        if val is not None:
            self.target = Ref()
            self.target.from_json(val)
        val = json.get(&#39;mappings&#39;)
        if val is not None:
            self.mappings = []
            for d in val:
                e = FlowMapEntry()
                e.from_json(d)
                self.mappings.append(e)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.FlowMap.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(FlowMap, self).from_json(json)
    val = json.get(&#39;source&#39;)
    if val is not None:
        self.source = Ref()
        self.source.from_json(val)
    val = json.get(&#39;target&#39;)
    if val is not None:
        self.target = Ref()
        self.target.from_json(val)
    val = json.get(&#39;mappings&#39;)
    if val is not None:
        self.mappings = []
        for d in val:
            e = FlowMapEntry()
            e.from_json(d)
            self.mappings.append(e)</code></pre>
</details>
</dd>
<dt id="olca.schema.FlowMap.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(FlowMap, self).to_json()
    if self.source is not None:
        json[&#39;source&#39;] = self.source.to_json()
    if self.target is not None:
        json[&#39;target&#39;] = self.target.to_json()
    if self.mappings is not None:
        json[&#39;mappings&#39;] = []
        for e in self.mappings:
            json[&#39;mappings&#39;].append(e.to_json())
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.FlowMapEntry"><code class="flex name class">
<span>class <span class="ident">FlowMapEntry</span></span>
</code></dt>
<dd>
<div class="desc"><p>A mapping from one flow to another.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>from_</code></strong> :&ensp;<code><a title="olca.schema.FlowMapRef" href="#olca.schema.FlowMapRef">FlowMapRef</a></code></dt>
<dd>The flow, flow property, and unit of the source flow.</dd>
<dt><strong><code>to</code></strong> :&ensp;<code><a title="olca.schema.FlowMapRef" href="#olca.schema.FlowMapRef">FlowMapRef</a></code></dt>
<dd>The flow, flow property, and unit of the target flow.</dd>
<dt><strong><code>conversion_factor</code></strong> :&ensp;<code>float</code></dt>
<dd>The factor to convert the original source flow to the target flow.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FlowMapEntry(RootEntity):
    &#34;&#34;&#34;
    A mapping from one flow to another.

    Attributes
    ----------
    from_: FlowMapRef
        The flow, flow property, and unit of the source flow.

    to: FlowMapRef
        The flow, flow property, and unit of the target flow.

    conversion_factor: float
        The factor to convert the original source flow to the target flow.

    &#34;&#34;&#34;

    def __init__(self):
        super(FlowMapEntry, self).__init__()
        self.from_: Optional[FlowMapRef] = None
        self.to: Optional[FlowMapRef] = None
        self.conversion_factor: Optional[float] = None

    def to_json(self) -&gt; dict:
        json: dict = super(FlowMapEntry, self).to_json()
        if self.from_ is not None:
            json[&#39;from&#39;] = self.from_.to_json()
        if self.to is not None:
            json[&#39;to&#39;] = self.to.to_json()
        if self.conversion_factor is not None:
            json[&#39;conversionFactor&#39;] = self.conversion_factor
        return json

    def from_json(self, json: dict):
        super(FlowMapEntry, self).from_json(json)
        val = json.get(&#39;from&#39;)
        if val is not None:
            self.from_ = FlowMapRef()
            self.from_.from_json(val)
        val = json.get(&#39;to&#39;)
        if val is not None:
            self.to = FlowMapRef()
            self.to.from_json(val)
        val = json.get(&#39;conversionFactor&#39;)
        if val is not None:
            self.conversion_factor = val</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.FlowMapEntry.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(FlowMapEntry, self).from_json(json)
    val = json.get(&#39;from&#39;)
    if val is not None:
        self.from_ = FlowMapRef()
        self.from_.from_json(val)
    val = json.get(&#39;to&#39;)
    if val is not None:
        self.to = FlowMapRef()
        self.to.from_json(val)
    val = json.get(&#39;conversionFactor&#39;)
    if val is not None:
        self.conversion_factor = val</code></pre>
</details>
</dd>
<dt id="olca.schema.FlowMapEntry.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(FlowMapEntry, self).to_json()
    if self.from_ is not None:
        json[&#39;from&#39;] = self.from_.to_json()
    if self.to is not None:
        json[&#39;to&#39;] = self.to.to_json()
    if self.conversion_factor is not None:
        json[&#39;conversionFactor&#39;] = self.conversion_factor
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.FlowMapRef"><code class="flex name class">
<span>class <span class="ident">FlowMapRef</span></span>
</code></dt>
<dd>
<div class="desc"><p>Describes a the source or target flow of a flow mapping in a <code><a title="olca.schema.FlowMap" href="#olca.schema.FlowMap">FlowMap</a></code>.
Such a flow reference can also optionally specify the unit and flow
property (quantity) for which the mapping is valid. If the unit and
quantity are not given, the mapping is based on the reference unit of the
reference flow property of the respective flow.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>flow</code></strong> :&ensp;<code><a title="olca.schema.FlowRef" href="#olca.schema.FlowRef">FlowRef</a></code></dt>
<dd>The reference to the flow data set.</dd>
<dt><strong><code>flow_property</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>An optional reference to a flow property of the flow for which the
mapping is valid.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>An optional reference to a unit of the flow for which the mapping is
valid</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FlowMapRef(Entity):
    &#34;&#34;&#34;
    Describes a the source or target flow of a flow mapping in a `FlowMap`.
    Such a flow reference can also optionally specify the unit and flow
    property (quantity) for which the mapping is valid. If the unit and
    quantity are not given, the mapping is based on the reference unit of the
    reference flow property of the respective flow.

    Attributes
    ----------
    flow: FlowRef
        The reference to the flow data set.

    flow_property: Ref
        An optional reference to a flow property of the flow for which the
        mapping is valid.

    unit: Ref
        An optional reference to a unit of the flow for which the mapping is
        valid

    &#34;&#34;&#34;

    def __init__(self):
        super(FlowMapRef, self).__init__()
        self.flow: Optional[FlowRef] = None
        self.flow_property: Optional[Ref] = None
        self.unit: Optional[Ref] = None

    def to_json(self) -&gt; dict:
        json: dict = super(FlowMapRef, self).to_json()
        if self.flow is not None:
            json[&#39;flow&#39;] = self.flow.to_json()
        if self.flow_property is not None:
            json[&#39;flowProperty&#39;] = self.flow_property.to_json()
        if self.unit is not None:
            json[&#39;unit&#39;] = self.unit.to_json()
        return json

    def from_json(self, json: dict):
        super(FlowMapRef, self).from_json(json)
        val = json.get(&#39;flow&#39;)
        if val is not None:
            self.flow = FlowRef()
            self.flow.from_json(val)
        val = json.get(&#39;flowProperty&#39;)
        if val is not None:
            self.flow_property = Ref()
            self.flow_property.from_json(val)
        val = json.get(&#39;unit&#39;)
        if val is not None:
            self.unit = Ref()
            self.unit.from_json(val)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.FlowMapRef.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(FlowMapRef, self).from_json(json)
    val = json.get(&#39;flow&#39;)
    if val is not None:
        self.flow = FlowRef()
        self.flow.from_json(val)
    val = json.get(&#39;flowProperty&#39;)
    if val is not None:
        self.flow_property = Ref()
        self.flow_property.from_json(val)
    val = json.get(&#39;unit&#39;)
    if val is not None:
        self.unit = Ref()
        self.unit.from_json(val)</code></pre>
</details>
</dd>
<dt id="olca.schema.FlowMapRef.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(FlowMapRef, self).to_json()
    if self.flow is not None:
        json[&#39;flow&#39;] = self.flow.to_json()
    if self.flow_property is not None:
        json[&#39;flowProperty&#39;] = self.flow_property.to_json()
    if self.unit is not None:
        json[&#39;unit&#39;] = self.unit.to_json()
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.FlowProperty"><code class="flex name class">
<span>class <span class="ident">FlowProperty</span></span>
</code></dt>
<dd>
<div class="desc"><p>A flow property is a quantity that can be used to express amounts of a
flow.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>flow_property_type</code></strong> :&ensp;<code><a title="olca.schema.FlowPropertyType" href="#olca.schema.FlowPropertyType">FlowPropertyType</a></code></dt>
<dd>The type of the flow property</dd>
<dt><strong><code>unit_group</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The units of measure that can be used to express quantities of the flow
property.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FlowProperty(CategorizedEntity):
    &#34;&#34;&#34;
    A flow property is a quantity that can be used to express amounts of a
    flow.

    Attributes
    ----------
    flow_property_type: FlowPropertyType
        The type of the flow property

    unit_group: Ref
        The units of measure that can be used to express quantities of the flow
        property.

    &#34;&#34;&#34;

    def __init__(self):
        super(FlowProperty, self).__init__()
        self.flow_property_type: Optional[FlowPropertyType] = None
        self.unit_group: Optional[Ref] = None

    def to_json(self) -&gt; dict:
        json: dict = super(FlowProperty, self).to_json()
        if self.flow_property_type is not None:
            json[&#39;flowPropertyType&#39;] = self.flow_property_type.value
        if self.unit_group is not None:
            json[&#39;unitGroup&#39;] = self.unit_group.to_json()
        return json

    def from_json(self, json: dict):
        super(FlowProperty, self).from_json(json)
        val = json.get(&#39;flowPropertyType&#39;)
        if val is not None:
            self.flow_property_type = FlowPropertyType(val)
        val = json.get(&#39;unitGroup&#39;)
        if val is not None:
            self.unit_group = Ref()
            self.unit_group.from_json(val)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.CategorizedEntity" href="#olca.schema.CategorizedEntity">CategorizedEntity</a></li>
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.FlowProperty.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(FlowProperty, self).from_json(json)
    val = json.get(&#39;flowPropertyType&#39;)
    if val is not None:
        self.flow_property_type = FlowPropertyType(val)
    val = json.get(&#39;unitGroup&#39;)
    if val is not None:
        self.unit_group = Ref()
        self.unit_group.from_json(val)</code></pre>
</details>
</dd>
<dt id="olca.schema.FlowProperty.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(FlowProperty, self).to_json()
    if self.flow_property_type is not None:
        json[&#39;flowPropertyType&#39;] = self.flow_property_type.value
    if self.unit_group is not None:
        json[&#39;unitGroup&#39;] = self.unit_group.to_json()
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.FlowPropertyFactor"><code class="flex name class">
<span>class <span class="ident">FlowPropertyFactor</span></span>
</code></dt>
<dd>
<div class="desc"><p>A FlowPropertyFactor is a conversion factor between <a
href="./FlowProperty.html">flow properties (quantities)</a> of a <a
href="./Flow.html">flow</a>. As an example the amount of the flow 'water'
in a process could be expressed in 'kg' mass or 'm3' volume. In this case
the flow water would have two flow property factors: one for the flow
property 'mass' and one for 'volume'. Each of these flow properties has a
reference to a <a href="./UnitGroup.html">unit group</a> which again has a
reference unit. In the example the flow property 'mass' could reference the
unit group 'units of mass' with 'kg' as reference unit and volume could
reference the unit group 'units of volume' with 'm3' as reference unit. The
flow property factor is now the conversion factor between these two
reference units where the factor of the reference flow property of the flow
is 1. If the reference flow property of 'water' in the example would be
'mass' the respective flow property factor would be 1 and the factor for
'volume' would be 0.001 (as 1 kg water is 0.001 m3). The amount of water in
a process can now be also given in liter, tons, grams etc. For this, the
unit conversion factor of the respective unit group can be used to convert
into the reference unit (which then can be used to convert to the reference
unit of another flow property). Another thing to note is that different
flow properties can refer to the same unit group (e.g. MJ upper calorific
value and MJ lower calorific value.)</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>flow_property</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The flow property (quantity) of the factor.</dd>
<dt><strong><code>conversion_factor</code></strong> :&ensp;<code>float</code></dt>
<dd>The value of the conversion factor.</dd>
<dt><strong><code>reference_flow_property</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates whether the flow property of the factor is the reference flow
property of the flow. The reference flow property must have a
conversion factor of 1.0 and there should be only one reference flow
property.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FlowPropertyFactor(Entity):
    &#34;&#34;&#34;
    A FlowPropertyFactor is a conversion factor between &lt;a
    href=&#34;./FlowProperty.html&#34;&gt;flow properties (quantities)&lt;/a&gt; of a &lt;a
    href=&#34;./Flow.html&#34;&gt;flow&lt;/a&gt;. As an example the amount of the flow &#39;water&#39;
    in a process could be expressed in &#39;kg&#39; mass or &#39;m3&#39; volume. In this case
    the flow water would have two flow property factors: one for the flow
    property &#39;mass&#39; and one for &#39;volume&#39;. Each of these flow properties has a
    reference to a &lt;a href=&#34;./UnitGroup.html&#34;&gt;unit group&lt;/a&gt; which again has a
    reference unit. In the example the flow property &#39;mass&#39; could reference the
    unit group &#39;units of mass&#39; with &#39;kg&#39; as reference unit and volume could
    reference the unit group &#39;units of volume&#39; with &#39;m3&#39; as reference unit. The
    flow property factor is now the conversion factor between these two
    reference units where the factor of the reference flow property of the flow
    is 1. If the reference flow property of &#39;water&#39; in the example would be
    &#39;mass&#39; the respective flow property factor would be 1 and the factor for
    &#39;volume&#39; would be 0.001 (as 1 kg water is 0.001 m3). The amount of water in
    a process can now be also given in liter, tons, grams etc. For this, the
    unit conversion factor of the respective unit group can be used to convert
    into the reference unit (which then can be used to convert to the reference
    unit of another flow property). Another thing to note is that different
    flow properties can refer to the same unit group (e.g. MJ upper calorific
    value and MJ lower calorific value.)

    Attributes
    ----------
    flow_property: Ref
        The flow property (quantity) of the factor.

    conversion_factor: float
        The value of the conversion factor.

    reference_flow_property: bool
        Indicates whether the flow property of the factor is the reference flow
        property of the flow. The reference flow property must have a
        conversion factor of 1.0 and there should be only one reference flow
        property.

    &#34;&#34;&#34;

    def __init__(self):
        super(FlowPropertyFactor, self).__init__()
        self.flow_property: Optional[Ref] = None
        self.conversion_factor: Optional[float] = None
        self.reference_flow_property: Optional[bool] = None

    def to_json(self) -&gt; dict:
        json: dict = super(FlowPropertyFactor, self).to_json()
        if self.flow_property is not None:
            json[&#39;flowProperty&#39;] = self.flow_property.to_json()
        if self.conversion_factor is not None:
            json[&#39;conversionFactor&#39;] = self.conversion_factor
        if self.reference_flow_property is not None:
            json[&#39;referenceFlowProperty&#39;] = self.reference_flow_property
        return json

    def from_json(self, json: dict):
        super(FlowPropertyFactor, self).from_json(json)
        val = json.get(&#39;flowProperty&#39;)
        if val is not None:
            self.flow_property = Ref()
            self.flow_property.from_json(val)
        val = json.get(&#39;conversionFactor&#39;)
        if val is not None:
            self.conversion_factor = val
        val = json.get(&#39;referenceFlowProperty&#39;)
        if val is not None:
            self.reference_flow_property = val</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.FlowPropertyFactor.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(FlowPropertyFactor, self).from_json(json)
    val = json.get(&#39;flowProperty&#39;)
    if val is not None:
        self.flow_property = Ref()
        self.flow_property.from_json(val)
    val = json.get(&#39;conversionFactor&#39;)
    if val is not None:
        self.conversion_factor = val
    val = json.get(&#39;referenceFlowProperty&#39;)
    if val is not None:
        self.reference_flow_property = val</code></pre>
</details>
</dd>
<dt id="olca.schema.FlowPropertyFactor.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(FlowPropertyFactor, self).to_json()
    if self.flow_property is not None:
        json[&#39;flowProperty&#39;] = self.flow_property.to_json()
    if self.conversion_factor is not None:
        json[&#39;conversionFactor&#39;] = self.conversion_factor
    if self.reference_flow_property is not None:
        json[&#39;referenceFlowProperty&#39;] = self.reference_flow_property
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.FlowPropertyType"><code class="flex name class">
<span>class <span class="ident">FlowPropertyType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration of flow property types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FlowPropertyType(Enum):
    &#34;&#34;&#34;
    An enumeration of flow property types.
    &#34;&#34;&#34;

    ECONOMIC_QUANTITY = &#39;ECONOMIC_QUANTITY&#39;
    PHYSICAL_QUANTITY = &#39;PHYSICAL_QUANTITY&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.FlowPropertyType.ECONOMIC_QUANTITY"><code class="name">var <span class="ident">ECONOMIC_QUANTITY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.FlowPropertyType.PHYSICAL_QUANTITY"><code class="name">var <span class="ident">PHYSICAL_QUANTITY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="olca.schema.FlowRef"><code class="flex name class">
<span>class <span class="ident">FlowRef</span></span>
</code></dt>
<dd>
<div class="desc"><p>A reference to a [Flow] data set.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>ref_unit</code></strong> :&ensp;<code>str</code></dt>
<dd>The name (symbol) of the reference unit of the flow.</dd>
<dt><strong><code>location</code></strong> :&ensp;<code>str</code></dt>
<dd>The location name or code of the flow. Typically, this is only used for
product flows in databases like ecoinvent.</dd>
<dt><strong><code>flow_type</code></strong> :&ensp;<code><a title="olca.schema.FlowType" href="#olca.schema.FlowType">FlowType</a></code></dt>
<dd>The type of the flow.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FlowRef(Ref):
    &#34;&#34;&#34;
    A reference to a [Flow] data set.

    Attributes
    ----------
    ref_unit: str
        The name (symbol) of the reference unit of the flow.

    location: str
        The location name or code of the flow. Typically, this is only used for
        product flows in databases like ecoinvent.

    flow_type: FlowType
        The type of the flow.

    &#34;&#34;&#34;

    def __init__(self):
        super(FlowRef, self).__init__()
        self.ref_unit: Optional[str] = None
        self.location: Optional[str] = None
        self.flow_type: Optional[FlowType] = None

    def to_json(self) -&gt; dict:
        json: dict = super(FlowRef, self).to_json()
        if self.ref_unit is not None:
            json[&#39;refUnit&#39;] = self.ref_unit
        if self.location is not None:
            json[&#39;location&#39;] = self.location
        if self.flow_type is not None:
            json[&#39;flowType&#39;] = self.flow_type.value
        return json

    def from_json(self, json: dict):
        super(FlowRef, self).from_json(json)
        val = json.get(&#39;refUnit&#39;)
        if val is not None:
            self.ref_unit = val
        val = json.get(&#39;location&#39;)
        if val is not None:
            self.location = val
        val = json.get(&#39;flowType&#39;)
        if val is not None:
            self.flow_type = FlowType(val)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></li>
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.FlowRef.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(FlowRef, self).from_json(json)
    val = json.get(&#39;refUnit&#39;)
    if val is not None:
        self.ref_unit = val
    val = json.get(&#39;location&#39;)
    if val is not None:
        self.location = val
    val = json.get(&#39;flowType&#39;)
    if val is not None:
        self.flow_type = FlowType(val)</code></pre>
</details>
</dd>
<dt id="olca.schema.FlowRef.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(FlowRef, self).to_json()
    if self.ref_unit is not None:
        json[&#39;refUnit&#39;] = self.ref_unit
    if self.location is not None:
        json[&#39;location&#39;] = self.location
    if self.flow_type is not None:
        json[&#39;flowType&#39;] = self.flow_type.value
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.FlowResult"><code class="flex name class">
<span>class <span class="ident">FlowResult</span></span>
</code></dt>
<dd>
<div class="desc"><p>A result value for a flow; given in the reference unit of the flow.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>flow</code></strong> :&ensp;<code><a title="olca.schema.FlowRef" href="#olca.schema.FlowRef">FlowRef</a></code></dt>
<dd>The flow reference.</dd>
<dt><strong><code>input</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates whether the flow is an input or not.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value of the flow amount.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FlowResult(Entity):
    &#34;&#34;&#34;
    A result value for a flow; given in the reference unit of the flow.

    Attributes
    ----------
    flow: FlowRef
        The flow reference.

    input: bool
        Indicates whether the flow is an input or not.

    value: float
        The value of the flow amount.

    &#34;&#34;&#34;

    def __init__(self):
        super(FlowResult, self).__init__()
        self.flow: Optional[FlowRef] = None
        self.input: Optional[bool] = None
        self.value: Optional[float] = None

    def to_json(self) -&gt; dict:
        json: dict = super(FlowResult, self).to_json()
        if self.flow is not None:
            json[&#39;flow&#39;] = self.flow.to_json()
        if self.input is not None:
            json[&#39;input&#39;] = self.input
        if self.value is not None:
            json[&#39;value&#39;] = self.value
        return json

    def from_json(self, json: dict):
        super(FlowResult, self).from_json(json)
        val = json.get(&#39;flow&#39;)
        if val is not None:
            self.flow = FlowRef()
            self.flow.from_json(val)
        val = json.get(&#39;input&#39;)
        if val is not None:
            self.input = val
        val = json.get(&#39;value&#39;)
        if val is not None:
            self.value = val</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.FlowResult.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(FlowResult, self).from_json(json)
    val = json.get(&#39;flow&#39;)
    if val is not None:
        self.flow = FlowRef()
        self.flow.from_json(val)
    val = json.get(&#39;input&#39;)
    if val is not None:
        self.input = val
    val = json.get(&#39;value&#39;)
    if val is not None:
        self.value = val</code></pre>
</details>
</dd>
<dt id="olca.schema.FlowResult.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(FlowResult, self).to_json()
    if self.flow is not None:
        json[&#39;flow&#39;] = self.flow.to_json()
    if self.input is not None:
        json[&#39;input&#39;] = self.input
    if self.value is not None:
        json[&#39;value&#39;] = self.value
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.FlowType"><code class="flex name class">
<span>class <span class="ident">FlowType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>The basic flow types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FlowType(Enum):
    &#34;&#34;&#34;
    The basic flow types.
    &#34;&#34;&#34;

    ELEMENTARY_FLOW = &#39;ELEMENTARY_FLOW&#39;
    PRODUCT_FLOW = &#39;PRODUCT_FLOW&#39;
    WASTE_FLOW = &#39;WASTE_FLOW&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.FlowType.ELEMENTARY_FLOW"><code class="name">var <span class="ident">ELEMENTARY_FLOW</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.FlowType.PRODUCT_FLOW"><code class="name">var <span class="ident">PRODUCT_FLOW</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.FlowType.WASTE_FLOW"><code class="name">var <span class="ident">WASTE_FLOW</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="olca.schema.ImpactCategory"><code class="flex name class">
<span>class <span class="ident">ImpactCategory</span></span>
</code></dt>
<dd>
<div class="desc"><p>A LCIA category of a LCIA method (see ImpactMethod) which groups a set of
characterisation factors</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>reference_unit_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the reference unit of the LCIA category (e.g. kg CO2-eq.).</dd>
<dt><strong><code>impact_factors</code></strong> :&ensp;<code>List[<a title="olca.schema.ImpactFactor" href="#olca.schema.ImpactFactor">ImpactFactor</a>]</code></dt>
<dd>The characterisation factors of the LCIA category.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ImpactCategory(RootEntity):
    &#34;&#34;&#34;
    A LCIA category of a LCIA method (see ImpactMethod) which groups a set of
    characterisation factors

    Attributes
    ----------
    reference_unit_name: str
        The name of the reference unit of the LCIA category (e.g. kg CO2-eq.).

    impact_factors: List[ImpactFactor]
        The characterisation factors of the LCIA category.

    &#34;&#34;&#34;

    def __init__(self):
        super(ImpactCategory, self).__init__()
        self.reference_unit_name: Optional[str] = None
        self.impact_factors: Optional[List[ImpactFactor]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ImpactCategory, self).to_json()
        if self.reference_unit_name is not None:
            json[&#39;referenceUnitName&#39;] = self.reference_unit_name
        if self.impact_factors is not None:
            json[&#39;impactFactors&#39;] = []
            for e in self.impact_factors:
                json[&#39;impactFactors&#39;].append(e.to_json())
        return json

    def from_json(self, json: dict):
        super(ImpactCategory, self).from_json(json)
        val = json.get(&#39;referenceUnitName&#39;)
        if val is not None:
            self.reference_unit_name = val
        val = json.get(&#39;impactFactors&#39;)
        if val is not None:
            self.impact_factors = []
            for d in val:
                e = ImpactFactor()
                e.from_json(d)
                self.impact_factors.append(e)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.ImpactCategory.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(ImpactCategory, self).from_json(json)
    val = json.get(&#39;referenceUnitName&#39;)
    if val is not None:
        self.reference_unit_name = val
    val = json.get(&#39;impactFactors&#39;)
    if val is not None:
        self.impact_factors = []
        for d in val:
            e = ImpactFactor()
            e.from_json(d)
            self.impact_factors.append(e)</code></pre>
</details>
</dd>
<dt id="olca.schema.ImpactCategory.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(ImpactCategory, self).to_json()
    if self.reference_unit_name is not None:
        json[&#39;referenceUnitName&#39;] = self.reference_unit_name
    if self.impact_factors is not None:
        json[&#39;impactFactors&#39;] = []
        for e in self.impact_factors:
            json[&#39;impactFactors&#39;].append(e.to_json())
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.ImpactCategoryRef"><code class="flex name class">
<span>class <span class="ident">ImpactCategoryRef</span></span>
</code></dt>
<dd>
<div class="desc"><p>A reference to a [ImpactCategory] data set.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>ref_unit</code></strong> :&ensp;<code>str</code></dt>
<dd>The name (symbol) of the reference unit of the impact category.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ImpactCategoryRef(Ref):
    &#34;&#34;&#34;
    A reference to a [ImpactCategory] data set.

    Attributes
    ----------
    ref_unit: str
        The name (symbol) of the reference unit of the impact category.

    &#34;&#34;&#34;

    def __init__(self):
        super(ImpactCategoryRef, self).__init__()
        self.ref_unit: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ImpactCategoryRef, self).to_json()
        if self.ref_unit is not None:
            json[&#39;refUnit&#39;] = self.ref_unit
        return json

    def from_json(self, json: dict):
        super(ImpactCategoryRef, self).from_json(json)
        val = json.get(&#39;refUnit&#39;)
        if val is not None:
            self.ref_unit = val</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></li>
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.ImpactCategoryRef.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(ImpactCategoryRef, self).from_json(json)
    val = json.get(&#39;refUnit&#39;)
    if val is not None:
        self.ref_unit = val</code></pre>
</details>
</dd>
<dt id="olca.schema.ImpactCategoryRef.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(ImpactCategoryRef, self).to_json()
    if self.ref_unit is not None:
        json[&#39;refUnit&#39;] = self.ref_unit
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.ImpactFactor"><code class="flex name class">
<span>class <span class="ident">ImpactFactor</span></span>
</code></dt>
<dd>
<div class="desc"><p>A single characterisation factor of a LCIA category for a flow.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>flow</code></strong> :&ensp;<code><a title="olca.schema.FlowRef" href="#olca.schema.FlowRef">FlowRef</a></code></dt>
<dd>The [Flow] of the impact assessment factor.</dd>
<dt><strong><code>flow_property</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The quantity of the flow to which the LCIA factor is related (e.g.
Mass).</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The flow unit to which the LCIA factor is related (e.g. kg).</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value of the impact assessment factor.</dd>
<dt><strong><code>formula</code></strong> :&ensp;<code>str</code></dt>
<dd>A mathematical formula for calculating the value of the LCIA factor.</dd>
<dt><strong><code>uncertainty</code></strong> :&ensp;<code><a title="olca.schema.Uncertainty" href="#olca.schema.Uncertainty">Uncertainty</a></code></dt>
<dd>The uncertainty distribution of the factors' value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ImpactFactor(Entity):
    &#34;&#34;&#34;
    A single characterisation factor of a LCIA category for a flow.

    Attributes
    ----------
    flow: FlowRef
        The [Flow] of the impact assessment factor.

    flow_property: Ref
        The quantity of the flow to which the LCIA factor is related (e.g.
        Mass).

    unit: Ref
        The flow unit to which the LCIA factor is related (e.g. kg).

    value: float
        The value of the impact assessment factor.

    formula: str
        A mathematical formula for calculating the value of the LCIA factor.

    uncertainty: Uncertainty
        The uncertainty distribution of the factors&#39; value.

    &#34;&#34;&#34;

    def __init__(self):
        super(ImpactFactor, self).__init__()
        self.flow: Optional[FlowRef] = None
        self.flow_property: Optional[Ref] = None
        self.unit: Optional[Ref] = None
        self.value: Optional[float] = None
        self.formula: Optional[str] = None
        self.uncertainty: Optional[Uncertainty] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ImpactFactor, self).to_json()
        if self.flow is not None:
            json[&#39;flow&#39;] = self.flow.to_json()
        if self.flow_property is not None:
            json[&#39;flowProperty&#39;] = self.flow_property.to_json()
        if self.unit is not None:
            json[&#39;unit&#39;] = self.unit.to_json()
        if self.value is not None:
            json[&#39;value&#39;] = self.value
        if self.formula is not None:
            json[&#39;formula&#39;] = self.formula
        if self.uncertainty is not None:
            json[&#39;uncertainty&#39;] = self.uncertainty.to_json()
        return json

    def from_json(self, json: dict):
        super(ImpactFactor, self).from_json(json)
        val = json.get(&#39;flow&#39;)
        if val is not None:
            self.flow = FlowRef()
            self.flow.from_json(val)
        val = json.get(&#39;flowProperty&#39;)
        if val is not None:
            self.flow_property = Ref()
            self.flow_property.from_json(val)
        val = json.get(&#39;unit&#39;)
        if val is not None:
            self.unit = Ref()
            self.unit.from_json(val)
        val = json.get(&#39;value&#39;)
        if val is not None:
            self.value = val
        val = json.get(&#39;formula&#39;)
        if val is not None:
            self.formula = val
        val = json.get(&#39;uncertainty&#39;)
        if val is not None:
            self.uncertainty = Uncertainty()
            self.uncertainty.from_json(val)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.ImpactFactor.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(ImpactFactor, self).from_json(json)
    val = json.get(&#39;flow&#39;)
    if val is not None:
        self.flow = FlowRef()
        self.flow.from_json(val)
    val = json.get(&#39;flowProperty&#39;)
    if val is not None:
        self.flow_property = Ref()
        self.flow_property.from_json(val)
    val = json.get(&#39;unit&#39;)
    if val is not None:
        self.unit = Ref()
        self.unit.from_json(val)
    val = json.get(&#39;value&#39;)
    if val is not None:
        self.value = val
    val = json.get(&#39;formula&#39;)
    if val is not None:
        self.formula = val
    val = json.get(&#39;uncertainty&#39;)
    if val is not None:
        self.uncertainty = Uncertainty()
        self.uncertainty.from_json(val)</code></pre>
</details>
</dd>
<dt id="olca.schema.ImpactFactor.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(ImpactFactor, self).to_json()
    if self.flow is not None:
        json[&#39;flow&#39;] = self.flow.to_json()
    if self.flow_property is not None:
        json[&#39;flowProperty&#39;] = self.flow_property.to_json()
    if self.unit is not None:
        json[&#39;unit&#39;] = self.unit.to_json()
    if self.value is not None:
        json[&#39;value&#39;] = self.value
    if self.formula is not None:
        json[&#39;formula&#39;] = self.formula
    if self.uncertainty is not None:
        json[&#39;uncertainty&#39;] = self.uncertainty.to_json()
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.ImpactMethod"><code class="flex name class">
<span>class <span class="ident">ImpactMethod</span></span>
</code></dt>
<dd>
<div class="desc"><p>A impact assessment method.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>impact_categories</code></strong> :&ensp;<code>List[<a title="olca.schema.ImpactCategoryRef" href="#olca.schema.ImpactCategoryRef">ImpactCategoryRef</a>]</code></dt>
<dd>The LCIA categories of the method.</dd>
<dt><strong><code>parameters</code></strong> :&ensp;<code>List[<a title="olca.schema.Parameter" href="#olca.schema.Parameter">Parameter</a>]</code></dt>
<dd>A set of method specific parameters which can be used in formulas of
the characterisation factors in this method.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ImpactMethod(CategorizedEntity):
    &#34;&#34;&#34;
    A impact assessment method.

    Attributes
    ----------
    impact_categories: List[ImpactCategoryRef]
        The LCIA categories of the method.

    parameters: List[Parameter]
        A set of method specific parameters which can be used in formulas of
        the characterisation factors in this method.

    &#34;&#34;&#34;

    def __init__(self):
        super(ImpactMethod, self).__init__()
        self.impact_categories: Optional[List[ImpactCategoryRef]] = None
        self.parameters: Optional[List[Parameter]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ImpactMethod, self).to_json()
        if self.impact_categories is not None:
            json[&#39;impactCategories&#39;] = []
            for e in self.impact_categories:
                json[&#39;impactCategories&#39;].append(e.to_json())
        if self.parameters is not None:
            json[&#39;parameters&#39;] = []
            for e in self.parameters:
                json[&#39;parameters&#39;].append(e.to_json())
        return json

    def from_json(self, json: dict):
        super(ImpactMethod, self).from_json(json)
        val = json.get(&#39;impactCategories&#39;)
        if val is not None:
            self.impact_categories = []
            for d in val:
                e = ImpactCategoryRef()
                e.from_json(d)
                self.impact_categories.append(e)
        val = json.get(&#39;parameters&#39;)
        if val is not None:
            self.parameters = []
            for d in val:
                e = Parameter()
                e.from_json(d)
                self.parameters.append(e)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.CategorizedEntity" href="#olca.schema.CategorizedEntity">CategorizedEntity</a></li>
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.ImpactMethod.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(ImpactMethod, self).from_json(json)
    val = json.get(&#39;impactCategories&#39;)
    if val is not None:
        self.impact_categories = []
        for d in val:
            e = ImpactCategoryRef()
            e.from_json(d)
            self.impact_categories.append(e)
    val = json.get(&#39;parameters&#39;)
    if val is not None:
        self.parameters = []
        for d in val:
            e = Parameter()
            e.from_json(d)
            self.parameters.append(e)</code></pre>
</details>
</dd>
<dt id="olca.schema.ImpactMethod.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(ImpactMethod, self).to_json()
    if self.impact_categories is not None:
        json[&#39;impactCategories&#39;] = []
        for e in self.impact_categories:
            json[&#39;impactCategories&#39;].append(e.to_json())
    if self.parameters is not None:
        json[&#39;parameters&#39;] = []
        for e in self.parameters:
            json[&#39;parameters&#39;].append(e.to_json())
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.ImpactResult"><code class="flex name class">
<span>class <span class="ident">ImpactResult</span></span>
</code></dt>
<dd>
<div class="desc"><p>A result value for an impact assessment category.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>impact_category</code></strong> :&ensp;<code><a title="olca.schema.ImpactCategoryRef" href="#olca.schema.ImpactCategoryRef">ImpactCategoryRef</a></code></dt>
<dd>The reference to the impact assessment category.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value of the flow amount.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ImpactResult(Entity):
    &#34;&#34;&#34;
    A result value for an impact assessment category.

    Attributes
    ----------
    impact_category: ImpactCategoryRef
        The reference to the impact assessment category.

    value: float
        The value of the flow amount.

    &#34;&#34;&#34;

    def __init__(self):
        super(ImpactResult, self).__init__()
        self.impact_category: Optional[ImpactCategoryRef] = None
        self.value: Optional[float] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ImpactResult, self).to_json()
        if self.impact_category is not None:
            json[&#39;impactCategory&#39;] = self.impact_category.to_json()
        if self.value is not None:
            json[&#39;value&#39;] = self.value
        return json

    def from_json(self, json: dict):
        super(ImpactResult, self).from_json(json)
        val = json.get(&#39;impactCategory&#39;)
        if val is not None:
            self.impact_category = ImpactCategoryRef()
            self.impact_category.from_json(val)
        val = json.get(&#39;value&#39;)
        if val is not None:
            self.value = val</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.ImpactResult.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(ImpactResult, self).from_json(json)
    val = json.get(&#39;impactCategory&#39;)
    if val is not None:
        self.impact_category = ImpactCategoryRef()
        self.impact_category.from_json(val)
    val = json.get(&#39;value&#39;)
    if val is not None:
        self.value = val</code></pre>
</details>
</dd>
<dt id="olca.schema.ImpactResult.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(ImpactResult, self).to_json()
    if self.impact_category is not None:
        json[&#39;impactCategory&#39;] = self.impact_category.to_json()
    if self.value is not None:
        json[&#39;value&#39;] = self.value
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.Location"><code class="flex name class">
<span>class <span class="ident">Location</span></span>
</code></dt>
<dd>
<div class="desc"><p>A location like a country, state, city, etc.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>code</code></strong> :&ensp;<code>str</code></dt>
<dd>The code of the location (e.g. an ISO 2-letter country code).</dd>
<dt><strong><code>latitude</code></strong> :&ensp;<code>float</code></dt>
<dd>The average latitude of the location.</dd>
<dt><strong><code>longitude</code></strong> :&ensp;<code>float</code></dt>
<dd>The average longitude of the location.</dd>
<dt><strong><code>kml</code></strong> :&ensp;<code>str</code></dt>
<dd>KML data of the location.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Location(RootEntity):
    &#34;&#34;&#34;
    A location like a country, state, city, etc.

    Attributes
    ----------
    code: str
        The code of the location (e.g. an ISO 2-letter country code).

    latitude: float
        The average latitude of the location.

    longitude: float
        The average longitude of the location.

    kml: str
        KML data of the location.

    &#34;&#34;&#34;

    def __init__(self):
        super(Location, self).__init__()
        self.code: Optional[str] = None
        self.latitude: Optional[float] = None
        self.longitude: Optional[float] = None
        self.kml: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Location, self).to_json()
        if self.code is not None:
            json[&#39;code&#39;] = self.code
        if self.latitude is not None:
            json[&#39;latitude&#39;] = self.latitude
        if self.longitude is not None:
            json[&#39;longitude&#39;] = self.longitude
        if self.kml is not None:
            json[&#39;kml&#39;] = self.kml
        return json

    def from_json(self, json: dict):
        super(Location, self).from_json(json)
        val = json.get(&#39;code&#39;)
        if val is not None:
            self.code = val
        val = json.get(&#39;latitude&#39;)
        if val is not None:
            self.latitude = val
        val = json.get(&#39;longitude&#39;)
        if val is not None:
            self.longitude = val
        val = json.get(&#39;kml&#39;)
        if val is not None:
            self.kml = val</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.Location.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(Location, self).from_json(json)
    val = json.get(&#39;code&#39;)
    if val is not None:
        self.code = val
    val = json.get(&#39;latitude&#39;)
    if val is not None:
        self.latitude = val
    val = json.get(&#39;longitude&#39;)
    if val is not None:
        self.longitude = val
    val = json.get(&#39;kml&#39;)
    if val is not None:
        self.kml = val</code></pre>
</details>
</dd>
<dt id="olca.schema.Location.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(Location, self).to_json()
    if self.code is not None:
        json[&#39;code&#39;] = self.code
    if self.latitude is not None:
        json[&#39;latitude&#39;] = self.latitude
    if self.longitude is not None:
        json[&#39;longitude&#39;] = self.longitude
    if self.kml is not None:
        json[&#39;kml&#39;] = self.kml
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.ModelType"><code class="flex name class">
<span>class <span class="ident">ModelType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration of the root entity types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ModelType(Enum):
    &#34;&#34;&#34;
    An enumeration of the root entity types.
    &#34;&#34;&#34;

    PROJECT = &#39;PROJECT&#39;
    IMPACT_METHOD = &#39;IMPACT_METHOD&#39;
    IMPACT_CATEGORY = &#39;IMPACT_CATEGORY&#39;
    PRODUCT_SYSTEM = &#39;PRODUCT_SYSTEM&#39;
    PROCESS = &#39;PROCESS&#39;
    FLOW = &#39;FLOW&#39;
    FLOW_PROPERTY = &#39;FLOW_PROPERTY&#39;
    UNIT_GROUP = &#39;UNIT_GROUP&#39;
    UNIT = &#39;UNIT&#39;
    ACTOR = &#39;ACTOR&#39;
    SOURCE = &#39;SOURCE&#39;
    CATEGORY = &#39;CATEGORY&#39;
    LOCATION = &#39;LOCATION&#39;
    NW_SET = &#39;NW_SET&#39;
    SOCIAL_INDICATOR = &#39;SOCIAL_INDICATOR&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.ModelType.ACTOR"><code class="name">var <span class="ident">ACTOR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ModelType.CATEGORY"><code class="name">var <span class="ident">CATEGORY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ModelType.FLOW"><code class="name">var <span class="ident">FLOW</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ModelType.FLOW_PROPERTY"><code class="name">var <span class="ident">FLOW_PROPERTY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ModelType.IMPACT_CATEGORY"><code class="name">var <span class="ident">IMPACT_CATEGORY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ModelType.IMPACT_METHOD"><code class="name">var <span class="ident">IMPACT_METHOD</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ModelType.LOCATION"><code class="name">var <span class="ident">LOCATION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ModelType.NW_SET"><code class="name">var <span class="ident">NW_SET</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ModelType.PROCESS"><code class="name">var <span class="ident">PROCESS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ModelType.PRODUCT_SYSTEM"><code class="name">var <span class="ident">PRODUCT_SYSTEM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ModelType.PROJECT"><code class="name">var <span class="ident">PROJECT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ModelType.SOCIAL_INDICATOR"><code class="name">var <span class="ident">SOCIAL_INDICATOR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ModelType.SOURCE"><code class="name">var <span class="ident">SOURCE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ModelType.UNIT"><code class="name">var <span class="ident">UNIT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ModelType.UNIT_GROUP"><code class="name">var <span class="ident">UNIT_GROUP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="olca.schema.Parameter"><code class="flex name class">
<span>class <span class="ident">Parameter</span></span>
</code></dt>
<dd>
<div class="desc"><h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the parameter.</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code></dt>
<dd>A description of the parameter.</dd>
<dt><strong><code>parameter_scope</code></strong> :&ensp;<code><a title="olca.schema.ParameterScope" href="#olca.schema.ParameterScope">ParameterScope</a></code></dt>
<dd>The scope where the parameter is valid.</dd>
<dt><strong><code>input_parameter</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates whether the parameter is an input parameter (true) or a
dependent/calculated parameter (false). A parameter can have a formula
if it is not an input parameter.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The parameter value.</dd>
<dt><strong><code>formula</code></strong> :&ensp;<code>str</code></dt>
<dd>A mathematical expression to calculate the parameter value.</dd>
<dt><strong><code>external_source</code></strong> :&ensp;<code>str</code></dt>
<dd>A reference to an external source where the parameter is defined (e.g.
an Excel table, shapefile, etc.).</dd>
<dt><strong><code>source_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Indicates the type of the source if an external source is defined for
the parameter.</dd>
<dt><strong><code>uncertainty</code></strong> :&ensp;<code><a title="olca.schema.Uncertainty" href="#olca.schema.Uncertainty">Uncertainty</a></code></dt>
<dd>An uncertainty distribution of the parameter value. This is only valid
for input parameters.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Parameter(Entity):
    &#34;&#34;&#34;


    Attributes
    ----------
    name: str
        The name of the parameter.

    description: str
        A description of the parameter.

    parameter_scope: ParameterScope
        The scope where the parameter is valid.

    input_parameter: bool
        Indicates whether the parameter is an input parameter (true) or a
        dependent/calculated parameter (false). A parameter can have a formula
        if it is not an input parameter.

    value: float
        The parameter value.

    formula: str
        A mathematical expression to calculate the parameter value.

    external_source: str
        A reference to an external source where the parameter is defined (e.g.
        an Excel table, shapefile, etc.).

    source_type: str
        Indicates the type of the source if an external source is defined for
        the parameter.

    uncertainty: Uncertainty
        An uncertainty distribution of the parameter value. This is only valid
        for input parameters.

    &#34;&#34;&#34;

    def __init__(self):
        super(Parameter, self).__init__()
        self.name: Optional[str] = None
        self.description: Optional[str] = None
        self.parameter_scope: Optional[ParameterScope] = None
        self.input_parameter: Optional[bool] = None
        self.value: Optional[float] = None
        self.formula: Optional[str] = None
        self.external_source: Optional[str] = None
        self.source_type: Optional[str] = None
        self.uncertainty: Optional[Uncertainty] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Parameter, self).to_json()
        if self.name is not None:
            json[&#39;name&#39;] = self.name
        if self.description is not None:
            json[&#39;description&#39;] = self.description
        if self.parameter_scope is not None:
            json[&#39;parameterScope&#39;] = self.parameter_scope.value
        if self.input_parameter is not None:
            json[&#39;inputParameter&#39;] = self.input_parameter
        if self.value is not None:
            json[&#39;value&#39;] = self.value
        if self.formula is not None:
            json[&#39;formula&#39;] = self.formula
        if self.external_source is not None:
            json[&#39;externalSource&#39;] = self.external_source
        if self.source_type is not None:
            json[&#39;sourceType&#39;] = self.source_type
        if self.uncertainty is not None:
            json[&#39;uncertainty&#39;] = self.uncertainty.to_json()
        return json

    def from_json(self, json: dict):
        super(Parameter, self).from_json(json)
        val = json.get(&#39;name&#39;)
        if val is not None:
            self.name = val
        val = json.get(&#39;description&#39;)
        if val is not None:
            self.description = val
        val = json.get(&#39;parameterScope&#39;)
        if val is not None:
            self.parameter_scope = ParameterScope(val)
        val = json.get(&#39;inputParameter&#39;)
        if val is not None:
            self.input_parameter = val
        val = json.get(&#39;value&#39;)
        if val is not None:
            self.value = val
        val = json.get(&#39;formula&#39;)
        if val is not None:
            self.formula = val
        val = json.get(&#39;externalSource&#39;)
        if val is not None:
            self.external_source = val
        val = json.get(&#39;sourceType&#39;)
        if val is not None:
            self.source_type = val
        val = json.get(&#39;uncertainty&#39;)
        if val is not None:
            self.uncertainty = Uncertainty()
            self.uncertainty.from_json(val)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.Parameter.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(Parameter, self).from_json(json)
    val = json.get(&#39;name&#39;)
    if val is not None:
        self.name = val
    val = json.get(&#39;description&#39;)
    if val is not None:
        self.description = val
    val = json.get(&#39;parameterScope&#39;)
    if val is not None:
        self.parameter_scope = ParameterScope(val)
    val = json.get(&#39;inputParameter&#39;)
    if val is not None:
        self.input_parameter = val
    val = json.get(&#39;value&#39;)
    if val is not None:
        self.value = val
    val = json.get(&#39;formula&#39;)
    if val is not None:
        self.formula = val
    val = json.get(&#39;externalSource&#39;)
    if val is not None:
        self.external_source = val
    val = json.get(&#39;sourceType&#39;)
    if val is not None:
        self.source_type = val
    val = json.get(&#39;uncertainty&#39;)
    if val is not None:
        self.uncertainty = Uncertainty()
        self.uncertainty.from_json(val)</code></pre>
</details>
</dd>
<dt id="olca.schema.Parameter.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(Parameter, self).to_json()
    if self.name is not None:
        json[&#39;name&#39;] = self.name
    if self.description is not None:
        json[&#39;description&#39;] = self.description
    if self.parameter_scope is not None:
        json[&#39;parameterScope&#39;] = self.parameter_scope.value
    if self.input_parameter is not None:
        json[&#39;inputParameter&#39;] = self.input_parameter
    if self.value is not None:
        json[&#39;value&#39;] = self.value
    if self.formula is not None:
        json[&#39;formula&#39;] = self.formula
    if self.external_source is not None:
        json[&#39;externalSource&#39;] = self.external_source
    if self.source_type is not None:
        json[&#39;sourceType&#39;] = self.source_type
    if self.uncertainty is not None:
        json[&#39;uncertainty&#39;] = self.uncertainty.to_json()
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.ParameterRedef"><code class="flex name class">
<span>class <span class="ident">ParameterRedef</span></span>
</code></dt>
<dd>
<div class="desc"><p>A redefinition of a parameter in a product system.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The parameter name.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The (new) value of the parameter.</dd>
<dt><strong><code>context</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The context of the paramater (a process or LCIA method). If no context
is provided it is assumed that this is a redefinition of a global
parameter.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParameterRedef(Entity):
    &#34;&#34;&#34;
    A redefinition of a parameter in a product system.

    Attributes
    ----------
    name: str
        The parameter name.

    value: float
        The (new) value of the parameter.

    context: Ref
        The context of the paramater (a process or LCIA method). If no context
        is provided it is assumed that this is a redefinition of a global
        parameter.

    &#34;&#34;&#34;

    def __init__(self):
        super(ParameterRedef, self).__init__()
        self.name: Optional[str] = None
        self.value: Optional[float] = None
        self.context: Optional[Ref] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ParameterRedef, self).to_json()
        if self.name is not None:
            json[&#39;name&#39;] = self.name
        if self.value is not None:
            json[&#39;value&#39;] = self.value
        if self.context is not None:
            json[&#39;context&#39;] = self.context.to_json()
        return json

    def from_json(self, json: dict):
        super(ParameterRedef, self).from_json(json)
        val = json.get(&#39;name&#39;)
        if val is not None:
            self.name = val
        val = json.get(&#39;value&#39;)
        if val is not None:
            self.value = val
        val = json.get(&#39;context&#39;)
        if val is not None:
            self.context = Ref()
            self.context.from_json(val)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.ParameterRedef.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(ParameterRedef, self).from_json(json)
    val = json.get(&#39;name&#39;)
    if val is not None:
        self.name = val
    val = json.get(&#39;value&#39;)
    if val is not None:
        self.value = val
    val = json.get(&#39;context&#39;)
    if val is not None:
        self.context = Ref()
        self.context.from_json(val)</code></pre>
</details>
</dd>
<dt id="olca.schema.ParameterRedef.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(ParameterRedef, self).to_json()
    if self.name is not None:
        json[&#39;name&#39;] = self.name
    if self.value is not None:
        json[&#39;value&#39;] = self.value
    if self.context is not None:
        json[&#39;context&#39;] = self.context.to_json()
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.ParameterScope"><code class="flex name class">
<span>class <span class="ident">ParameterScope</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>The possible scopes of parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParameterScope(Enum):
    &#34;&#34;&#34;
    The possible scopes of parameters.
    &#34;&#34;&#34;

    PROCESS_SCOPE = &#39;PROCESS_SCOPE&#39;
    LCIA_METHOD_SCOPE = &#39;LCIA_METHOD_SCOPE&#39;
    GLOBAL_SCOPE = &#39;GLOBAL_SCOPE&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.ParameterScope.GLOBAL_SCOPE"><code class="name">var <span class="ident">GLOBAL_SCOPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ParameterScope.LCIA_METHOD_SCOPE"><code class="name">var <span class="ident">LCIA_METHOD_SCOPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ParameterScope.PROCESS_SCOPE"><code class="name">var <span class="ident">PROCESS_SCOPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="olca.schema.Process"><code class="flex name class">
<span>class <span class="ident">Process</span></span>
</code></dt>
<dd>
<div class="desc"><h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>default_allocation_method</code></strong> :&ensp;<code><a title="olca.schema.AllocationType" href="#olca.schema.AllocationType">AllocationType</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>allocation_factors</code></strong> :&ensp;<code>List[<a title="olca.schema.AllocationFactor" href="#olca.schema.AllocationFactor">AllocationFactor</a>]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>exchanges</code></strong> :&ensp;<code>List[<a title="olca.schema.Exchange" href="#olca.schema.Exchange">Exchange</a>]</code></dt>
<dd>The inputs and outputs of the process.</dd>
<dt><strong><code>location</code></strong> :&ensp;<code><a title="olca.schema.Location" href="#olca.schema.Location">Location</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>parameters</code></strong> :&ensp;<code>List[<a title="olca.schema.Parameter" href="#olca.schema.Parameter">Parameter</a>]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>process_documentation</code></strong> :&ensp;<code><a title="olca.schema.ProcessDocumentation" href="#olca.schema.ProcessDocumentation">ProcessDocumentation</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>process_type</code></strong> :&ensp;<code><a title="olca.schema.ProcessType" href="#olca.schema.ProcessType">ProcessType</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>dq_system</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>A reference to a data quality system ([DqSystem]) with which the
overall quality of the process can be assessed.</dd>
<dt><strong><code>exchange_dq_system</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>A reference to a data quality system ([DqSystem]) with which the
quality of individual inputs and outputs ([Exchange]s) of the process
can be assessed.</dd>
<dt><strong><code>social_dq_system</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>A reference to a data quality system ([DqSystem]) with which the
quality of individual social aspects of the process can be assessed.</dd>
<dt><strong><code>dq_entry</code></strong> :&ensp;<code>str</code></dt>
<dd>A data quality entry like <code>(1;3;2;5;1)</code>. The entry is a vector of data
quality values that need to match the overall data quality system of
the process (the system that is stored in the <code>dqSystem</code> property). In
such a system the data quality indicators have fixed positions and the
respective values in the <code>dqEntry</code> vector map to these positions.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Process(CategorizedEntity):
    &#34;&#34;&#34;


    Attributes
    ----------
    default_allocation_method: AllocationType

    allocation_factors: List[AllocationFactor]

    exchanges: List[Exchange]
        The inputs and outputs of the process.

    location: Location

    parameters: List[Parameter]

    process_documentation: ProcessDocumentation

    process_type: ProcessType

    dq_system: Ref
        A reference to a data quality system ([DqSystem]) with which the
        overall quality of the process can be assessed.

    exchange_dq_system: Ref
        A reference to a data quality system ([DqSystem]) with which the
        quality of individual inputs and outputs ([Exchange]s) of the process
        can be assessed.

    social_dq_system: Ref
        A reference to a data quality system ([DqSystem]) with which the
        quality of individual social aspects of the process can be assessed.

    dq_entry: str
        A data quality entry like `(1;3;2;5;1)`. The entry is a vector of data
        quality values that need to match the overall data quality system of
        the process (the system that is stored in the `dqSystem` property). In
        such a system the data quality indicators have fixed positions and the
        respective values in the `dqEntry` vector map to these positions.

    &#34;&#34;&#34;

    def __init__(self):
        super(Process, self).__init__()
        self.default_allocation_method: Optional[AllocationType] = None
        self.allocation_factors: Optional[List[AllocationFactor]] = None
        self.exchanges: Optional[List[Exchange]] = None
        self.location: Optional[Location] = None
        self.parameters: Optional[List[Parameter]] = None
        self.process_documentation: Optional[ProcessDocumentation] = None
        self.process_type: Optional[ProcessType] = None
        self.dq_system: Optional[Ref] = None
        self.exchange_dq_system: Optional[Ref] = None
        self.social_dq_system: Optional[Ref] = None
        self.dq_entry: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Process, self).to_json()
        if self.default_allocation_method is not None:
            json[&#39;defaultAllocationMethod&#39;] = self.default_allocation_method.value
        if self.allocation_factors is not None:
            json[&#39;allocationFactors&#39;] = []
            for e in self.allocation_factors:
                json[&#39;allocationFactors&#39;].append(e.to_json())
        if self.exchanges is not None:
            json[&#39;exchanges&#39;] = []
            for e in self.exchanges:
                json[&#39;exchanges&#39;].append(e.to_json())
        if self.location is not None:
            json[&#39;location&#39;] = self.location.to_json()
        if self.parameters is not None:
            json[&#39;parameters&#39;] = []
            for e in self.parameters:
                json[&#39;parameters&#39;].append(e.to_json())
        if self.process_documentation is not None:
            json[&#39;processDocumentation&#39;] = self.process_documentation.to_json()
        if self.process_type is not None:
            json[&#39;processType&#39;] = self.process_type.value
        if self.dq_system is not None:
            json[&#39;dqSystem&#39;] = self.dq_system.to_json()
        if self.exchange_dq_system is not None:
            json[&#39;exchangeDqSystem&#39;] = self.exchange_dq_system.to_json()
        if self.social_dq_system is not None:
            json[&#39;socialDqSystem&#39;] = self.social_dq_system.to_json()
        if self.dq_entry is not None:
            json[&#39;dqEntry&#39;] = self.dq_entry
        return json

    def from_json(self, json: dict):
        super(Process, self).from_json(json)
        val = json.get(&#39;defaultAllocationMethod&#39;)
        if val is not None:
            self.default_allocation_method = AllocationType(val)
        val = json.get(&#39;allocationFactors&#39;)
        if val is not None:
            self.allocation_factors = []
            for d in val:
                e = AllocationFactor()
                e.from_json(d)
                self.allocation_factors.append(e)
        val = json.get(&#39;exchanges&#39;)
        if val is not None:
            self.exchanges = []
            for d in val:
                e = Exchange()
                e.from_json(d)
                self.exchanges.append(e)
        val = json.get(&#39;location&#39;)
        if val is not None:
            self.location = Location()
            self.location.from_json(val)
        val = json.get(&#39;parameters&#39;)
        if val is not None:
            self.parameters = []
            for d in val:
                e = Parameter()
                e.from_json(d)
                self.parameters.append(e)
        val = json.get(&#39;processDocumentation&#39;)
        if val is not None:
            self.process_documentation = ProcessDocumentation()
            self.process_documentation.from_json(val)
        val = json.get(&#39;processType&#39;)
        if val is not None:
            self.process_type = ProcessType(val)
        val = json.get(&#39;dqSystem&#39;)
        if val is not None:
            self.dq_system = Ref()
            self.dq_system.from_json(val)
        val = json.get(&#39;exchangeDqSystem&#39;)
        if val is not None:
            self.exchange_dq_system = Ref()
            self.exchange_dq_system.from_json(val)
        val = json.get(&#39;socialDqSystem&#39;)
        if val is not None:
            self.social_dq_system = Ref()
            self.social_dq_system.from_json(val)
        val = json.get(&#39;dqEntry&#39;)
        if val is not None:
            self.dq_entry = val</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.CategorizedEntity" href="#olca.schema.CategorizedEntity">CategorizedEntity</a></li>
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.Process.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(Process, self).from_json(json)
    val = json.get(&#39;defaultAllocationMethod&#39;)
    if val is not None:
        self.default_allocation_method = AllocationType(val)
    val = json.get(&#39;allocationFactors&#39;)
    if val is not None:
        self.allocation_factors = []
        for d in val:
            e = AllocationFactor()
            e.from_json(d)
            self.allocation_factors.append(e)
    val = json.get(&#39;exchanges&#39;)
    if val is not None:
        self.exchanges = []
        for d in val:
            e = Exchange()
            e.from_json(d)
            self.exchanges.append(e)
    val = json.get(&#39;location&#39;)
    if val is not None:
        self.location = Location()
        self.location.from_json(val)
    val = json.get(&#39;parameters&#39;)
    if val is not None:
        self.parameters = []
        for d in val:
            e = Parameter()
            e.from_json(d)
            self.parameters.append(e)
    val = json.get(&#39;processDocumentation&#39;)
    if val is not None:
        self.process_documentation = ProcessDocumentation()
        self.process_documentation.from_json(val)
    val = json.get(&#39;processType&#39;)
    if val is not None:
        self.process_type = ProcessType(val)
    val = json.get(&#39;dqSystem&#39;)
    if val is not None:
        self.dq_system = Ref()
        self.dq_system.from_json(val)
    val = json.get(&#39;exchangeDqSystem&#39;)
    if val is not None:
        self.exchange_dq_system = Ref()
        self.exchange_dq_system.from_json(val)
    val = json.get(&#39;socialDqSystem&#39;)
    if val is not None:
        self.social_dq_system = Ref()
        self.social_dq_system.from_json(val)
    val = json.get(&#39;dqEntry&#39;)
    if val is not None:
        self.dq_entry = val</code></pre>
</details>
</dd>
<dt id="olca.schema.Process.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(Process, self).to_json()
    if self.default_allocation_method is not None:
        json[&#39;defaultAllocationMethod&#39;] = self.default_allocation_method.value
    if self.allocation_factors is not None:
        json[&#39;allocationFactors&#39;] = []
        for e in self.allocation_factors:
            json[&#39;allocationFactors&#39;].append(e.to_json())
    if self.exchanges is not None:
        json[&#39;exchanges&#39;] = []
        for e in self.exchanges:
            json[&#39;exchanges&#39;].append(e.to_json())
    if self.location is not None:
        json[&#39;location&#39;] = self.location.to_json()
    if self.parameters is not None:
        json[&#39;parameters&#39;] = []
        for e in self.parameters:
            json[&#39;parameters&#39;].append(e.to_json())
    if self.process_documentation is not None:
        json[&#39;processDocumentation&#39;] = self.process_documentation.to_json()
    if self.process_type is not None:
        json[&#39;processType&#39;] = self.process_type.value
    if self.dq_system is not None:
        json[&#39;dqSystem&#39;] = self.dq_system.to_json()
    if self.exchange_dq_system is not None:
        json[&#39;exchangeDqSystem&#39;] = self.exchange_dq_system.to_json()
    if self.social_dq_system is not None:
        json[&#39;socialDqSystem&#39;] = self.social_dq_system.to_json()
    if self.dq_entry is not None:
        json[&#39;dqEntry&#39;] = self.dq_entry
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.ProcessDocumentation"><code class="flex name class">
<span>class <span class="ident">ProcessDocumentation</span></span>
</code></dt>
<dd>
<div class="desc"><h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>time_description</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>valid_until</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>valid_from</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>technology_description</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>data_collection_description</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>completeness_description</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>data_selection_description</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>review_details</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>data_treatment_description</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>inventory_method_description</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>modeling_constants_description</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>reviewer</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>sampling_description</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>sources</code></strong> :&ensp;<code>List[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>restrictions_description</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>copyright</code></strong> :&ensp;<code>bool</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>creation_date</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>data_documentor</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>data_generator</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>data_set_owner</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>intended_application</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>project_description</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>publication</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>geography_description</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProcessDocumentation(Entity):
    &#34;&#34;&#34;


    Attributes
    ----------
    time_description: str

    valid_until: str

    valid_from: str

    technology_description: str

    data_collection_description: str

    completeness_description: str

    data_selection_description: str

    review_details: str

    data_treatment_description: str

    inventory_method_description: str

    modeling_constants_description: str

    reviewer: Ref

    sampling_description: str

    sources: List[Ref]

    restrictions_description: str

    copyright: bool

    creation_date: str

    data_documentor: Ref

    data_generator: Ref

    data_set_owner: Ref

    intended_application: str

    project_description: str

    publication: Ref

    geography_description: str

    &#34;&#34;&#34;

    def __init__(self):
        super(ProcessDocumentation, self).__init__()
        self.time_description: Optional[str] = None
        self.valid_until: Optional[str] = None
        self.valid_from: Optional[str] = None
        self.technology_description: Optional[str] = None
        self.data_collection_description: Optional[str] = None
        self.completeness_description: Optional[str] = None
        self.data_selection_description: Optional[str] = None
        self.review_details: Optional[str] = None
        self.data_treatment_description: Optional[str] = None
        self.inventory_method_description: Optional[str] = None
        self.modeling_constants_description: Optional[str] = None
        self.reviewer: Optional[Ref] = None
        self.sampling_description: Optional[str] = None
        self.sources: Optional[List[Ref]] = None
        self.restrictions_description: Optional[str] = None
        self.copyright: Optional[bool] = None
        self.creation_date: Optional[str] = None
        self.data_documentor: Optional[Ref] = None
        self.data_generator: Optional[Ref] = None
        self.data_set_owner: Optional[Ref] = None
        self.intended_application: Optional[str] = None
        self.project_description: Optional[str] = None
        self.publication: Optional[Ref] = None
        self.geography_description: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ProcessDocumentation, self).to_json()
        if self.time_description is not None:
            json[&#39;timeDescription&#39;] = self.time_description
        if self.valid_until is not None:
            json[&#39;validUntil&#39;] = self.valid_until
        if self.valid_from is not None:
            json[&#39;validFrom&#39;] = self.valid_from
        if self.technology_description is not None:
            json[&#39;technologyDescription&#39;] = self.technology_description
        if self.data_collection_description is not None:
            json[&#39;dataCollectionDescription&#39;] = self.data_collection_description
        if self.completeness_description is not None:
            json[&#39;completenessDescription&#39;] = self.completeness_description
        if self.data_selection_description is not None:
            json[&#39;dataSelectionDescription&#39;] = self.data_selection_description
        if self.review_details is not None:
            json[&#39;reviewDetails&#39;] = self.review_details
        if self.data_treatment_description is not None:
            json[&#39;dataTreatmentDescription&#39;] = self.data_treatment_description
        if self.inventory_method_description is not None:
            json[&#39;inventoryMethodDescription&#39;] = self.inventory_method_description
        if self.modeling_constants_description is not None:
            json[&#39;modelingConstantsDescription&#39;] = self.modeling_constants_description
        if self.reviewer is not None:
            json[&#39;reviewer&#39;] = self.reviewer.to_json()
        if self.sampling_description is not None:
            json[&#39;samplingDescription&#39;] = self.sampling_description
        if self.sources is not None:
            json[&#39;sources&#39;] = []
            for e in self.sources:
                json[&#39;sources&#39;].append(e.to_json())
        if self.restrictions_description is not None:
            json[&#39;restrictionsDescription&#39;] = self.restrictions_description
        if self.copyright is not None:
            json[&#39;copyright&#39;] = self.copyright
        if self.creation_date is not None:
            json[&#39;creationDate&#39;] = self.creation_date
        if self.data_documentor is not None:
            json[&#39;dataDocumentor&#39;] = self.data_documentor.to_json()
        if self.data_generator is not None:
            json[&#39;dataGenerator&#39;] = self.data_generator.to_json()
        if self.data_set_owner is not None:
            json[&#39;dataSetOwner&#39;] = self.data_set_owner.to_json()
        if self.intended_application is not None:
            json[&#39;intendedApplication&#39;] = self.intended_application
        if self.project_description is not None:
            json[&#39;projectDescription&#39;] = self.project_description
        if self.publication is not None:
            json[&#39;publication&#39;] = self.publication.to_json()
        if self.geography_description is not None:
            json[&#39;geographyDescription&#39;] = self.geography_description
        return json

    def from_json(self, json: dict):
        super(ProcessDocumentation, self).from_json(json)
        val = json.get(&#39;timeDescription&#39;)
        if val is not None:
            self.time_description = val
        val = json.get(&#39;validUntil&#39;)
        if val is not None:
            self.valid_until = val
        val = json.get(&#39;validFrom&#39;)
        if val is not None:
            self.valid_from = val
        val = json.get(&#39;technologyDescription&#39;)
        if val is not None:
            self.technology_description = val
        val = json.get(&#39;dataCollectionDescription&#39;)
        if val is not None:
            self.data_collection_description = val
        val = json.get(&#39;completenessDescription&#39;)
        if val is not None:
            self.completeness_description = val
        val = json.get(&#39;dataSelectionDescription&#39;)
        if val is not None:
            self.data_selection_description = val
        val = json.get(&#39;reviewDetails&#39;)
        if val is not None:
            self.review_details = val
        val = json.get(&#39;dataTreatmentDescription&#39;)
        if val is not None:
            self.data_treatment_description = val
        val = json.get(&#39;inventoryMethodDescription&#39;)
        if val is not None:
            self.inventory_method_description = val
        val = json.get(&#39;modelingConstantsDescription&#39;)
        if val is not None:
            self.modeling_constants_description = val
        val = json.get(&#39;reviewer&#39;)
        if val is not None:
            self.reviewer = Ref()
            self.reviewer.from_json(val)
        val = json.get(&#39;samplingDescription&#39;)
        if val is not None:
            self.sampling_description = val
        val = json.get(&#39;sources&#39;)
        if val is not None:
            self.sources = []
            for d in val:
                e = Ref()
                e.from_json(d)
                self.sources.append(e)
        val = json.get(&#39;restrictionsDescription&#39;)
        if val is not None:
            self.restrictions_description = val
        val = json.get(&#39;copyright&#39;)
        if val is not None:
            self.copyright = val
        val = json.get(&#39;creationDate&#39;)
        if val is not None:
            self.creation_date = val
        val = json.get(&#39;dataDocumentor&#39;)
        if val is not None:
            self.data_documentor = Ref()
            self.data_documentor.from_json(val)
        val = json.get(&#39;dataGenerator&#39;)
        if val is not None:
            self.data_generator = Ref()
            self.data_generator.from_json(val)
        val = json.get(&#39;dataSetOwner&#39;)
        if val is not None:
            self.data_set_owner = Ref()
            self.data_set_owner.from_json(val)
        val = json.get(&#39;intendedApplication&#39;)
        if val is not None:
            self.intended_application = val
        val = json.get(&#39;projectDescription&#39;)
        if val is not None:
            self.project_description = val
        val = json.get(&#39;publication&#39;)
        if val is not None:
            self.publication = Ref()
            self.publication.from_json(val)
        val = json.get(&#39;geographyDescription&#39;)
        if val is not None:
            self.geography_description = val</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.ProcessDocumentation.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(ProcessDocumentation, self).from_json(json)
    val = json.get(&#39;timeDescription&#39;)
    if val is not None:
        self.time_description = val
    val = json.get(&#39;validUntil&#39;)
    if val is not None:
        self.valid_until = val
    val = json.get(&#39;validFrom&#39;)
    if val is not None:
        self.valid_from = val
    val = json.get(&#39;technologyDescription&#39;)
    if val is not None:
        self.technology_description = val
    val = json.get(&#39;dataCollectionDescription&#39;)
    if val is not None:
        self.data_collection_description = val
    val = json.get(&#39;completenessDescription&#39;)
    if val is not None:
        self.completeness_description = val
    val = json.get(&#39;dataSelectionDescription&#39;)
    if val is not None:
        self.data_selection_description = val
    val = json.get(&#39;reviewDetails&#39;)
    if val is not None:
        self.review_details = val
    val = json.get(&#39;dataTreatmentDescription&#39;)
    if val is not None:
        self.data_treatment_description = val
    val = json.get(&#39;inventoryMethodDescription&#39;)
    if val is not None:
        self.inventory_method_description = val
    val = json.get(&#39;modelingConstantsDescription&#39;)
    if val is not None:
        self.modeling_constants_description = val
    val = json.get(&#39;reviewer&#39;)
    if val is not None:
        self.reviewer = Ref()
        self.reviewer.from_json(val)
    val = json.get(&#39;samplingDescription&#39;)
    if val is not None:
        self.sampling_description = val
    val = json.get(&#39;sources&#39;)
    if val is not None:
        self.sources = []
        for d in val:
            e = Ref()
            e.from_json(d)
            self.sources.append(e)
    val = json.get(&#39;restrictionsDescription&#39;)
    if val is not None:
        self.restrictions_description = val
    val = json.get(&#39;copyright&#39;)
    if val is not None:
        self.copyright = val
    val = json.get(&#39;creationDate&#39;)
    if val is not None:
        self.creation_date = val
    val = json.get(&#39;dataDocumentor&#39;)
    if val is not None:
        self.data_documentor = Ref()
        self.data_documentor.from_json(val)
    val = json.get(&#39;dataGenerator&#39;)
    if val is not None:
        self.data_generator = Ref()
        self.data_generator.from_json(val)
    val = json.get(&#39;dataSetOwner&#39;)
    if val is not None:
        self.data_set_owner = Ref()
        self.data_set_owner.from_json(val)
    val = json.get(&#39;intendedApplication&#39;)
    if val is not None:
        self.intended_application = val
    val = json.get(&#39;projectDescription&#39;)
    if val is not None:
        self.project_description = val
    val = json.get(&#39;publication&#39;)
    if val is not None:
        self.publication = Ref()
        self.publication.from_json(val)
    val = json.get(&#39;geographyDescription&#39;)
    if val is not None:
        self.geography_description = val</code></pre>
</details>
</dd>
<dt id="olca.schema.ProcessDocumentation.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(ProcessDocumentation, self).to_json()
    if self.time_description is not None:
        json[&#39;timeDescription&#39;] = self.time_description
    if self.valid_until is not None:
        json[&#39;validUntil&#39;] = self.valid_until
    if self.valid_from is not None:
        json[&#39;validFrom&#39;] = self.valid_from
    if self.technology_description is not None:
        json[&#39;technologyDescription&#39;] = self.technology_description
    if self.data_collection_description is not None:
        json[&#39;dataCollectionDescription&#39;] = self.data_collection_description
    if self.completeness_description is not None:
        json[&#39;completenessDescription&#39;] = self.completeness_description
    if self.data_selection_description is not None:
        json[&#39;dataSelectionDescription&#39;] = self.data_selection_description
    if self.review_details is not None:
        json[&#39;reviewDetails&#39;] = self.review_details
    if self.data_treatment_description is not None:
        json[&#39;dataTreatmentDescription&#39;] = self.data_treatment_description
    if self.inventory_method_description is not None:
        json[&#39;inventoryMethodDescription&#39;] = self.inventory_method_description
    if self.modeling_constants_description is not None:
        json[&#39;modelingConstantsDescription&#39;] = self.modeling_constants_description
    if self.reviewer is not None:
        json[&#39;reviewer&#39;] = self.reviewer.to_json()
    if self.sampling_description is not None:
        json[&#39;samplingDescription&#39;] = self.sampling_description
    if self.sources is not None:
        json[&#39;sources&#39;] = []
        for e in self.sources:
            json[&#39;sources&#39;].append(e.to_json())
    if self.restrictions_description is not None:
        json[&#39;restrictionsDescription&#39;] = self.restrictions_description
    if self.copyright is not None:
        json[&#39;copyright&#39;] = self.copyright
    if self.creation_date is not None:
        json[&#39;creationDate&#39;] = self.creation_date
    if self.data_documentor is not None:
        json[&#39;dataDocumentor&#39;] = self.data_documentor.to_json()
    if self.data_generator is not None:
        json[&#39;dataGenerator&#39;] = self.data_generator.to_json()
    if self.data_set_owner is not None:
        json[&#39;dataSetOwner&#39;] = self.data_set_owner.to_json()
    if self.intended_application is not None:
        json[&#39;intendedApplication&#39;] = self.intended_application
    if self.project_description is not None:
        json[&#39;projectDescription&#39;] = self.project_description
    if self.publication is not None:
        json[&#39;publication&#39;] = self.publication.to_json()
    if self.geography_description is not None:
        json[&#39;geographyDescription&#39;] = self.geography_description
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.ProcessLink"><code class="flex name class">
<span>class <span class="ident">ProcessLink</span></span>
</code></dt>
<dd>
<div class="desc"><p>A process link is a connection between two processes in a product system.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>provider</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The descriptor of the process that provides a product or a waste
treatment.</dd>
<dt><strong><code>flow</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The descriptor of the flow that is exchanged between the two processes.</dd>
<dt><strong><code>process</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The descriptor of the process that is linked to the provider.</dd>
<dt><strong><code>exchange</code></strong> :&ensp;<code><a title="olca.schema.Exchange" href="#olca.schema.Exchange">Exchange</a></code></dt>
<dd>The exchange of the linked process (this is useful if the linked
process has multiple exchanges with the same flow that are linked to
different provides, e.g. in an electricity mix).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProcessLink(Entity):
    &#34;&#34;&#34;
    A process link is a connection between two processes in a product system.

    Attributes
    ----------
    provider: Ref
        The descriptor of the process that provides a product or a waste
        treatment.

    flow: Ref
        The descriptor of the flow that is exchanged between the two processes.

    process: Ref
        The descriptor of the process that is linked to the provider.

    exchange: Exchange
        The exchange of the linked process (this is useful if the linked
        process has multiple exchanges with the same flow that are linked to
        different provides, e.g. in an electricity mix).

    &#34;&#34;&#34;

    def __init__(self):
        super(ProcessLink, self).__init__()
        self.provider: Optional[Ref] = None
        self.flow: Optional[Ref] = None
        self.process: Optional[Ref] = None
        self.exchange: Optional[Exchange] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ProcessLink, self).to_json()
        if self.provider is not None:
            json[&#39;provider&#39;] = self.provider.to_json()
        if self.flow is not None:
            json[&#39;flow&#39;] = self.flow.to_json()
        if self.process is not None:
            json[&#39;process&#39;] = self.process.to_json()
        if self.exchange is not None:
            json[&#39;exchange&#39;] = self.exchange.to_json()
        return json

    def from_json(self, json: dict):
        super(ProcessLink, self).from_json(json)
        val = json.get(&#39;provider&#39;)
        if val is not None:
            self.provider = Ref()
            self.provider.from_json(val)
        val = json.get(&#39;flow&#39;)
        if val is not None:
            self.flow = Ref()
            self.flow.from_json(val)
        val = json.get(&#39;process&#39;)
        if val is not None:
            self.process = Ref()
            self.process.from_json(val)
        val = json.get(&#39;exchange&#39;)
        if val is not None:
            self.exchange = Exchange()
            self.exchange.from_json(val)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.ProcessLink.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(ProcessLink, self).from_json(json)
    val = json.get(&#39;provider&#39;)
    if val is not None:
        self.provider = Ref()
        self.provider.from_json(val)
    val = json.get(&#39;flow&#39;)
    if val is not None:
        self.flow = Ref()
        self.flow.from_json(val)
    val = json.get(&#39;process&#39;)
    if val is not None:
        self.process = Ref()
        self.process.from_json(val)
    val = json.get(&#39;exchange&#39;)
    if val is not None:
        self.exchange = Exchange()
        self.exchange.from_json(val)</code></pre>
</details>
</dd>
<dt id="olca.schema.ProcessLink.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(ProcessLink, self).to_json()
    if self.provider is not None:
        json[&#39;provider&#39;] = self.provider.to_json()
    if self.flow is not None:
        json[&#39;flow&#39;] = self.flow.to_json()
    if self.process is not None:
        json[&#39;process&#39;] = self.process.to_json()
    if self.exchange is not None:
        json[&#39;exchange&#39;] = self.exchange.to_json()
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.ProcessRef"><code class="flex name class">
<span>class <span class="ident">ProcessRef</span></span>
</code></dt>
<dd>
<div class="desc"><p>A reference to a [Process] data set.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>location</code></strong> :&ensp;<code>str</code></dt>
<dd>The location name or code of the process.</dd>
<dt><strong><code>process_type</code></strong> :&ensp;<code><a title="olca.schema.ProcessType" href="#olca.schema.ProcessType">ProcessType</a></code></dt>
<dd>The type of the process.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProcessRef(Ref):
    &#34;&#34;&#34;
    A reference to a [Process] data set.

    Attributes
    ----------
    location: str
        The location name or code of the process.

    process_type: ProcessType
        The type of the process.

    &#34;&#34;&#34;

    def __init__(self):
        super(ProcessRef, self).__init__()
        self.location: Optional[str] = None
        self.process_type: Optional[ProcessType] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ProcessRef, self).to_json()
        if self.location is not None:
            json[&#39;location&#39;] = self.location
        if self.process_type is not None:
            json[&#39;processType&#39;] = self.process_type.value
        return json

    def from_json(self, json: dict):
        super(ProcessRef, self).from_json(json)
        val = json.get(&#39;location&#39;)
        if val is not None:
            self.location = val
        val = json.get(&#39;processType&#39;)
        if val is not None:
            self.process_type = ProcessType(val)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></li>
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.ProcessRef.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(ProcessRef, self).from_json(json)
    val = json.get(&#39;location&#39;)
    if val is not None:
        self.location = val
    val = json.get(&#39;processType&#39;)
    if val is not None:
        self.process_type = ProcessType(val)</code></pre>
</details>
</dd>
<dt id="olca.schema.ProcessRef.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(ProcessRef, self).to_json()
    if self.location is not None:
        json[&#39;location&#39;] = self.location
    if self.process_type is not None:
        json[&#39;processType&#39;] = self.process_type.value
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.ProcessType"><code class="flex name class">
<span>class <span class="ident">ProcessType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProcessType(Enum):
    LCI_RESULT = &#39;LCI_RESULT&#39;
    UNIT_PROCESS = &#39;UNIT_PROCESS&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.ProcessType.LCI_RESULT"><code class="name">var <span class="ident">LCI_RESULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProcessType.UNIT_PROCESS"><code class="name">var <span class="ident">UNIT_PROCESS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="olca.schema.ProductSystem"><code class="flex name class">
<span>class <span class="ident">ProductSystem</span></span>
</code></dt>
<dd>
<div class="desc"><p>A product system describes the supply chain of a product (the functional
unit) &hellip;</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>processes</code></strong> :&ensp;<code>List[<a title="olca.schema.ProcessRef" href="#olca.schema.ProcessRef">ProcessRef</a>]</code></dt>
<dd>The descriptors of all processes that are contained in the product
system.</dd>
<dt><strong><code>reference_process</code></strong> :&ensp;<code><a title="olca.schema.ProcessRef" href="#olca.schema.ProcessRef">ProcessRef</a></code></dt>
<dd>The descriptor of the process that provides the flow of the functional
unit of the product system.</dd>
<dt><strong><code>reference_exchange</code></strong> :&ensp;<code><a title="olca.schema.Exchange" href="#olca.schema.Exchange">Exchange</a></code></dt>
<dd>The exchange of the reference processes (typically the product output)
that provides the flow of the functional unit of the product system.</dd>
<dt><strong><code>target_amount</code></strong> :&ensp;<code>float</code></dt>
<dd>The flow amount of the functional unit of the product system.</dd>
<dt><strong><code>target_unit</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The unit in which the flow amount of the functional unit is given.</dd>
<dt><strong><code>target_flow_property</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The flow property in which the flow amount of the functional unit is
given.</dd>
<dt><strong><code>process_links</code></strong> :&ensp;<code>List[<a title="olca.schema.ProcessLink" href="#olca.schema.ProcessLink">ProcessLink</a>]</code></dt>
<dd>The process links of the product system.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProductSystem(CategorizedEntity):
    &#34;&#34;&#34;
    A product system describes the supply chain of a product (the functional
    unit) ...

    Attributes
    ----------
    processes: List[ProcessRef]
        The descriptors of all processes that are contained in the product
        system.

    reference_process: ProcessRef
        The descriptor of the process that provides the flow of the functional
        unit of the product system.

    reference_exchange: Exchange
        The exchange of the reference processes (typically the product output)
        that provides the flow of the functional unit of the product system.

    target_amount: float
        The flow amount of the functional unit of the product system.

    target_unit: Ref
        The unit in which the flow amount of the functional unit is given.

    target_flow_property: Ref
        The flow property in which the flow amount of the functional unit is
        given.

    process_links: List[ProcessLink]
        The process links of the product system.

    &#34;&#34;&#34;

    def __init__(self):
        super(ProductSystem, self).__init__()
        self.processes: Optional[List[ProcessRef]] = None
        self.reference_process: Optional[ProcessRef] = None
        self.reference_exchange: Optional[Exchange] = None
        self.target_amount: Optional[float] = None
        self.target_unit: Optional[Ref] = None
        self.target_flow_property: Optional[Ref] = None
        self.process_links: Optional[List[ProcessLink]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ProductSystem, self).to_json()
        if self.processes is not None:
            json[&#39;processes&#39;] = []
            for e in self.processes:
                json[&#39;processes&#39;].append(e.to_json())
        if self.reference_process is not None:
            json[&#39;referenceProcess&#39;] = self.reference_process.to_json()
        if self.reference_exchange is not None:
            json[&#39;referenceExchange&#39;] = self.reference_exchange.to_json()
        if self.target_amount is not None:
            json[&#39;targetAmount&#39;] = self.target_amount
        if self.target_unit is not None:
            json[&#39;targetUnit&#39;] = self.target_unit.to_json()
        if self.target_flow_property is not None:
            json[&#39;targetFlowProperty&#39;] = self.target_flow_property.to_json()
        if self.process_links is not None:
            json[&#39;processLinks&#39;] = []
            for e in self.process_links:
                json[&#39;processLinks&#39;].append(e.to_json())
        return json

    def from_json(self, json: dict):
        super(ProductSystem, self).from_json(json)
        val = json.get(&#39;processes&#39;)
        if val is not None:
            self.processes = []
            for d in val:
                e = ProcessRef()
                e.from_json(d)
                self.processes.append(e)
        val = json.get(&#39;referenceProcess&#39;)
        if val is not None:
            self.reference_process = ProcessRef()
            self.reference_process.from_json(val)
        val = json.get(&#39;referenceExchange&#39;)
        if val is not None:
            self.reference_exchange = Exchange()
            self.reference_exchange.from_json(val)
        val = json.get(&#39;targetAmount&#39;)
        if val is not None:
            self.target_amount = val
        val = json.get(&#39;targetUnit&#39;)
        if val is not None:
            self.target_unit = Ref()
            self.target_unit.from_json(val)
        val = json.get(&#39;targetFlowProperty&#39;)
        if val is not None:
            self.target_flow_property = Ref()
            self.target_flow_property.from_json(val)
        val = json.get(&#39;processLinks&#39;)
        if val is not None:
            self.process_links = []
            for d in val:
                e = ProcessLink()
                e.from_json(d)
                self.process_links.append(e)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.CategorizedEntity" href="#olca.schema.CategorizedEntity">CategorizedEntity</a></li>
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.ProductSystem.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(ProductSystem, self).from_json(json)
    val = json.get(&#39;processes&#39;)
    if val is not None:
        self.processes = []
        for d in val:
            e = ProcessRef()
            e.from_json(d)
            self.processes.append(e)
    val = json.get(&#39;referenceProcess&#39;)
    if val is not None:
        self.reference_process = ProcessRef()
        self.reference_process.from_json(val)
    val = json.get(&#39;referenceExchange&#39;)
    if val is not None:
        self.reference_exchange = Exchange()
        self.reference_exchange.from_json(val)
    val = json.get(&#39;targetAmount&#39;)
    if val is not None:
        self.target_amount = val
    val = json.get(&#39;targetUnit&#39;)
    if val is not None:
        self.target_unit = Ref()
        self.target_unit.from_json(val)
    val = json.get(&#39;targetFlowProperty&#39;)
    if val is not None:
        self.target_flow_property = Ref()
        self.target_flow_property.from_json(val)
    val = json.get(&#39;processLinks&#39;)
    if val is not None:
        self.process_links = []
        for d in val:
            e = ProcessLink()
            e.from_json(d)
            self.process_links.append(e)</code></pre>
</details>
</dd>
<dt id="olca.schema.ProductSystem.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(ProductSystem, self).to_json()
    if self.processes is not None:
        json[&#39;processes&#39;] = []
        for e in self.processes:
            json[&#39;processes&#39;].append(e.to_json())
    if self.reference_process is not None:
        json[&#39;referenceProcess&#39;] = self.reference_process.to_json()
    if self.reference_exchange is not None:
        json[&#39;referenceExchange&#39;] = self.reference_exchange.to_json()
    if self.target_amount is not None:
        json[&#39;targetAmount&#39;] = self.target_amount
    if self.target_unit is not None:
        json[&#39;targetUnit&#39;] = self.target_unit.to_json()
    if self.target_flow_property is not None:
        json[&#39;targetFlowProperty&#39;] = self.target_flow_property.to_json()
    if self.process_links is not None:
        json[&#39;processLinks&#39;] = []
        for e in self.process_links:
            json[&#39;processLinks&#39;].append(e.to_json())
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.Ref"><code class="flex name class">
<span>class <span class="ident">Ref</span></span>
</code></dt>
<dd>
<div class="desc"><p>A Ref is a reference to a [RootEntity]. When serializing an entity (e.g. a
[Process]) that references another standalone entity (e.g. a [Flow] in an
[Exchange]) we do not want to write the complete referenced entity into the
serialized JSON object but just a reference. However, the reference
contains some meta-data like name, category path etc. that are useful to
display.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>category_path</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>The full path of the category of the referenced entity from top to
bottom, e.g. <code>"Elementary flows", "Emissions to air", "unspecified"</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Ref(RootEntity):
    &#34;&#34;&#34;
    A Ref is a reference to a [RootEntity]. When serializing an entity (e.g. a
    [Process]) that references another standalone entity (e.g. a [Flow] in an
    [Exchange]) we do not want to write the complete referenced entity into the
    serialized JSON object but just a reference. However, the reference
    contains some meta-data like name, category path etc. that are useful to
    display.

    Attributes
    ----------
    category_path: List[str]
        The full path of the category of the referenced entity from top to
        bottom, e.g. `&#34;Elementary flows&#34;, &#34;Emissions to air&#34;, &#34;unspecified&#34;`.

    &#34;&#34;&#34;

    def __init__(self):
        super(Ref, self).__init__()
        self.category_path: Optional[List[str]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Ref, self).to_json()
        if self.category_path is not None:
            json[&#39;categoryPath&#39;] = []
            for e in self.category_path:
                json[&#39;categoryPath&#39;].append(e)
        return json

    def from_json(self, json: dict):
        super(Ref, self).from_json(json)
        val = json.get(&#39;categoryPath&#39;)
        if val is not None:
            self.category_path = []
            for d in val:
                e = d
                self.category_path.append(e)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="olca.schema.FlowRef" href="#olca.schema.FlowRef">FlowRef</a></li>
<li><a title="olca.schema.ImpactCategoryRef" href="#olca.schema.ImpactCategoryRef">ImpactCategoryRef</a></li>
<li><a title="olca.schema.ProcessRef" href="#olca.schema.ProcessRef">ProcessRef</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.Ref.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(Ref, self).from_json(json)
    val = json.get(&#39;categoryPath&#39;)
    if val is not None:
        self.category_path = []
        for d in val:
            e = d
            self.category_path.append(e)</code></pre>
</details>
</dd>
<dt id="olca.schema.Ref.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(Ref, self).to_json()
    if self.category_path is not None:
        json[&#39;categoryPath&#39;] = []
        for e in self.category_path:
            json[&#39;categoryPath&#39;].append(e)
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.RootEntity"><code class="flex name class">
<span>class <span class="ident">RootEntity</span></span>
</code></dt>
<dd>
<div class="desc"><p>A standalone item in a database like a location, unit group, flow, or
process. A root entity can be unambiguously identified by its id (the
JSON-LD @id field), version, and lastChange fields.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the entity.</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code></dt>
<dd>The description of the entity.</dd>
<dt><strong><code>version</code></strong> :&ensp;<code>str</code></dt>
<dd>A version number in MAJOR.MINOR.PATCH format where the MINOR and PATCH
fields are optional and the fields may have leading zeros (so 01.00.00
is the same as 1.0.0 or 1).</dd>
<dt><strong><code>last_change</code></strong> :&ensp;<code>str</code></dt>
<dd>The timestamp when the entity was changed the last time.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RootEntity(Entity):
    &#34;&#34;&#34;
    A standalone item in a database like a location, unit group, flow, or
    process. A root entity can be unambiguously identified by its id (the
    JSON-LD @id field), version, and lastChange fields.

    Attributes
    ----------
    name: str
        The name of the entity.

    description: str
        The description of the entity.

    version: str
        A version number in MAJOR.MINOR.PATCH format where the MINOR and PATCH
        fields are optional and the fields may have leading zeros (so 01.00.00
        is the same as 1.0.0 or 1).

    last_change: str
        The timestamp when the entity was changed the last time.

    &#34;&#34;&#34;

    def __init__(self):
        super(RootEntity, self).__init__()
        self.name: Optional[str] = None
        self.description: Optional[str] = None
        self.version: Optional[str] = None
        self.last_change: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(RootEntity, self).to_json()
        if self.name is not None:
            json[&#39;name&#39;] = self.name
        if self.description is not None:
            json[&#39;description&#39;] = self.description
        if self.version is not None:
            json[&#39;version&#39;] = self.version
        if self.last_change is not None:
            json[&#39;lastChange&#39;] = self.last_change
        return json

    def from_json(self, json: dict):
        super(RootEntity, self).from_json(json)
        val = json.get(&#39;name&#39;)
        if val is not None:
            self.name = val
        val = json.get(&#39;description&#39;)
        if val is not None:
            self.description = val
        val = json.get(&#39;version&#39;)
        if val is not None:
            self.version = val
        val = json.get(&#39;lastChange&#39;)
        if val is not None:
            self.last_change = val</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="olca.schema.CategorizedEntity" href="#olca.schema.CategorizedEntity">CategorizedEntity</a></li>
<li><a title="olca.schema.FlowMap" href="#olca.schema.FlowMap">FlowMap</a></li>
<li><a title="olca.schema.FlowMapEntry" href="#olca.schema.FlowMapEntry">FlowMapEntry</a></li>
<li><a title="olca.schema.ImpactCategory" href="#olca.schema.ImpactCategory">ImpactCategory</a></li>
<li><a title="olca.schema.Location" href="#olca.schema.Location">Location</a></li>
<li><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></li>
<li><a title="olca.schema.Unit" href="#olca.schema.Unit">Unit</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.RootEntity.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(RootEntity, self).from_json(json)
    val = json.get(&#39;name&#39;)
    if val is not None:
        self.name = val
    val = json.get(&#39;description&#39;)
    if val is not None:
        self.description = val
    val = json.get(&#39;version&#39;)
    if val is not None:
        self.version = val
    val = json.get(&#39;lastChange&#39;)
    if val is not None:
        self.last_change = val</code></pre>
</details>
</dd>
<dt id="olca.schema.RootEntity.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(RootEntity, self).to_json()
    if self.name is not None:
        json[&#39;name&#39;] = self.name
    if self.description is not None:
        json[&#39;description&#39;] = self.description
    if self.version is not None:
        json[&#39;version&#39;] = self.version
    if self.last_change is not None:
        json[&#39;lastChange&#39;] = self.last_change
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.SimpleResult"><code class="flex name class">
<span>class <span class="ident">SimpleResult</span></span>
</code></dt>
<dd>
<div class="desc"><h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>flow_results</code></strong> :&ensp;<code>List[<a title="olca.schema.FlowResult" href="#olca.schema.FlowResult">FlowResult</a>]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>impact_results</code></strong> :&ensp;<code>List[<a title="olca.schema.ImpactResult" href="#olca.schema.ImpactResult">ImpactResult</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SimpleResult(Entity):
    &#34;&#34;&#34;


    Attributes
    ----------
    flow_results: List[FlowResult]

    impact_results: List[ImpactResult]

    &#34;&#34;&#34;

    def __init__(self):
        super(SimpleResult, self).__init__()
        self.flow_results: Optional[List[FlowResult]] = None
        self.impact_results: Optional[List[ImpactResult]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(SimpleResult, self).to_json()
        if self.flow_results is not None:
            json[&#39;flowResults&#39;] = []
            for e in self.flow_results:
                json[&#39;flowResults&#39;].append(e.to_json())
        if self.impact_results is not None:
            json[&#39;impactResults&#39;] = []
            for e in self.impact_results:
                json[&#39;impactResults&#39;].append(e.to_json())
        return json

    def from_json(self, json: dict):
        super(SimpleResult, self).from_json(json)
        val = json.get(&#39;flowResults&#39;)
        if val is not None:
            self.flow_results = []
            for d in val:
                e = FlowResult()
                e.from_json(d)
                self.flow_results.append(e)
        val = json.get(&#39;impactResults&#39;)
        if val is not None:
            self.impact_results = []
            for d in val:
                e = ImpactResult()
                e.from_json(d)
                self.impact_results.append(e)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.SimpleResult.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(SimpleResult, self).from_json(json)
    val = json.get(&#39;flowResults&#39;)
    if val is not None:
        self.flow_results = []
        for d in val:
            e = FlowResult()
            e.from_json(d)
            self.flow_results.append(e)
    val = json.get(&#39;impactResults&#39;)
    if val is not None:
        self.impact_results = []
        for d in val:
            e = ImpactResult()
            e.from_json(d)
            self.impact_results.append(e)</code></pre>
</details>
</dd>
<dt id="olca.schema.SimpleResult.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(SimpleResult, self).to_json()
    if self.flow_results is not None:
        json[&#39;flowResults&#39;] = []
        for e in self.flow_results:
            json[&#39;flowResults&#39;].append(e.to_json())
    if self.impact_results is not None:
        json[&#39;impactResults&#39;] = []
        for e in self.impact_results:
            json[&#39;impactResults&#39;].append(e.to_json())
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.SocialIndicator"><code class="flex name class">
<span>class <span class="ident">SocialIndicator</span></span>
</code></dt>
<dd>
<div class="desc"><h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>activity_variable</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the activity variable of the indicator.</dd>
<dt><strong><code>activity_quantity</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The quantity of the activity variable.</dd>
<dt><strong><code>activity_unit</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The unit of the activity variable.</dd>
<dt><strong><code>unit_of_measurement</code></strong> :&ensp;<code>str</code></dt>
<dd>The unit in which the indicator is measured.</dd>
<dt><strong><code>evaluation_scheme</code></strong> :&ensp;<code>str</code></dt>
<dd>Documentation of the evaluation scheme of the indicator.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SocialIndicator(CategorizedEntity):
    &#34;&#34;&#34;


    Attributes
    ----------
    activity_variable: str
        The name of the activity variable of the indicator.

    activity_quantity: Ref
        The quantity of the activity variable.

    activity_unit: Ref
        The unit of the activity variable.

    unit_of_measurement: str
        The unit in which the indicator is measured.

    evaluation_scheme: str
        Documentation of the evaluation scheme of the indicator.

    &#34;&#34;&#34;

    def __init__(self):
        super(SocialIndicator, self).__init__()
        self.activity_variable: Optional[str] = None
        self.activity_quantity: Optional[Ref] = None
        self.activity_unit: Optional[Ref] = None
        self.unit_of_measurement: Optional[str] = None
        self.evaluation_scheme: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(SocialIndicator, self).to_json()
        if self.activity_variable is not None:
            json[&#39;activityVariable&#39;] = self.activity_variable
        if self.activity_quantity is not None:
            json[&#39;activityQuantity&#39;] = self.activity_quantity.to_json()
        if self.activity_unit is not None:
            json[&#39;activityUnit&#39;] = self.activity_unit.to_json()
        if self.unit_of_measurement is not None:
            json[&#39;unitOfMeasurement&#39;] = self.unit_of_measurement
        if self.evaluation_scheme is not None:
            json[&#39;evaluationScheme&#39;] = self.evaluation_scheme
        return json

    def from_json(self, json: dict):
        super(SocialIndicator, self).from_json(json)
        val = json.get(&#39;activityVariable&#39;)
        if val is not None:
            self.activity_variable = val
        val = json.get(&#39;activityQuantity&#39;)
        if val is not None:
            self.activity_quantity = Ref()
            self.activity_quantity.from_json(val)
        val = json.get(&#39;activityUnit&#39;)
        if val is not None:
            self.activity_unit = Ref()
            self.activity_unit.from_json(val)
        val = json.get(&#39;unitOfMeasurement&#39;)
        if val is not None:
            self.unit_of_measurement = val
        val = json.get(&#39;evaluationScheme&#39;)
        if val is not None:
            self.evaluation_scheme = val</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.CategorizedEntity" href="#olca.schema.CategorizedEntity">CategorizedEntity</a></li>
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.SocialIndicator.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(SocialIndicator, self).from_json(json)
    val = json.get(&#39;activityVariable&#39;)
    if val is not None:
        self.activity_variable = val
    val = json.get(&#39;activityQuantity&#39;)
    if val is not None:
        self.activity_quantity = Ref()
        self.activity_quantity.from_json(val)
    val = json.get(&#39;activityUnit&#39;)
    if val is not None:
        self.activity_unit = Ref()
        self.activity_unit.from_json(val)
    val = json.get(&#39;unitOfMeasurement&#39;)
    if val is not None:
        self.unit_of_measurement = val
    val = json.get(&#39;evaluationScheme&#39;)
    if val is not None:
        self.evaluation_scheme = val</code></pre>
</details>
</dd>
<dt id="olca.schema.SocialIndicator.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(SocialIndicator, self).to_json()
    if self.activity_variable is not None:
        json[&#39;activityVariable&#39;] = self.activity_variable
    if self.activity_quantity is not None:
        json[&#39;activityQuantity&#39;] = self.activity_quantity.to_json()
    if self.activity_unit is not None:
        json[&#39;activityUnit&#39;] = self.activity_unit.to_json()
    if self.unit_of_measurement is not None:
        json[&#39;unitOfMeasurement&#39;] = self.unit_of_measurement
    if self.evaluation_scheme is not None:
        json[&#39;evaluationScheme&#39;] = self.evaluation_scheme
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.Source"><code class="flex name class">
<span>class <span class="ident">Source</span></span>
</code></dt>
<dd>
<div class="desc"><p>A source is a literature reference.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>doi</code></strong> :&ensp;<code>str</code></dt>
<dd>The digital object identifier of the source (see
<a href="http://en.wikipedia.org/wiki/Digital_object_identifier">http://en.wikipedia.org/wiki/Digital_object_identifier</a>).</dd>
<dt><strong><code>text_reference</code></strong> :&ensp;<code>str</code></dt>
<dd>The full text reference of the source.</dd>
<dt><strong><code>year</code></strong> :&ensp;<code>int</code></dt>
<dd>The publication year of the source.</dd>
<dt><strong><code>external_file</code></strong> :&ensp;<code>str</code></dt>
<dd>A direct link (relative or absolute URL) to the source file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Source(CategorizedEntity):
    &#34;&#34;&#34;
    A source is a literature reference.

    Attributes
    ----------
    doi: str
        The digital object identifier of the source (see
        http://en.wikipedia.org/wiki/Digital_object_identifier).

    text_reference: str
        The full text reference of the source.

    year: int
        The publication year of the source.

    external_file: str
        A direct link (relative or absolute URL) to the source file.

    &#34;&#34;&#34;

    def __init__(self):
        super(Source, self).__init__()
        self.doi: Optional[str] = None
        self.text_reference: Optional[str] = None
        self.year: Optional[int] = None
        self.external_file: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Source, self).to_json()
        if self.doi is not None:
            json[&#39;doi&#39;] = self.doi
        if self.text_reference is not None:
            json[&#39;textReference&#39;] = self.text_reference
        if self.year is not None:
            json[&#39;year&#39;] = self.year
        if self.external_file is not None:
            json[&#39;externalFile&#39;] = self.external_file
        return json

    def from_json(self, json: dict):
        super(Source, self).from_json(json)
        val = json.get(&#39;doi&#39;)
        if val is not None:
            self.doi = val
        val = json.get(&#39;textReference&#39;)
        if val is not None:
            self.text_reference = val
        val = json.get(&#39;year&#39;)
        if val is not None:
            self.year = val
        val = json.get(&#39;externalFile&#39;)
        if val is not None:
            self.external_file = val</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.CategorizedEntity" href="#olca.schema.CategorizedEntity">CategorizedEntity</a></li>
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.Source.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(Source, self).from_json(json)
    val = json.get(&#39;doi&#39;)
    if val is not None:
        self.doi = val
    val = json.get(&#39;textReference&#39;)
    if val is not None:
        self.text_reference = val
    val = json.get(&#39;year&#39;)
    if val is not None:
        self.year = val
    val = json.get(&#39;externalFile&#39;)
    if val is not None:
        self.external_file = val</code></pre>
</details>
</dd>
<dt id="olca.schema.Source.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(Source, self).to_json()
    if self.doi is not None:
        json[&#39;doi&#39;] = self.doi
    if self.text_reference is not None:
        json[&#39;textReference&#39;] = self.text_reference
    if self.year is not None:
        json[&#39;year&#39;] = self.year
    if self.external_file is not None:
        json[&#39;externalFile&#39;] = self.external_file
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.Uncertainty"><code class="flex name class">
<span>class <span class="ident">Uncertainty</span></span>
</code></dt>
<dd>
<div class="desc"><p>Defines the parameter values of an uncertainty distribution. Depending on
the uncertainty distribution type different parameters could be used.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>distribution_type</code></strong> :&ensp;<code><a title="olca.schema.UncertaintyType" href="#olca.schema.UncertaintyType">UncertaintyType</a></code></dt>
<dd>The uncertainty distribution type</dd>
<dt><strong><code>mean</code></strong> :&ensp;<code>float</code></dt>
<dd>The arithmetic mean (used for normal distributions).</dd>
<dt><strong><code>mean_formula</code></strong> :&ensp;<code>str</code></dt>
<dd>A mathematical formula for the arithmetic mean.</dd>
<dt><strong><code>geom_mean</code></strong> :&ensp;<code>float</code></dt>
<dd>The geometric mean value (used for log-normal distributions).</dd>
<dt><strong><code>geom_mean_formula</code></strong> :&ensp;<code>str</code></dt>
<dd>A mathematical formula for the geometric mean.</dd>
<dt><strong><code>minimum</code></strong> :&ensp;<code>float</code></dt>
<dd>The minimum value (used for uniform and triangle distributions).</dd>
<dt><strong><code>minimum_formula</code></strong> :&ensp;<code>str</code></dt>
<dd>A mathematical formula for the minimum value.</dd>
<dt><strong><code>sd</code></strong> :&ensp;<code>float</code></dt>
<dd>The arithmetic standard deviation (used for normal distributions).</dd>
<dt><strong><code>sd_formula</code></strong> :&ensp;<code>str</code></dt>
<dd>A mathematical formula for the arithmetic standard deviation.</dd>
<dt><strong><code>geom_sd</code></strong> :&ensp;<code>float</code></dt>
<dd>The geometric standard deviation (used for log-normal distributions).</dd>
<dt><strong><code>geom_sd_formula</code></strong> :&ensp;<code>str</code></dt>
<dd>A mathematical formula for the geometric standard deviation.</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>float</code></dt>
<dd>The most likely value (used for triangle distributions).</dd>
<dt><strong><code>mode_formula</code></strong> :&ensp;<code>str</code></dt>
<dd>A mathematical formula for the most likely value.</dd>
<dt><strong><code>maximum</code></strong> :&ensp;<code>float</code></dt>
<dd>The maximum value (used for uniform and triangle distributions).</dd>
<dt><strong><code>maximum_formula</code></strong> :&ensp;<code>str</code></dt>
<dd>A mathematical formula for the maximum value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Uncertainty(Entity):
    &#34;&#34;&#34;
    Defines the parameter values of an uncertainty distribution. Depending on
    the uncertainty distribution type different parameters could be used.

    Attributes
    ----------
    distribution_type: UncertaintyType
        The uncertainty distribution type

    mean: float
        The arithmetic mean (used for normal distributions).

    mean_formula: str
        A mathematical formula for the arithmetic mean.

    geom_mean: float
        The geometric mean value (used for log-normal distributions).

    geom_mean_formula: str
        A mathematical formula for the geometric mean.

    minimum: float
        The minimum value (used for uniform and triangle distributions).

    minimum_formula: str
        A mathematical formula for the minimum value.

    sd: float
        The arithmetic standard deviation (used for normal distributions).

    sd_formula: str
        A mathematical formula for the arithmetic standard deviation.

    geom_sd: float
        The geometric standard deviation (used for log-normal distributions).

    geom_sd_formula: str
        A mathematical formula for the geometric standard deviation.

    mode: float
        The most likely value (used for triangle distributions).

    mode_formula: str
        A mathematical formula for the most likely value.

    maximum: float
        The maximum value (used for uniform and triangle distributions).

    maximum_formula: str
        A mathematical formula for the maximum value.

    &#34;&#34;&#34;

    def __init__(self):
        super(Uncertainty, self).__init__()
        self.distribution_type: Optional[UncertaintyType] = None
        self.mean: Optional[float] = None
        self.mean_formula: Optional[str] = None
        self.geom_mean: Optional[float] = None
        self.geom_mean_formula: Optional[str] = None
        self.minimum: Optional[float] = None
        self.minimum_formula: Optional[str] = None
        self.sd: Optional[float] = None
        self.sd_formula: Optional[str] = None
        self.geom_sd: Optional[float] = None
        self.geom_sd_formula: Optional[str] = None
        self.mode: Optional[float] = None
        self.mode_formula: Optional[str] = None
        self.maximum: Optional[float] = None
        self.maximum_formula: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Uncertainty, self).to_json()
        if self.distribution_type is not None:
            json[&#39;distributionType&#39;] = self.distribution_type.value
        if self.mean is not None:
            json[&#39;mean&#39;] = self.mean
        if self.mean_formula is not None:
            json[&#39;meanFormula&#39;] = self.mean_formula
        if self.geom_mean is not None:
            json[&#39;geomMean&#39;] = self.geom_mean
        if self.geom_mean_formula is not None:
            json[&#39;geomMeanFormula&#39;] = self.geom_mean_formula
        if self.minimum is not None:
            json[&#39;minimum&#39;] = self.minimum
        if self.minimum_formula is not None:
            json[&#39;minimumFormula&#39;] = self.minimum_formula
        if self.sd is not None:
            json[&#39;sd&#39;] = self.sd
        if self.sd_formula is not None:
            json[&#39;sdFormula&#39;] = self.sd_formula
        if self.geom_sd is not None:
            json[&#39;geomSd&#39;] = self.geom_sd
        if self.geom_sd_formula is not None:
            json[&#39;geomSdFormula&#39;] = self.geom_sd_formula
        if self.mode is not None:
            json[&#39;mode&#39;] = self.mode
        if self.mode_formula is not None:
            json[&#39;modeFormula&#39;] = self.mode_formula
        if self.maximum is not None:
            json[&#39;maximum&#39;] = self.maximum
        if self.maximum_formula is not None:
            json[&#39;maximumFormula&#39;] = self.maximum_formula
        return json

    def from_json(self, json: dict):
        super(Uncertainty, self).from_json(json)
        val = json.get(&#39;distributionType&#39;)
        if val is not None:
            self.distribution_type = UncertaintyType(val)
        val = json.get(&#39;mean&#39;)
        if val is not None:
            self.mean = val
        val = json.get(&#39;meanFormula&#39;)
        if val is not None:
            self.mean_formula = val
        val = json.get(&#39;geomMean&#39;)
        if val is not None:
            self.geom_mean = val
        val = json.get(&#39;geomMeanFormula&#39;)
        if val is not None:
            self.geom_mean_formula = val
        val = json.get(&#39;minimum&#39;)
        if val is not None:
            self.minimum = val
        val = json.get(&#39;minimumFormula&#39;)
        if val is not None:
            self.minimum_formula = val
        val = json.get(&#39;sd&#39;)
        if val is not None:
            self.sd = val
        val = json.get(&#39;sdFormula&#39;)
        if val is not None:
            self.sd_formula = val
        val = json.get(&#39;geomSd&#39;)
        if val is not None:
            self.geom_sd = val
        val = json.get(&#39;geomSdFormula&#39;)
        if val is not None:
            self.geom_sd_formula = val
        val = json.get(&#39;mode&#39;)
        if val is not None:
            self.mode = val
        val = json.get(&#39;modeFormula&#39;)
        if val is not None:
            self.mode_formula = val
        val = json.get(&#39;maximum&#39;)
        if val is not None:
            self.maximum = val
        val = json.get(&#39;maximumFormula&#39;)
        if val is not None:
            self.maximum_formula = val</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.Uncertainty.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(Uncertainty, self).from_json(json)
    val = json.get(&#39;distributionType&#39;)
    if val is not None:
        self.distribution_type = UncertaintyType(val)
    val = json.get(&#39;mean&#39;)
    if val is not None:
        self.mean = val
    val = json.get(&#39;meanFormula&#39;)
    if val is not None:
        self.mean_formula = val
    val = json.get(&#39;geomMean&#39;)
    if val is not None:
        self.geom_mean = val
    val = json.get(&#39;geomMeanFormula&#39;)
    if val is not None:
        self.geom_mean_formula = val
    val = json.get(&#39;minimum&#39;)
    if val is not None:
        self.minimum = val
    val = json.get(&#39;minimumFormula&#39;)
    if val is not None:
        self.minimum_formula = val
    val = json.get(&#39;sd&#39;)
    if val is not None:
        self.sd = val
    val = json.get(&#39;sdFormula&#39;)
    if val is not None:
        self.sd_formula = val
    val = json.get(&#39;geomSd&#39;)
    if val is not None:
        self.geom_sd = val
    val = json.get(&#39;geomSdFormula&#39;)
    if val is not None:
        self.geom_sd_formula = val
    val = json.get(&#39;mode&#39;)
    if val is not None:
        self.mode = val
    val = json.get(&#39;modeFormula&#39;)
    if val is not None:
        self.mode_formula = val
    val = json.get(&#39;maximum&#39;)
    if val is not None:
        self.maximum = val
    val = json.get(&#39;maximumFormula&#39;)
    if val is not None:
        self.maximum_formula = val</code></pre>
</details>
</dd>
<dt id="olca.schema.Uncertainty.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(Uncertainty, self).to_json()
    if self.distribution_type is not None:
        json[&#39;distributionType&#39;] = self.distribution_type.value
    if self.mean is not None:
        json[&#39;mean&#39;] = self.mean
    if self.mean_formula is not None:
        json[&#39;meanFormula&#39;] = self.mean_formula
    if self.geom_mean is not None:
        json[&#39;geomMean&#39;] = self.geom_mean
    if self.geom_mean_formula is not None:
        json[&#39;geomMeanFormula&#39;] = self.geom_mean_formula
    if self.minimum is not None:
        json[&#39;minimum&#39;] = self.minimum
    if self.minimum_formula is not None:
        json[&#39;minimumFormula&#39;] = self.minimum_formula
    if self.sd is not None:
        json[&#39;sd&#39;] = self.sd
    if self.sd_formula is not None:
        json[&#39;sdFormula&#39;] = self.sd_formula
    if self.geom_sd is not None:
        json[&#39;geomSd&#39;] = self.geom_sd
    if self.geom_sd_formula is not None:
        json[&#39;geomSdFormula&#39;] = self.geom_sd_formula
    if self.mode is not None:
        json[&#39;mode&#39;] = self.mode
    if self.mode_formula is not None:
        json[&#39;modeFormula&#39;] = self.mode_formula
    if self.maximum is not None:
        json[&#39;maximum&#39;] = self.maximum
    if self.maximum_formula is not None:
        json[&#39;maximumFormula&#39;] = self.maximum_formula
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.UncertaintyType"><code class="flex name class">
<span>class <span class="ident">UncertaintyType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enumeration of uncertainty distribution types that can be used in
exchanges, parameters, LCIA factors, etc.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UncertaintyType(Enum):
    &#34;&#34;&#34;
    Enumeration of uncertainty distribution types that can be used in
    exchanges, parameters, LCIA factors, etc.
    &#34;&#34;&#34;

    LOG_NORMAL_DISTRIBUTION = &#39;LOG_NORMAL_DISTRIBUTION&#39;
    NORMAL_DISTRIBUTION = &#39;NORMAL_DISTRIBUTION&#39;
    TRIANGLE_DISTRIBUTION = &#39;TRIANGLE_DISTRIBUTION&#39;
    UNIFORM_DISTRIBUTION = &#39;UNIFORM_DISTRIBUTION&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.UncertaintyType.LOG_NORMAL_DISTRIBUTION"><code class="name">var <span class="ident">LOG_NORMAL_DISTRIBUTION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.UncertaintyType.NORMAL_DISTRIBUTION"><code class="name">var <span class="ident">NORMAL_DISTRIBUTION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.UncertaintyType.TRIANGLE_DISTRIBUTION"><code class="name">var <span class="ident">TRIANGLE_DISTRIBUTION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.UncertaintyType.UNIFORM_DISTRIBUTION"><code class="name">var <span class="ident">UNIFORM_DISTRIBUTION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="olca.schema.Unit"><code class="flex name class">
<span>class <span class="ident">Unit</span></span>
</code></dt>
<dd>
<div class="desc"><p>An unit of measure</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>conversion_factor</code></strong> :&ensp;<code>float</code></dt>
<dd>The conversion factor to the reference unit of the unit group to which
this unit belongs.</dd>
<dt><strong><code>reference_unit</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates whether the unit is the reference unit of the unit group to
which this unit belongs. If it is the reference unit the conversion
factor must be 1.0. There should be always only one reference unit in a
unit group. The reference unit is used to convert amounts given in one
unit to amounts given in another unit of the respective unit group.</dd>
<dt><strong><code>synonyms</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>A list of synonyms for the unit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Unit(RootEntity):
    &#34;&#34;&#34;
    An unit of measure

    Attributes
    ----------
    conversion_factor: float
        The conversion factor to the reference unit of the unit group to which
        this unit belongs.

    reference_unit: bool
        Indicates whether the unit is the reference unit of the unit group to
        which this unit belongs. If it is the reference unit the conversion
        factor must be 1.0. There should be always only one reference unit in a
        unit group. The reference unit is used to convert amounts given in one
        unit to amounts given in another unit of the respective unit group.

    synonyms: List[str]
        A list of synonyms for the unit.

    &#34;&#34;&#34;

    def __init__(self):
        super(Unit, self).__init__()
        self.conversion_factor: Optional[float] = None
        self.reference_unit: Optional[bool] = None
        self.synonyms: Optional[List[str]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Unit, self).to_json()
        if self.conversion_factor is not None:
            json[&#39;conversionFactor&#39;] = self.conversion_factor
        if self.reference_unit is not None:
            json[&#39;referenceUnit&#39;] = self.reference_unit
        if self.synonyms is not None:
            json[&#39;synonyms&#39;] = []
            for e in self.synonyms:
                json[&#39;synonyms&#39;].append(e)
        return json

    def from_json(self, json: dict):
        super(Unit, self).from_json(json)
        val = json.get(&#39;conversionFactor&#39;)
        if val is not None:
            self.conversion_factor = val
        val = json.get(&#39;referenceUnit&#39;)
        if val is not None:
            self.reference_unit = val
        val = json.get(&#39;synonyms&#39;)
        if val is not None:
            self.synonyms = []
            for d in val:
                e = d
                self.synonyms.append(e)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.Unit.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(Unit, self).from_json(json)
    val = json.get(&#39;conversionFactor&#39;)
    if val is not None:
        self.conversion_factor = val
    val = json.get(&#39;referenceUnit&#39;)
    if val is not None:
        self.reference_unit = val
    val = json.get(&#39;synonyms&#39;)
    if val is not None:
        self.synonyms = []
        for d in val:
            e = d
            self.synonyms.append(e)</code></pre>
</details>
</dd>
<dt id="olca.schema.Unit.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(Unit, self).to_json()
    if self.conversion_factor is not None:
        json[&#39;conversionFactor&#39;] = self.conversion_factor
    if self.reference_unit is not None:
        json[&#39;referenceUnit&#39;] = self.reference_unit
    if self.synonyms is not None:
        json[&#39;synonyms&#39;] = []
        for e in self.synonyms:
            json[&#39;synonyms&#39;].append(e)
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.UnitGroup"><code class="flex name class">
<span>class <span class="ident">UnitGroup</span></span>
</code></dt>
<dd>
<div class="desc"><p>A group of units that can be converted into each other.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>default_flow_property</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>Some LCA data formats do not have the concept of flow properties or
quantities. This field provides a default link to a flow property for
units that are contained in this group.</dd>
<dt><strong><code>units</code></strong> :&ensp;<code>List[<a title="olca.schema.Unit" href="#olca.schema.Unit">Unit</a>]</code></dt>
<dd>The units of the unit group.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnitGroup(CategorizedEntity):
    &#34;&#34;&#34;
    A group of units that can be converted into each other.

    Attributes
    ----------
    default_flow_property: Ref
        Some LCA data formats do not have the concept of flow properties or
        quantities. This field provides a default link to a flow property for
        units that are contained in this group.

    units: List[Unit]
        The units of the unit group.

    &#34;&#34;&#34;

    def __init__(self):
        super(UnitGroup, self).__init__()
        self.default_flow_property: Optional[Ref] = None
        self.units: Optional[List[Unit]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(UnitGroup, self).to_json()
        if self.default_flow_property is not None:
            json[&#39;defaultFlowProperty&#39;] = self.default_flow_property.to_json()
        if self.units is not None:
            json[&#39;units&#39;] = []
            for e in self.units:
                json[&#39;units&#39;].append(e.to_json())
        return json

    def from_json(self, json: dict):
        super(UnitGroup, self).from_json(json)
        val = json.get(&#39;defaultFlowProperty&#39;)
        if val is not None:
            self.default_flow_property = Ref()
            self.default_flow_property.from_json(val)
        val = json.get(&#39;units&#39;)
        if val is not None:
            self.units = []
            for d in val:
                e = Unit()
                e.from_json(d)
                self.units.append(e)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.CategorizedEntity" href="#olca.schema.CategorizedEntity">CategorizedEntity</a></li>
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.UnitGroup.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json: dict):
    super(UnitGroup, self).from_json(json)
    val = json.get(&#39;defaultFlowProperty&#39;)
    if val is not None:
        self.default_flow_property = Ref()
        self.default_flow_property.from_json(val)
    val = json.get(&#39;units&#39;)
    if val is not None:
        self.units = []
        for d in val:
            e = Unit()
            e.from_json(d)
            self.units.append(e)</code></pre>
</details>
</dd>
<dt id="olca.schema.UnitGroup.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(UnitGroup, self).to_json()
    if self.default_flow_property is not None:
        json[&#39;defaultFlowProperty&#39;] = self.default_flow_property.to_json()
    if self.units is not None:
        json[&#39;units&#39;] = []
        for e in self.units:
            json[&#39;units&#39;].append(e.to_json())
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="olca" href="index.html">olca</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="olca.schema.Actor" href="#olca.schema.Actor">Actor</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.Actor.from_json" href="#olca.schema.Actor.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.Actor.to_json" href="#olca.schema.Actor.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.AllocationFactor" href="#olca.schema.AllocationFactor">AllocationFactor</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.AllocationFactor.from_json" href="#olca.schema.AllocationFactor.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.AllocationFactor.to_json" href="#olca.schema.AllocationFactor.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.AllocationType" href="#olca.schema.AllocationType">AllocationType</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.AllocationType.CAUSAL_ALLOCATION" href="#olca.schema.AllocationType.CAUSAL_ALLOCATION">CAUSAL_ALLOCATION</a></code></li>
<li><code><a title="olca.schema.AllocationType.ECONOMIC_ALLOCATION" href="#olca.schema.AllocationType.ECONOMIC_ALLOCATION">ECONOMIC_ALLOCATION</a></code></li>
<li><code><a title="olca.schema.AllocationType.NO_ALLOCATION" href="#olca.schema.AllocationType.NO_ALLOCATION">NO_ALLOCATION</a></code></li>
<li><code><a title="olca.schema.AllocationType.PHYSICAL_ALLOCATION" href="#olca.schema.AllocationType.PHYSICAL_ALLOCATION">PHYSICAL_ALLOCATION</a></code></li>
<li><code><a title="olca.schema.AllocationType.USE_DEFAULT_ALLOCATION" href="#olca.schema.AllocationType.USE_DEFAULT_ALLOCATION">USE_DEFAULT_ALLOCATION</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.CalculationSetup" href="#olca.schema.CalculationSetup">CalculationSetup</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.CalculationSetup.from_json" href="#olca.schema.CalculationSetup.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.CalculationSetup.to_json" href="#olca.schema.CalculationSetup.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.CalculationType" href="#olca.schema.CalculationType">CalculationType</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.CalculationType.CONTRIBUTION_ANALYSIS" href="#olca.schema.CalculationType.CONTRIBUTION_ANALYSIS">CONTRIBUTION_ANALYSIS</a></code></li>
<li><code><a title="olca.schema.CalculationType.MONTE_CARLO_SIMULATION" href="#olca.schema.CalculationType.MONTE_CARLO_SIMULATION">MONTE_CARLO_SIMULATION</a></code></li>
<li><code><a title="olca.schema.CalculationType.REGIONALIZED_CALCULATION" href="#olca.schema.CalculationType.REGIONALIZED_CALCULATION">REGIONALIZED_CALCULATION</a></code></li>
<li><code><a title="olca.schema.CalculationType.SIMPLE_CALCULATION" href="#olca.schema.CalculationType.SIMPLE_CALCULATION">SIMPLE_CALCULATION</a></code></li>
<li><code><a title="olca.schema.CalculationType.UPSTREAM_ANALYSIS" href="#olca.schema.CalculationType.UPSTREAM_ANALYSIS">UPSTREAM_ANALYSIS</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.CategorizedEntity" href="#olca.schema.CategorizedEntity">CategorizedEntity</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.CategorizedEntity.from_json" href="#olca.schema.CategorizedEntity.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.CategorizedEntity.to_json" href="#olca.schema.CategorizedEntity.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.Category" href="#olca.schema.Category">Category</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.Category.from_json" href="#olca.schema.Category.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.Category.to_json" href="#olca.schema.Category.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.DqIndicator" href="#olca.schema.DqIndicator">DqIndicator</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.DqIndicator.from_json" href="#olca.schema.DqIndicator.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.DqIndicator.to_json" href="#olca.schema.DqIndicator.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.DqScore" href="#olca.schema.DqScore">DqScore</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.DqScore.from_json" href="#olca.schema.DqScore.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.DqScore.to_json" href="#olca.schema.DqScore.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.DqSystem" href="#olca.schema.DqSystem">DqSystem</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.DqSystem.from_json" href="#olca.schema.DqSystem.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.DqSystem.to_json" href="#olca.schema.DqSystem.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.Entity.from_json" href="#olca.schema.Entity.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.Entity.to_json" href="#olca.schema.Entity.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.Exchange" href="#olca.schema.Exchange">Exchange</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.Exchange.from_json" href="#olca.schema.Exchange.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.Exchange.to_json" href="#olca.schema.Exchange.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.Flow" href="#olca.schema.Flow">Flow</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.Flow.from_json" href="#olca.schema.Flow.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.Flow.to_json" href="#olca.schema.Flow.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.FlowMap" href="#olca.schema.FlowMap">FlowMap</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.FlowMap.from_json" href="#olca.schema.FlowMap.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.FlowMap.to_json" href="#olca.schema.FlowMap.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.FlowMapEntry" href="#olca.schema.FlowMapEntry">FlowMapEntry</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.FlowMapEntry.from_json" href="#olca.schema.FlowMapEntry.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.FlowMapEntry.to_json" href="#olca.schema.FlowMapEntry.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.FlowMapRef" href="#olca.schema.FlowMapRef">FlowMapRef</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.FlowMapRef.from_json" href="#olca.schema.FlowMapRef.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.FlowMapRef.to_json" href="#olca.schema.FlowMapRef.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.FlowProperty" href="#olca.schema.FlowProperty">FlowProperty</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.FlowProperty.from_json" href="#olca.schema.FlowProperty.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.FlowProperty.to_json" href="#olca.schema.FlowProperty.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.FlowPropertyFactor" href="#olca.schema.FlowPropertyFactor">FlowPropertyFactor</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.FlowPropertyFactor.from_json" href="#olca.schema.FlowPropertyFactor.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.FlowPropertyFactor.to_json" href="#olca.schema.FlowPropertyFactor.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.FlowPropertyType" href="#olca.schema.FlowPropertyType">FlowPropertyType</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.FlowPropertyType.ECONOMIC_QUANTITY" href="#olca.schema.FlowPropertyType.ECONOMIC_QUANTITY">ECONOMIC_QUANTITY</a></code></li>
<li><code><a title="olca.schema.FlowPropertyType.PHYSICAL_QUANTITY" href="#olca.schema.FlowPropertyType.PHYSICAL_QUANTITY">PHYSICAL_QUANTITY</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.FlowRef" href="#olca.schema.FlowRef">FlowRef</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.FlowRef.from_json" href="#olca.schema.FlowRef.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.FlowRef.to_json" href="#olca.schema.FlowRef.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.FlowResult" href="#olca.schema.FlowResult">FlowResult</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.FlowResult.from_json" href="#olca.schema.FlowResult.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.FlowResult.to_json" href="#olca.schema.FlowResult.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.FlowType" href="#olca.schema.FlowType">FlowType</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.FlowType.ELEMENTARY_FLOW" href="#olca.schema.FlowType.ELEMENTARY_FLOW">ELEMENTARY_FLOW</a></code></li>
<li><code><a title="olca.schema.FlowType.PRODUCT_FLOW" href="#olca.schema.FlowType.PRODUCT_FLOW">PRODUCT_FLOW</a></code></li>
<li><code><a title="olca.schema.FlowType.WASTE_FLOW" href="#olca.schema.FlowType.WASTE_FLOW">WASTE_FLOW</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.ImpactCategory" href="#olca.schema.ImpactCategory">ImpactCategory</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.ImpactCategory.from_json" href="#olca.schema.ImpactCategory.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.ImpactCategory.to_json" href="#olca.schema.ImpactCategory.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.ImpactCategoryRef" href="#olca.schema.ImpactCategoryRef">ImpactCategoryRef</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.ImpactCategoryRef.from_json" href="#olca.schema.ImpactCategoryRef.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.ImpactCategoryRef.to_json" href="#olca.schema.ImpactCategoryRef.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.ImpactFactor" href="#olca.schema.ImpactFactor">ImpactFactor</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.ImpactFactor.from_json" href="#olca.schema.ImpactFactor.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.ImpactFactor.to_json" href="#olca.schema.ImpactFactor.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.ImpactMethod" href="#olca.schema.ImpactMethod">ImpactMethod</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.ImpactMethod.from_json" href="#olca.schema.ImpactMethod.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.ImpactMethod.to_json" href="#olca.schema.ImpactMethod.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.ImpactResult" href="#olca.schema.ImpactResult">ImpactResult</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.ImpactResult.from_json" href="#olca.schema.ImpactResult.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.ImpactResult.to_json" href="#olca.schema.ImpactResult.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.Location" href="#olca.schema.Location">Location</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.Location.from_json" href="#olca.schema.Location.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.Location.to_json" href="#olca.schema.Location.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.ModelType" href="#olca.schema.ModelType">ModelType</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.ModelType.ACTOR" href="#olca.schema.ModelType.ACTOR">ACTOR</a></code></li>
<li><code><a title="olca.schema.ModelType.CATEGORY" href="#olca.schema.ModelType.CATEGORY">CATEGORY</a></code></li>
<li><code><a title="olca.schema.ModelType.FLOW" href="#olca.schema.ModelType.FLOW">FLOW</a></code></li>
<li><code><a title="olca.schema.ModelType.FLOW_PROPERTY" href="#olca.schema.ModelType.FLOW_PROPERTY">FLOW_PROPERTY</a></code></li>
<li><code><a title="olca.schema.ModelType.IMPACT_CATEGORY" href="#olca.schema.ModelType.IMPACT_CATEGORY">IMPACT_CATEGORY</a></code></li>
<li><code><a title="olca.schema.ModelType.IMPACT_METHOD" href="#olca.schema.ModelType.IMPACT_METHOD">IMPACT_METHOD</a></code></li>
<li><code><a title="olca.schema.ModelType.LOCATION" href="#olca.schema.ModelType.LOCATION">LOCATION</a></code></li>
<li><code><a title="olca.schema.ModelType.NW_SET" href="#olca.schema.ModelType.NW_SET">NW_SET</a></code></li>
<li><code><a title="olca.schema.ModelType.PROCESS" href="#olca.schema.ModelType.PROCESS">PROCESS</a></code></li>
<li><code><a title="olca.schema.ModelType.PRODUCT_SYSTEM" href="#olca.schema.ModelType.PRODUCT_SYSTEM">PRODUCT_SYSTEM</a></code></li>
<li><code><a title="olca.schema.ModelType.PROJECT" href="#olca.schema.ModelType.PROJECT">PROJECT</a></code></li>
<li><code><a title="olca.schema.ModelType.SOCIAL_INDICATOR" href="#olca.schema.ModelType.SOCIAL_INDICATOR">SOCIAL_INDICATOR</a></code></li>
<li><code><a title="olca.schema.ModelType.SOURCE" href="#olca.schema.ModelType.SOURCE">SOURCE</a></code></li>
<li><code><a title="olca.schema.ModelType.UNIT" href="#olca.schema.ModelType.UNIT">UNIT</a></code></li>
<li><code><a title="olca.schema.ModelType.UNIT_GROUP" href="#olca.schema.ModelType.UNIT_GROUP">UNIT_GROUP</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.Parameter" href="#olca.schema.Parameter">Parameter</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.Parameter.from_json" href="#olca.schema.Parameter.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.Parameter.to_json" href="#olca.schema.Parameter.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.ParameterRedef" href="#olca.schema.ParameterRedef">ParameterRedef</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.ParameterRedef.from_json" href="#olca.schema.ParameterRedef.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.ParameterRedef.to_json" href="#olca.schema.ParameterRedef.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.ParameterScope" href="#olca.schema.ParameterScope">ParameterScope</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.ParameterScope.GLOBAL_SCOPE" href="#olca.schema.ParameterScope.GLOBAL_SCOPE">GLOBAL_SCOPE</a></code></li>
<li><code><a title="olca.schema.ParameterScope.LCIA_METHOD_SCOPE" href="#olca.schema.ParameterScope.LCIA_METHOD_SCOPE">LCIA_METHOD_SCOPE</a></code></li>
<li><code><a title="olca.schema.ParameterScope.PROCESS_SCOPE" href="#olca.schema.ParameterScope.PROCESS_SCOPE">PROCESS_SCOPE</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.Process" href="#olca.schema.Process">Process</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.Process.from_json" href="#olca.schema.Process.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.Process.to_json" href="#olca.schema.Process.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.ProcessDocumentation" href="#olca.schema.ProcessDocumentation">ProcessDocumentation</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.ProcessDocumentation.from_json" href="#olca.schema.ProcessDocumentation.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.ProcessDocumentation.to_json" href="#olca.schema.ProcessDocumentation.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.ProcessLink" href="#olca.schema.ProcessLink">ProcessLink</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.ProcessLink.from_json" href="#olca.schema.ProcessLink.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.ProcessLink.to_json" href="#olca.schema.ProcessLink.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.ProcessRef" href="#olca.schema.ProcessRef">ProcessRef</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.ProcessRef.from_json" href="#olca.schema.ProcessRef.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.ProcessRef.to_json" href="#olca.schema.ProcessRef.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.ProcessType" href="#olca.schema.ProcessType">ProcessType</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.ProcessType.LCI_RESULT" href="#olca.schema.ProcessType.LCI_RESULT">LCI_RESULT</a></code></li>
<li><code><a title="olca.schema.ProcessType.UNIT_PROCESS" href="#olca.schema.ProcessType.UNIT_PROCESS">UNIT_PROCESS</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.ProductSystem" href="#olca.schema.ProductSystem">ProductSystem</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.ProductSystem.from_json" href="#olca.schema.ProductSystem.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.ProductSystem.to_json" href="#olca.schema.ProductSystem.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.Ref.from_json" href="#olca.schema.Ref.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.Ref.to_json" href="#olca.schema.Ref.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.RootEntity.from_json" href="#olca.schema.RootEntity.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.RootEntity.to_json" href="#olca.schema.RootEntity.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.SimpleResult" href="#olca.schema.SimpleResult">SimpleResult</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.SimpleResult.from_json" href="#olca.schema.SimpleResult.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.SimpleResult.to_json" href="#olca.schema.SimpleResult.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.SocialIndicator" href="#olca.schema.SocialIndicator">SocialIndicator</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.SocialIndicator.from_json" href="#olca.schema.SocialIndicator.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.SocialIndicator.to_json" href="#olca.schema.SocialIndicator.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.Source" href="#olca.schema.Source">Source</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.Source.from_json" href="#olca.schema.Source.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.Source.to_json" href="#olca.schema.Source.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.Uncertainty" href="#olca.schema.Uncertainty">Uncertainty</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.Uncertainty.from_json" href="#olca.schema.Uncertainty.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.Uncertainty.to_json" href="#olca.schema.Uncertainty.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.UncertaintyType" href="#olca.schema.UncertaintyType">UncertaintyType</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.UncertaintyType.LOG_NORMAL_DISTRIBUTION" href="#olca.schema.UncertaintyType.LOG_NORMAL_DISTRIBUTION">LOG_NORMAL_DISTRIBUTION</a></code></li>
<li><code><a title="olca.schema.UncertaintyType.NORMAL_DISTRIBUTION" href="#olca.schema.UncertaintyType.NORMAL_DISTRIBUTION">NORMAL_DISTRIBUTION</a></code></li>
<li><code><a title="olca.schema.UncertaintyType.TRIANGLE_DISTRIBUTION" href="#olca.schema.UncertaintyType.TRIANGLE_DISTRIBUTION">TRIANGLE_DISTRIBUTION</a></code></li>
<li><code><a title="olca.schema.UncertaintyType.UNIFORM_DISTRIBUTION" href="#olca.schema.UncertaintyType.UNIFORM_DISTRIBUTION">UNIFORM_DISTRIBUTION</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.Unit" href="#olca.schema.Unit">Unit</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.Unit.from_json" href="#olca.schema.Unit.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.Unit.to_json" href="#olca.schema.Unit.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.UnitGroup" href="#olca.schema.UnitGroup">UnitGroup</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.UnitGroup.from_json" href="#olca.schema.UnitGroup.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.UnitGroup.to_json" href="#olca.schema.UnitGroup.to_json">to_json</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>