<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>olca.schema API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>olca.schema</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># DO NOT CHANGE THIS CODE AS THIS IS GENERATED AUTOMATICALLY

# This module contains a Python API of the JSON-LD based
# openLCA data exchange model.package schema.
# For more information see http://greendelta.github.io/olca-schema/

from __future__ import annotations

import json as jsonlib

from dataclasses import dataclass
from enum import Enum
from typing import Optional


class AllocationType(Enum):
    &#34;&#34;&#34;
    An enumeration type for allocation methods. This type is used to define the
    type of an [AllocationFactor], the default allocation method of a
    multi-functional [Process], or the allocation method in a
    [CalculationSetup].
    &#34;&#34;&#34;

    PHYSICAL_ALLOCATION = &#39;PHYSICAL_ALLOCATION&#39;
    ECONOMIC_ALLOCATION = &#39;ECONOMIC_ALLOCATION&#39;
    CAUSAL_ALLOCATION = &#39;CAUSAL_ALLOCATION&#39;
    USE_DEFAULT_ALLOCATION = &#39;USE_DEFAULT_ALLOCATION&#39;
    NO_ALLOCATION = &#39;NO_ALLOCATION&#39;


class CalculationType(Enum):
    &#34;&#34;&#34;
    An enumeration of the different calculation methods supported by openLCA.
    &#34;&#34;&#34;

    SIMPLE_CALCULATION = &#39;SIMPLE_CALCULATION&#39;
    &#34;&#34;&#34;
    Calculates the total results for elementary flows, LCIA indicators, costs,
    etc. of a product system.
    &#34;&#34;&#34;

    CONTRIBUTION_ANALYSIS = &#39;CONTRIBUTION_ANALYSIS&#39;
    &#34;&#34;&#34;
    Includes the total result vectors of a simple calculation but calculates
    also the direct contributions of each process (or better process product in
    case of multi-output processes) to these total results.
    &#34;&#34;&#34;

    UPSTREAM_ANALYSIS = &#39;UPSTREAM_ANALYSIS&#39;
    &#34;&#34;&#34;
    Extends the contribution analysis by providing also the upstream results of
    each process (process product) in the product system. The upstream result
    contains the direct contributions of the respective process but also the
    result of the supply chain up to this process scaled to the demand of the
    process in the product system.
    &#34;&#34;&#34;

    REGIONALIZED_CALCULATION = &#39;REGIONALIZED_CALCULATION&#39;
    &#34;&#34;&#34;
    A regionalized calculation is a contribution analysis but with an LCIA
    method that supports regionalized characterization factors (via region
    specific parameters in formulas) and a product system with processes that
    have geographic information assigned (point, line, or polygon shapes).
    &#34;&#34;&#34;

    MONTE_CARLO_SIMULATION = &#39;MONTE_CARLO_SIMULATION&#39;
    &#34;&#34;&#34;
    A Monte Carlo simulation generates for each run, of a given number of a
    given number of iterations, random values according to the uncertainty
    distributions of process inputs/outputs, parameters, characterization
    factors, etc. of a product system and then performs a simple calculation
    for that specific run.
    &#34;&#34;&#34;



class FlowPropertyType(Enum):
    &#34;&#34;&#34;
    An enumeration of flow property types.
    &#34;&#34;&#34;

    ECONOMIC_QUANTITY = &#39;ECONOMIC_QUANTITY&#39;
    PHYSICAL_QUANTITY = &#39;PHYSICAL_QUANTITY&#39;


class FlowType(Enum):
    &#34;&#34;&#34;
    The basic flow types.
    &#34;&#34;&#34;

    ELEMENTARY_FLOW = &#39;ELEMENTARY_FLOW&#39;
    PRODUCT_FLOW = &#39;PRODUCT_FLOW&#39;
    WASTE_FLOW = &#39;WASTE_FLOW&#39;


class ModelType(Enum):
    &#34;&#34;&#34;
    An enumeration of the root entity types.
    &#34;&#34;&#34;

    ACTOR = &#39;ACTOR&#39;
    CATEGORY = &#39;CATEGORY&#39;
    CURRENCY = &#39;CURRENCY&#39;
    DQ_SYSTEM = &#39;DQ_SYSTEM&#39;
    FLOW = &#39;FLOW&#39;
    FLOW_PROPERTY = &#39;FLOW_PROPERTY&#39;
    IMPACT_CATEGORY = &#39;IMPACT_CATEGORY&#39;
    IMPACT_METHOD = &#39;IMPACT_METHOD&#39;
    LOCATION = &#39;LOCATION&#39;
    NW_SET = &#39;NW_SET&#39;
    PARAMETER = &#39;PARAMETER&#39;
    PROCESS = &#39;PROCESS&#39;
    PRODUCT_SYSTEM = &#39;PRODUCT_SYSTEM&#39;
    PROJECT = &#39;PROJECT&#39;
    SOCIAL_INDICATOR = &#39;SOCIAL_INDICATOR&#39;
    SOURCE = &#39;SOURCE&#39;
    UNIT = &#39;UNIT&#39;
    UNIT_GROUP = &#39;UNIT_GROUP&#39;


class ParameterScope(Enum):
    &#34;&#34;&#34;
    The possible scopes of parameters. Parameters can be defined globally, in
    processes, or impact categories. They can be redefined in calculation
    setups on the project and product system level, but the initial definition
    is always only global, in a process, or an LCIA category.
    &#34;&#34;&#34;

    PROCESS_SCOPE = &#39;PROCESS_SCOPE&#39;
    &#34;&#34;&#34;
    Indicates that the evaluation scope of a parameter is the process where it
    is defined.
    &#34;&#34;&#34;

    IMPACT_SCOPE = &#39;IMPACT_SCOPE&#39;
    &#34;&#34;&#34;
    Indicates that the evaluation scope of a parameter is the impact category
    where it is defined.
    &#34;&#34;&#34;

    GLOBAL_SCOPE = &#39;GLOBAL_SCOPE&#39;
    &#34;&#34;&#34;
    Indicates that the evaluation scope of a parameter is the global scope.
    &#34;&#34;&#34;



class ProcessType(Enum):
    LCI_RESULT = &#39;LCI_RESULT&#39;
    UNIT_PROCESS = &#39;UNIT_PROCESS&#39;


class RiskLevel(Enum):
    &#34;&#34;&#34;

    &#34;&#34;&#34;

    NO_OPPORTUNITY = &#39;NO_OPPORTUNITY&#39;
    HIGH_OPPORTUNITY = &#39;HIGH_OPPORTUNITY&#39;
    MEDIUM_OPPORTUNITY = &#39;MEDIUM_OPPORTUNITY&#39;
    LOW_OPPORTUNITY = &#39;LOW_OPPORTUNITY&#39;
    NO_RISK = &#39;NO_RISK&#39;
    VERY_LOW_RISK = &#39;VERY_LOW_RISK&#39;
    LOW_RISK = &#39;LOW_RISK&#39;
    MEDIUM_RISK = &#39;MEDIUM_RISK&#39;
    HIGH_RISK = &#39;HIGH_RISK&#39;
    VERY_HIGH_RISK = &#39;VERY_HIGH_RISK&#39;
    NO_DATA = &#39;NO_DATA&#39;
    NOT_APPLICABLE = &#39;NOT_APPLICABLE&#39;


class UncertaintyType(Enum):
    &#34;&#34;&#34;
    Enumeration of uncertainty distribution types that can be used in
    exchanges, parameters, LCIA factors, etc.
    &#34;&#34;&#34;

    LOG_NORMAL_DISTRIBUTION = &#39;LOG_NORMAL_DISTRIBUTION&#39;
    NORMAL_DISTRIBUTION = &#39;NORMAL_DISTRIBUTION&#39;
    TRIANGLE_DISTRIBUTION = &#39;TRIANGLE_DISTRIBUTION&#39;
    UNIFORM_DISTRIBUTION = &#39;UNIFORM_DISTRIBUTION&#39;



@dataclass
class Entity(object):
    &#34;&#34;&#34;
    The most generic type of the openLCA data model.
    &#34;&#34;&#34;

    id: str = &#39;&#39;
    olca_type: str = &#39;&#39;

    def _repr_html_(self):
        code = jsonlib.dumps(self.to_json(), indent=2, sort_keys=True)
        if len(code) &gt; 10000:
            code = code[0:10000] + &#39;...&#39;
        return f&#39;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{code}&lt;/code&gt;&lt;/pre&gt;&#39;
        
    def to_json(self) -&gt; dict:
        o_type = self.olca_type
        if o_type is None:
            o_type = type(self).__name__
        json = {&#39;@type&#39;: o_type}
        if self.id is not None:
            json[&#39;@id&#39;] = self.id
        return json

    def read_json(self, json: dict):
        self.id = json.get(&#39;@id&#39;)
        self.olca_type = json.get(&#39;@type&#39;)

    @staticmethod
    def from_json(json: dict):
        instance = Entity()
        instance.read_json(json)
        return instance


@dataclass
class AllocationFactor(Entity):
    &#34;&#34;&#34;
    A single allocation factor in a process.

    Attributes
    ----------
    allocation_type: AllocationType
        The type of allocation.

    product: Ref
        The output product (or waste input) to which this allocation factor is
        related. The must be an exchange with this product output (or waste
        input) in this process.

    value: float
        The value of the allocation factor.

    formula: str
        An optional formula from which the value of the allocation factor is
        calculated.

    exchange: ExchangeRef
        A product input, waste output, or elementary flow exchange which is
        allocated by this factor. This is only valid for causal allocation
        where allocation factors can be assigned to single exchanges.

    &#34;&#34;&#34;

    olca_type: str = &#39;AllocationFactor&#39;
    allocation_type: Optional[AllocationType] = None
    product: Optional[Ref] = None
    value: Optional[float] = None
    formula: Optional[str] = None
    exchange: Optional[ExchangeRef] = None

    def to_json(self) -&gt; dict:
        json: dict = super(AllocationFactor, self).to_json()
        if self.allocation_type is not None:
            json[&#39;allocationType&#39;] = self.allocation_type.value
        if self.product is not None:
            json[&#39;product&#39;] = self.product.to_json()
        if self.value is not None:
            json[&#39;value&#39;] = self.value
        if self.formula is not None:
            json[&#39;formula&#39;] = self.formula
        if self.exchange is not None:
            json[&#39;exchange&#39;] = self.exchange.to_json()
        return json

    def read_json(self, json: dict):
        super(AllocationFactor, self).read_json(json)
        val = json.get(&#39;allocationType&#39;)
        if val is not None:
            self.allocation_type = AllocationType(val)
        val = json.get(&#39;product&#39;)
        if val is not None:
            self.product = Ref()
            self.product.read_json(val)
        val = json.get(&#39;value&#39;)
        if val is not None:
            self.value = val
        val = json.get(&#39;formula&#39;)
        if val is not None:
            self.formula = val
        val = json.get(&#39;exchange&#39;)
        if val is not None:
            self.exchange = ExchangeRef()
            self.exchange.read_json(val)

    @staticmethod
    def from_json(json: dict):
        instance = AllocationFactor()
        instance.read_json(json)
        return instance


@dataclass
class CalculationSetup(Entity):
    &#34;&#34;&#34;
    A setup for a product system calculation.

    Attributes
    ----------
    calculation_type: CalculationType
        The type of calculation that should be performed.

    product_system: Ref
        The product system that should be calculated (required).

    impact_method: Ref
        The LCIA method for the calculation (optional).

    with_costs: bool
        Indicates whether life cycle costs should be also calculated
        (optional).

    with_regionalization: bool
        Indicates whether a regionalized result should be calculated or not. If
        this is set to true, the intervention matrix is indexed by (elementary
        flow, location) - pairs instead of just elementary flows. The LCI
        result then contains results for these pairs which can be then used in
        regionalized impact assessments.

    nw_set: Ref
        The normalisation and weighting set for the calculation (optional).

    allocation_method: AllocationType
        The calculation type to be used in the calculation (optional).

    parameter_redefs: list[ParameterRedef]
        A list of parameter redefinitions to be used in the calculation
        (optional).

    amount: float
        (optional)

    unit: Ref
        (optional)

    flow_property: Ref
        (optional)

    &#34;&#34;&#34;

    olca_type: str = &#39;CalculationSetup&#39;
    calculation_type: Optional[CalculationType] = None
    product_system: Optional[Ref] = None
    impact_method: Optional[Ref] = None
    with_costs: Optional[bool] = None
    with_regionalization: Optional[bool] = None
    nw_set: Optional[Ref] = None
    allocation_method: Optional[AllocationType] = None
    parameter_redefs: Optional[list[ParameterRedef]] = None
    amount: Optional[float] = None
    unit: Optional[Ref] = None
    flow_property: Optional[Ref] = None

    def to_json(self) -&gt; dict:
        json: dict = super(CalculationSetup, self).to_json()
        if self.calculation_type is not None:
            json[&#39;calculationType&#39;] = self.calculation_type.value
        if self.product_system is not None:
            json[&#39;productSystem&#39;] = self.product_system.to_json()
        if self.impact_method is not None:
            json[&#39;impactMethod&#39;] = self.impact_method.to_json()
        if self.with_costs is not None:
            json[&#39;withCosts&#39;] = self.with_costs
        if self.with_regionalization is not None:
            json[&#39;withRegionalization&#39;] = self.with_regionalization
        if self.nw_set is not None:
            json[&#39;nwSet&#39;] = self.nw_set.to_json()
        if self.allocation_method is not None:
            json[&#39;allocationMethod&#39;] = self.allocation_method.value
        if self.parameter_redefs is not None:
            json[&#39;parameterRedefs&#39;] = []
            for e in self.parameter_redefs:
                json[&#39;parameterRedefs&#39;].append(e.to_json())
        if self.amount is not None:
            json[&#39;amount&#39;] = self.amount
        if self.unit is not None:
            json[&#39;unit&#39;] = self.unit.to_json()
        if self.flow_property is not None:
            json[&#39;flowProperty&#39;] = self.flow_property.to_json()
        return json

    def read_json(self, json: dict):
        super(CalculationSetup, self).read_json(json)
        val = json.get(&#39;calculationType&#39;)
        if val is not None:
            self.calculation_type = CalculationType(val)
        val = json.get(&#39;productSystem&#39;)
        if val is not None:
            self.product_system = Ref()
            self.product_system.read_json(val)
        val = json.get(&#39;impactMethod&#39;)
        if val is not None:
            self.impact_method = Ref()
            self.impact_method.read_json(val)
        val = json.get(&#39;withCosts&#39;)
        if val is not None:
            self.with_costs = val
        val = json.get(&#39;withRegionalization&#39;)
        if val is not None:
            self.with_regionalization = val
        val = json.get(&#39;nwSet&#39;)
        if val is not None:
            self.nw_set = Ref()
            self.nw_set.read_json(val)
        val = json.get(&#39;allocationMethod&#39;)
        if val is not None:
            self.allocation_method = AllocationType(val)
        val = json.get(&#39;parameterRedefs&#39;)
        if val is not None:
            self.parameter_redefs = []
            for d in val:
                e = ParameterRedef()
                e.read_json(d)
                self.parameter_redefs.append(e)
        val = json.get(&#39;amount&#39;)
        if val is not None:
            self.amount = val
        val = json.get(&#39;unit&#39;)
        if val is not None:
            self.unit = Ref()
            self.unit.read_json(val)
        val = json.get(&#39;flowProperty&#39;)
        if val is not None:
            self.flow_property = Ref()
            self.flow_property.read_json(val)

    @staticmethod
    def from_json(json: dict):
        instance = CalculationSetup()
        instance.read_json(json)
        return instance


@dataclass
class DQIndicator(Entity):
    &#34;&#34;&#34;
    An indicator of a data quality system ([DQSystem]).

    Attributes
    ----------
    name: str

    position: int

    scores: list[DQScore]

    &#34;&#34;&#34;

    olca_type: str = &#39;DQIndicator&#39;
    name: Optional[str] = None
    position: Optional[int] = None
    scores: Optional[list[DQScore]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(DQIndicator, self).to_json()
        if self.name is not None:
            json[&#39;name&#39;] = self.name
        if self.position is not None:
            json[&#39;position&#39;] = self.position
        if self.scores is not None:
            json[&#39;scores&#39;] = []
            for e in self.scores:
                json[&#39;scores&#39;].append(e.to_json())
        return json

    def read_json(self, json: dict):
        super(DQIndicator, self).read_json(json)
        val = json.get(&#39;name&#39;)
        if val is not None:
            self.name = val
        val = json.get(&#39;position&#39;)
        if val is not None:
            self.position = val
        val = json.get(&#39;scores&#39;)
        if val is not None:
            self.scores = []
            for d in val:
                e = DQScore()
                e.read_json(d)
                self.scores.append(e)

    @staticmethod
    def from_json(json: dict):
        instance = DQIndicator()
        instance.read_json(json)
        return instance


@dataclass
class DQScore(Entity):
    &#34;&#34;&#34;
    An score value of an indicator ([DQIndicator]) in a data quality system
    ([DQSystem]).

    Attributes
    ----------
    position: int

    label: str

    description: str

    uncertainty: float

    &#34;&#34;&#34;

    olca_type: str = &#39;DQScore&#39;
    position: Optional[int] = None
    label: Optional[str] = None
    description: Optional[str] = None
    uncertainty: Optional[float] = None

    def to_json(self) -&gt; dict:
        json: dict = super(DQScore, self).to_json()
        if self.position is not None:
            json[&#39;position&#39;] = self.position
        if self.label is not None:
            json[&#39;label&#39;] = self.label
        if self.description is not None:
            json[&#39;description&#39;] = self.description
        if self.uncertainty is not None:
            json[&#39;uncertainty&#39;] = self.uncertainty
        return json

    def read_json(self, json: dict):
        super(DQScore, self).read_json(json)
        val = json.get(&#39;position&#39;)
        if val is not None:
            self.position = val
        val = json.get(&#39;label&#39;)
        if val is not None:
            self.label = val
        val = json.get(&#39;description&#39;)
        if val is not None:
            self.description = val
        val = json.get(&#39;uncertainty&#39;)
        if val is not None:
            self.uncertainty = val

    @staticmethod
    def from_json(json: dict):
        instance = DQScore()
        instance.read_json(json)
        return instance


@dataclass
class Exchange(Entity):
    &#34;&#34;&#34;
    An Exchange is an input or output of a [Flow] in a [Process]. The amount of
    an exchange is given in a specific unit of a quantity ([FlowProperty]) of
    the flow. The allowed units and flow properties that can be used for a flow
    in an exchange are defined by the flow property information in that flow
    (see also the [FlowPropertyFactor] type).

    Attributes
    ----------
    avoided_product: bool
        Indicates whether this exchange is an avoided product.

    cost_formula: str
        A formula for calculating the costs of this exchange.

    cost_value: float
        The costs of this exchange.

    currency: Ref
        The currency in which the costs of this exchange are given.

    internal_id: int
        The process internal ID of the exchange. This is used to identify
        exchanges unambiguously within a process (e.g. when linking exchanges
        in a product system where multiple exchanges with the same flow are
        allowed). The value should be &gt;= 1.

    flow: Ref
        The reference to the flow of the exchange.

    flow_property: Ref
        The quantity in which the amount is given.

    input: bool

    quantitative_reference: bool
        Indicates whether the exchange is the quantitative reference of the
        process.

    base_uncertainty: float

    default_provider: Ref
        A default provider is a [Process] that is linked as the provider of a
        product input or the waste treatment provider of a waste output. It is
        just an optional default setting which can be also ignored when
        building product systems in openLCA. The user is always free to link
        processes in product systems ignoring these defaults (but the flows and
        flow directions have to match of course).

    amount: float

    amount_formula: str

    unit: Ref

    dq_entry: str
        A data quality entry like `(1;3;2;5;1)`. The entry is a vector of data
        quality values that need to match the data quality scheme for flow
        inputs and outputs that is assigned to the [Process]. In such a scheme
        the data quality indicators have fixed positions and the respective
        values in the `dqEntry` vector map to these positions.

    uncertainty: Uncertainty

    description: str
        A general comment about the input or output.

    &#34;&#34;&#34;

    olca_type: str = &#39;Exchange&#39;
    avoided_product: Optional[bool] = None
    cost_formula: Optional[str] = None
    cost_value: Optional[float] = None
    currency: Optional[Ref] = None
    internal_id: Optional[int] = None
    flow: Optional[Ref] = None
    flow_property: Optional[Ref] = None
    input: Optional[bool] = None
    quantitative_reference: Optional[bool] = None
    base_uncertainty: Optional[float] = None
    default_provider: Optional[Ref] = None
    amount: Optional[float] = None
    amount_formula: Optional[str] = None
    unit: Optional[Ref] = None
    dq_entry: Optional[str] = None
    uncertainty: Optional[Uncertainty] = None
    description: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Exchange, self).to_json()
        if self.avoided_product is not None:
            json[&#39;avoidedProduct&#39;] = self.avoided_product
        if self.cost_formula is not None:
            json[&#39;costFormula&#39;] = self.cost_formula
        if self.cost_value is not None:
            json[&#39;costValue&#39;] = self.cost_value
        if self.currency is not None:
            json[&#39;currency&#39;] = self.currency.to_json()
        if self.internal_id is not None:
            json[&#39;internalId&#39;] = self.internal_id
        if self.flow is not None:
            json[&#39;flow&#39;] = self.flow.to_json()
        if self.flow_property is not None:
            json[&#39;flowProperty&#39;] = self.flow_property.to_json()
        if self.input is not None:
            json[&#39;input&#39;] = self.input
        if self.quantitative_reference is not None:
            json[&#39;quantitativeReference&#39;] = self.quantitative_reference
        if self.base_uncertainty is not None:
            json[&#39;baseUncertainty&#39;] = self.base_uncertainty
        if self.default_provider is not None:
            json[&#39;defaultProvider&#39;] = self.default_provider.to_json()
        if self.amount is not None:
            json[&#39;amount&#39;] = self.amount
        if self.amount_formula is not None:
            json[&#39;amountFormula&#39;] = self.amount_formula
        if self.unit is not None:
            json[&#39;unit&#39;] = self.unit.to_json()
        if self.dq_entry is not None:
            json[&#39;dqEntry&#39;] = self.dq_entry
        if self.uncertainty is not None:
            json[&#39;uncertainty&#39;] = self.uncertainty.to_json()
        if self.description is not None:
            json[&#39;description&#39;] = self.description
        return json

    def read_json(self, json: dict):
        super(Exchange, self).read_json(json)
        val = json.get(&#39;avoidedProduct&#39;)
        if val is not None:
            self.avoided_product = val
        val = json.get(&#39;costFormula&#39;)
        if val is not None:
            self.cost_formula = val
        val = json.get(&#39;costValue&#39;)
        if val is not None:
            self.cost_value = val
        val = json.get(&#39;currency&#39;)
        if val is not None:
            self.currency = Ref()
            self.currency.read_json(val)
        val = json.get(&#39;internalId&#39;)
        if val is not None:
            self.internal_id = val
        val = json.get(&#39;flow&#39;)
        if val is not None:
            self.flow = Ref()
            self.flow.read_json(val)
        val = json.get(&#39;flowProperty&#39;)
        if val is not None:
            self.flow_property = Ref()
            self.flow_property.read_json(val)
        val = json.get(&#39;input&#39;)
        if val is not None:
            self.input = val
        val = json.get(&#39;quantitativeReference&#39;)
        if val is not None:
            self.quantitative_reference = val
        val = json.get(&#39;baseUncertainty&#39;)
        if val is not None:
            self.base_uncertainty = val
        val = json.get(&#39;defaultProvider&#39;)
        if val is not None:
            self.default_provider = Ref()
            self.default_provider.read_json(val)
        val = json.get(&#39;amount&#39;)
        if val is not None:
            self.amount = val
        val = json.get(&#39;amountFormula&#39;)
        if val is not None:
            self.amount_formula = val
        val = json.get(&#39;unit&#39;)
        if val is not None:
            self.unit = Ref()
            self.unit.read_json(val)
        val = json.get(&#39;dqEntry&#39;)
        if val is not None:
            self.dq_entry = val
        val = json.get(&#39;uncertainty&#39;)
        if val is not None:
            self.uncertainty = Uncertainty()
            self.uncertainty.read_json(val)
        val = json.get(&#39;description&#39;)
        if val is not None:
            self.description = val

    @staticmethod
    def from_json(json: dict):
        instance = Exchange()
        instance.read_json(json)
        return instance


@dataclass
class ExchangeRef(Entity):
    &#34;&#34;&#34;
    An instance of this class describes a reference to an exchange in a
    process. When we reference such an exchange we only need the information to
    indentify that exchange unambiguously in a process.

    Attributes
    ----------
    internal_id: int
        The internal ID of the exchange.

    &#34;&#34;&#34;

    olca_type: str = &#39;ExchangeRef&#39;
    internal_id: Optional[int] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ExchangeRef, self).to_json()
        if self.internal_id is not None:
            json[&#39;internalId&#39;] = self.internal_id
        return json

    def read_json(self, json: dict):
        super(ExchangeRef, self).read_json(json)
        val = json.get(&#39;internalId&#39;)
        if val is not None:
            self.internal_id = val

    @staticmethod
    def from_json(json: dict):
        instance = ExchangeRef()
        instance.read_json(json)
        return instance


@dataclass
class FlowMapEntry(Entity):
    &#34;&#34;&#34;
    A mapping from a source flow to a target flow.

    Attributes
    ----------
    from_: FlowMapRef
        Describes the source flow of the mapping.

    to: FlowMapRef
        Describes the target of the mapping.

    conversion_factor: float
        The conversion factor to convert the amount of 1 unit of the source
        flow into the corresponding quantity of the target flow.

    &#34;&#34;&#34;

    olca_type: str = &#39;FlowMapEntry&#39;
    from_: Optional[FlowMapRef] = None
    to: Optional[FlowMapRef] = None
    conversion_factor: Optional[float] = None

    def to_json(self) -&gt; dict:
        json: dict = super(FlowMapEntry, self).to_json()
        if self.from_ is not None:
            json[&#39;from&#39;] = self.from_.to_json()
        if self.to is not None:
            json[&#39;to&#39;] = self.to.to_json()
        if self.conversion_factor is not None:
            json[&#39;conversionFactor&#39;] = self.conversion_factor
        return json

    def read_json(self, json: dict):
        super(FlowMapEntry, self).read_json(json)
        val = json.get(&#39;from&#39;)
        if val is not None:
            self.from_ = FlowMapRef()
            self.from_.read_json(val)
        val = json.get(&#39;to&#39;)
        if val is not None:
            self.to = FlowMapRef()
            self.to.read_json(val)
        val = json.get(&#39;conversionFactor&#39;)
        if val is not None:
            self.conversion_factor = val

    @staticmethod
    def from_json(json: dict):
        instance = FlowMapEntry()
        instance.read_json(json)
        return instance


@dataclass
class FlowMapRef(Entity):
    &#34;&#34;&#34;
    Describes a source or target flow in a `FlowMappingEntry` of a `FlowMap`.
    Such a flow reference can also optionally specify the unit and flow
    property (quantity) for which the mapping is valid. If the unit or quantity
    is not given, the mapping is based on the respective reference unit and
    reference flow property of the flow.

    Attributes
    ----------
    flow: Ref
        The reference to the flow data set.

    flow_property: Ref
        An optional reference to a flow property of the flow for which the
        mapping is valid.

    unit: Ref
        An optional reference to a unit of the flow for which the mapping is
        valid

    provider: Ref
        In case of a product or waste flow a flow mapping can contain a
        provider which is the process that produces the product or a waste
        treatment process that consumes the waste flow. This is useful when we
        want to apply mappings of product and waste flows on databases and link
        them in the corresponding processes and product systems.

    &#34;&#34;&#34;

    olca_type: str = &#39;FlowMapRef&#39;
    flow: Optional[Ref] = None
    flow_property: Optional[Ref] = None
    unit: Optional[Ref] = None
    provider: Optional[Ref] = None

    def to_json(self) -&gt; dict:
        json: dict = super(FlowMapRef, self).to_json()
        if self.flow is not None:
            json[&#39;flow&#39;] = self.flow.to_json()
        if self.flow_property is not None:
            json[&#39;flowProperty&#39;] = self.flow_property.to_json()
        if self.unit is not None:
            json[&#39;unit&#39;] = self.unit.to_json()
        if self.provider is not None:
            json[&#39;provider&#39;] = self.provider.to_json()
        return json

    def read_json(self, json: dict):
        super(FlowMapRef, self).read_json(json)
        val = json.get(&#39;flow&#39;)
        if val is not None:
            self.flow = Ref()
            self.flow.read_json(val)
        val = json.get(&#39;flowProperty&#39;)
        if val is not None:
            self.flow_property = Ref()
            self.flow_property.read_json(val)
        val = json.get(&#39;unit&#39;)
        if val is not None:
            self.unit = Ref()
            self.unit.read_json(val)
        val = json.get(&#39;provider&#39;)
        if val is not None:
            self.provider = Ref()
            self.provider.read_json(val)

    @staticmethod
    def from_json(json: dict):
        instance = FlowMapRef()
        instance.read_json(json)
        return instance


@dataclass
class FlowPropertyFactor(Entity):
    &#34;&#34;&#34;
    A FlowPropertyFactor is a conversion factor between &lt;a
    href=&#34;./FlowProperty.html&#34;&gt;flow properties (quantities)&lt;/a&gt; of a &lt;a
    href=&#34;./Flow.html&#34;&gt;flow&lt;/a&gt;. As an example the amount of the flow &#39;water&#39;
    in a process could be expressed in &#39;kg&#39; mass or &#39;m3&#39; volume. In this case
    the flow water would have two flow property factors: one for the flow
    property &#39;mass&#39; and one for &#39;volume&#39;. Each of these flow properties has a
    reference to a &lt;a href=&#34;./UnitGroup.html&#34;&gt;unit group&lt;/a&gt; which again has a
    reference unit. In the example the flow property &#39;mass&#39; could reference the
    unit group &#39;units of mass&#39; with &#39;kg&#39; as reference unit and volume could
    reference the unit group &#39;units of volume&#39; with &#39;m3&#39; as reference unit. The
    flow property factor is now the conversion factor between these two
    reference units where the factor of the reference flow property of the flow
    is 1. If the reference flow property of &#39;water&#39; in the example would be
    &#39;mass&#39; the respective flow property factor would be 1 and the factor for
    &#39;volume&#39; would be 0.001 (as 1 kg water is 0.001 m3). The amount of water in
    a process can now be also given in liter, tons, grams etc. For this, the
    unit conversion factor of the respective unit group can be used to convert
    into the reference unit (which then can be used to convert to the reference
    unit of another flow property). Another thing to note is that different
    flow properties can refer to the same unit group (e.g. MJ upper calorific
    value and MJ lower calorific value.)

    Attributes
    ----------
    flow_property: Ref
        The flow property (quantity) of the factor.

    conversion_factor: float
        The value of the conversion factor.

    reference_flow_property: bool
        Indicates whether the flow property of the factor is the reference flow
        property of the flow. The reference flow property must have a
        conversion factor of 1.0 and there should be only one reference flow
        property.

    &#34;&#34;&#34;

    olca_type: str = &#39;FlowPropertyFactor&#39;
    flow_property: Optional[Ref] = None
    conversion_factor: Optional[float] = None
    reference_flow_property: Optional[bool] = None

    def to_json(self) -&gt; dict:
        json: dict = super(FlowPropertyFactor, self).to_json()
        if self.flow_property is not None:
            json[&#39;flowProperty&#39;] = self.flow_property.to_json()
        if self.conversion_factor is not None:
            json[&#39;conversionFactor&#39;] = self.conversion_factor
        if self.reference_flow_property is not None:
            json[&#39;referenceFlowProperty&#39;] = self.reference_flow_property
        return json

    def read_json(self, json: dict):
        super(FlowPropertyFactor, self).read_json(json)
        val = json.get(&#39;flowProperty&#39;)
        if val is not None:
            self.flow_property = Ref()
            self.flow_property.read_json(val)
        val = json.get(&#39;conversionFactor&#39;)
        if val is not None:
            self.conversion_factor = val
        val = json.get(&#39;referenceFlowProperty&#39;)
        if val is not None:
            self.reference_flow_property = val

    @staticmethod
    def from_json(json: dict):
        instance = FlowPropertyFactor()
        instance.read_json(json)
        return instance


@dataclass
class FlowResult(Entity):
    &#34;&#34;&#34;
    A result value for a flow; given in the reference unit of the flow.

    Attributes
    ----------
    flow: Ref
        The flow reference.

    input: bool
        Indicates whether the flow is an input or not.

    value: float
        The value of the flow amount.

    location: Ref
        The (reference to the) location of this flow result in case of a
        regionalized result.

    &#34;&#34;&#34;

    olca_type: str = &#39;FlowResult&#39;
    flow: Optional[Ref] = None
    input: Optional[bool] = None
    value: Optional[float] = None
    location: Optional[Ref] = None

    def to_json(self) -&gt; dict:
        json: dict = super(FlowResult, self).to_json()
        if self.flow is not None:
            json[&#39;flow&#39;] = self.flow.to_json()
        if self.input is not None:
            json[&#39;input&#39;] = self.input
        if self.value is not None:
            json[&#39;value&#39;] = self.value
        if self.location is not None:
            json[&#39;location&#39;] = self.location.to_json()
        return json

    def read_json(self, json: dict):
        super(FlowResult, self).read_json(json)
        val = json.get(&#39;flow&#39;)
        if val is not None:
            self.flow = Ref()
            self.flow.read_json(val)
        val = json.get(&#39;input&#39;)
        if val is not None:
            self.input = val
        val = json.get(&#39;value&#39;)
        if val is not None:
            self.value = val
        val = json.get(&#39;location&#39;)
        if val is not None:
            self.location = Ref()
            self.location.read_json(val)

    @staticmethod
    def from_json(json: dict):
        instance = FlowResult()
        instance.read_json(json)
        return instance


@dataclass
class ImpactFactor(Entity):
    &#34;&#34;&#34;
    A single characterisation factor of a LCIA category for a flow.

    Attributes
    ----------
    flow: Ref
        The [Flow] of the impact assessment factor.

    location: Ref
        In case of a regionalized impact category, this field can contain the
        location for which this factor is valid.

    flow_property: Ref
        The quantity of the flow to which the LCIA factor is related (e.g.
        Mass).

    unit: Ref
        The flow unit to which the LCIA factor is related (e.g. kg).

    value: float
        The value of the impact assessment factor.

    formula: str
        A mathematical formula for calculating the value of the LCIA factor.

    uncertainty: Uncertainty
        The uncertainty distribution of the factors&#39; value.

    &#34;&#34;&#34;

    olca_type: str = &#39;ImpactFactor&#39;
    flow: Optional[Ref] = None
    location: Optional[Ref] = None
    flow_property: Optional[Ref] = None
    unit: Optional[Ref] = None
    value: Optional[float] = None
    formula: Optional[str] = None
    uncertainty: Optional[Uncertainty] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ImpactFactor, self).to_json()
        if self.flow is not None:
            json[&#39;flow&#39;] = self.flow.to_json()
        if self.location is not None:
            json[&#39;location&#39;] = self.location.to_json()
        if self.flow_property is not None:
            json[&#39;flowProperty&#39;] = self.flow_property.to_json()
        if self.unit is not None:
            json[&#39;unit&#39;] = self.unit.to_json()
        if self.value is not None:
            json[&#39;value&#39;] = self.value
        if self.formula is not None:
            json[&#39;formula&#39;] = self.formula
        if self.uncertainty is not None:
            json[&#39;uncertainty&#39;] = self.uncertainty.to_json()
        return json

    def read_json(self, json: dict):
        super(ImpactFactor, self).read_json(json)
        val = json.get(&#39;flow&#39;)
        if val is not None:
            self.flow = Ref()
            self.flow.read_json(val)
        val = json.get(&#39;location&#39;)
        if val is not None:
            self.location = Ref()
            self.location.read_json(val)
        val = json.get(&#39;flowProperty&#39;)
        if val is not None:
            self.flow_property = Ref()
            self.flow_property.read_json(val)
        val = json.get(&#39;unit&#39;)
        if val is not None:
            self.unit = Ref()
            self.unit.read_json(val)
        val = json.get(&#39;value&#39;)
        if val is not None:
            self.value = val
        val = json.get(&#39;formula&#39;)
        if val is not None:
            self.formula = val
        val = json.get(&#39;uncertainty&#39;)
        if val is not None:
            self.uncertainty = Uncertainty()
            self.uncertainty.read_json(val)

    @staticmethod
    def from_json(json: dict):
        instance = ImpactFactor()
        instance.read_json(json)
        return instance


@dataclass
class ImpactResult(Entity):
    &#34;&#34;&#34;
    A result value for an impact assessment category.

    Attributes
    ----------
    impact_category: Ref
        The reference to the impact assessment category.

    value: float
        The value of the flow amount.

    &#34;&#34;&#34;

    olca_type: str = &#39;ImpactResult&#39;
    impact_category: Optional[Ref] = None
    value: Optional[float] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ImpactResult, self).to_json()
        if self.impact_category is not None:
            json[&#39;impactCategory&#39;] = self.impact_category.to_json()
        if self.value is not None:
            json[&#39;value&#39;] = self.value
        return json

    def read_json(self, json: dict):
        super(ImpactResult, self).read_json(json)
        val = json.get(&#39;impactCategory&#39;)
        if val is not None:
            self.impact_category = Ref()
            self.impact_category.read_json(val)
        val = json.get(&#39;value&#39;)
        if val is not None:
            self.value = val

    @staticmethod
    def from_json(json: dict):
        instance = ImpactResult()
        instance.read_json(json)
        return instance


@dataclass
class NwFactor(Entity):
    &#34;&#34;&#34;
    A normalization and weighting factor of a [NwSet] related to an impact
    category. Depending on the purpose of the [NwSet] (normalization,
    weighting, or both) the normalization and weighting factor can be present
    or not.

    Attributes
    ----------
    impact_category: Ref

    normalisation_factor: float

    weighting_factor: float

    &#34;&#34;&#34;

    olca_type: str = &#39;NwFactor&#39;
    impact_category: Optional[Ref] = None
    normalisation_factor: Optional[float] = None
    weighting_factor: Optional[float] = None

    def to_json(self) -&gt; dict:
        json: dict = super(NwFactor, self).to_json()
        if self.impact_category is not None:
            json[&#39;impactCategory&#39;] = self.impact_category.to_json()
        if self.normalisation_factor is not None:
            json[&#39;normalisationFactor&#39;] = self.normalisation_factor
        if self.weighting_factor is not None:
            json[&#39;weightingFactor&#39;] = self.weighting_factor
        return json

    def read_json(self, json: dict):
        super(NwFactor, self).read_json(json)
        val = json.get(&#39;impactCategory&#39;)
        if val is not None:
            self.impact_category = Ref()
            self.impact_category.read_json(val)
        val = json.get(&#39;normalisationFactor&#39;)
        if val is not None:
            self.normalisation_factor = val
        val = json.get(&#39;weightingFactor&#39;)
        if val is not None:
            self.weighting_factor = val

    @staticmethod
    def from_json(json: dict):
        instance = NwFactor()
        instance.read_json(json)
        return instance


@dataclass
class ParameterRedef(Entity):
    &#34;&#34;&#34;
    A redefinition of a parameter in a product system.

    Attributes
    ----------
    context: Ref
        The context of the paramater (a process or LCIA method). If no context
        is provided it is assumed that this is a redefinition of a global
        parameter.

    description: str
        A description of this parameter redefinition.

    name: str
        The name of the redefined parameter. Note that parameter names are used
        in formulas so they need to follow specific syntax rules. A
        redefinition replaces a bound parameter in a specific context and thus
        has to exactly match the respective name.

    uncertainty: Uncertainty
        An uncertainty distribution for the redefined parameter value.

    value: float
        The value of the redefined parameter.

    &#34;&#34;&#34;

    olca_type: str = &#39;ParameterRedef&#39;
    context: Optional[Ref] = None
    description: Optional[str] = None
    name: Optional[str] = None
    uncertainty: Optional[Uncertainty] = None
    value: Optional[float] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ParameterRedef, self).to_json()
        if self.context is not None:
            json[&#39;context&#39;] = self.context.to_json()
        if self.description is not None:
            json[&#39;description&#39;] = self.description
        if self.name is not None:
            json[&#39;name&#39;] = self.name
        if self.uncertainty is not None:
            json[&#39;uncertainty&#39;] = self.uncertainty.to_json()
        if self.value is not None:
            json[&#39;value&#39;] = self.value
        return json

    def read_json(self, json: dict):
        super(ParameterRedef, self).read_json(json)
        val = json.get(&#39;context&#39;)
        if val is not None:
            self.context = Ref()
            self.context.read_json(val)
        val = json.get(&#39;description&#39;)
        if val is not None:
            self.description = val
        val = json.get(&#39;name&#39;)
        if val is not None:
            self.name = val
        val = json.get(&#39;uncertainty&#39;)
        if val is not None:
            self.uncertainty = Uncertainty()
            self.uncertainty.read_json(val)
        val = json.get(&#39;value&#39;)
        if val is not None:
            self.value = val

    @staticmethod
    def from_json(json: dict):
        instance = ParameterRedef()
        instance.read_json(json)
        return instance


@dataclass
class ParameterRedefSet(Entity):
    &#34;&#34;&#34;
    An instance of this class is just a set of parameter redefinitions attached
    to a product system. It can have a name and a description. One of the
    parameter sets can be defined as the baseline of the product system. In the
    calculation the baseline set is then taken by default.

    Attributes
    ----------
    name: str
        The name of the parameter set.

    description: str
        A description of the parameter set.

    is_baseline: bool
        Indicates if this set of parameter redefinitions is the baseline for a
        product system.

    parameters: list[ParameterRedef]
        The parameter redefinitions of this redefinition set.

    &#34;&#34;&#34;

    olca_type: str = &#39;ParameterRedefSet&#39;
    name: Optional[str] = None
    description: Optional[str] = None
    is_baseline: Optional[bool] = None
    parameters: Optional[list[ParameterRedef]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ParameterRedefSet, self).to_json()
        if self.name is not None:
            json[&#39;name&#39;] = self.name
        if self.description is not None:
            json[&#39;description&#39;] = self.description
        if self.is_baseline is not None:
            json[&#39;isBaseline&#39;] = self.is_baseline
        if self.parameters is not None:
            json[&#39;parameters&#39;] = []
            for e in self.parameters:
                json[&#39;parameters&#39;].append(e.to_json())
        return json

    def read_json(self, json: dict):
        super(ParameterRedefSet, self).read_json(json)
        val = json.get(&#39;name&#39;)
        if val is not None:
            self.name = val
        val = json.get(&#39;description&#39;)
        if val is not None:
            self.description = val
        val = json.get(&#39;isBaseline&#39;)
        if val is not None:
            self.is_baseline = val
        val = json.get(&#39;parameters&#39;)
        if val is not None:
            self.parameters = []
            for d in val:
                e = ParameterRedef()
                e.read_json(d)
                self.parameters.append(e)

    @staticmethod
    def from_json(json: dict):
        instance = ParameterRedefSet()
        instance.read_json(json)
        return instance


@dataclass
class ProcessDocumentation(Entity):
    &#34;&#34;&#34;


    Attributes
    ----------
    time_description: str

    valid_until: str

    valid_from: str

    technology_description: str

    data_collection_description: str

    completeness_description: str

    data_selection_description: str

    review_details: str

    data_treatment_description: str

    inventory_method_description: str

    modeling_constants_description: str

    reviewer: Ref

    sampling_description: str

    sources: list[Ref]

    restrictions_description: str

    copyright: bool

    creation_date: str

    data_documentor: Ref

    data_generator: Ref

    data_set_owner: Ref

    intended_application: str

    project_description: str

    publication: Ref

    geography_description: str

    &#34;&#34;&#34;

    olca_type: str = &#39;ProcessDocumentation&#39;
    time_description: Optional[str] = None
    valid_until: Optional[str] = None
    valid_from: Optional[str] = None
    technology_description: Optional[str] = None
    data_collection_description: Optional[str] = None
    completeness_description: Optional[str] = None
    data_selection_description: Optional[str] = None
    review_details: Optional[str] = None
    data_treatment_description: Optional[str] = None
    inventory_method_description: Optional[str] = None
    modeling_constants_description: Optional[str] = None
    reviewer: Optional[Ref] = None
    sampling_description: Optional[str] = None
    sources: Optional[list[Ref]] = None
    restrictions_description: Optional[str] = None
    copyright: Optional[bool] = None
    creation_date: Optional[str] = None
    data_documentor: Optional[Ref] = None
    data_generator: Optional[Ref] = None
    data_set_owner: Optional[Ref] = None
    intended_application: Optional[str] = None
    project_description: Optional[str] = None
    publication: Optional[Ref] = None
    geography_description: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ProcessDocumentation, self).to_json()
        if self.time_description is not None:
            json[&#39;timeDescription&#39;] = self.time_description
        if self.valid_until is not None:
            json[&#39;validUntil&#39;] = self.valid_until
        if self.valid_from is not None:
            json[&#39;validFrom&#39;] = self.valid_from
        if self.technology_description is not None:
            json[&#39;technologyDescription&#39;] = self.technology_description
        if self.data_collection_description is not None:
            json[&#39;dataCollectionDescription&#39;] = self.data_collection_description
        if self.completeness_description is not None:
            json[&#39;completenessDescription&#39;] = self.completeness_description
        if self.data_selection_description is not None:
            json[&#39;dataSelectionDescription&#39;] = self.data_selection_description
        if self.review_details is not None:
            json[&#39;reviewDetails&#39;] = self.review_details
        if self.data_treatment_description is not None:
            json[&#39;dataTreatmentDescription&#39;] = self.data_treatment_description
        if self.inventory_method_description is not None:
            json[&#39;inventoryMethodDescription&#39;] = self.inventory_method_description
        if self.modeling_constants_description is not None:
            json[&#39;modelingConstantsDescription&#39;] = self.modeling_constants_description
        if self.reviewer is not None:
            json[&#39;reviewer&#39;] = self.reviewer.to_json()
        if self.sampling_description is not None:
            json[&#39;samplingDescription&#39;] = self.sampling_description
        if self.sources is not None:
            json[&#39;sources&#39;] = []
            for e in self.sources:
                json[&#39;sources&#39;].append(e.to_json())
        if self.restrictions_description is not None:
            json[&#39;restrictionsDescription&#39;] = self.restrictions_description
        if self.copyright is not None:
            json[&#39;copyright&#39;] = self.copyright
        if self.creation_date is not None:
            json[&#39;creationDate&#39;] = self.creation_date
        if self.data_documentor is not None:
            json[&#39;dataDocumentor&#39;] = self.data_documentor.to_json()
        if self.data_generator is not None:
            json[&#39;dataGenerator&#39;] = self.data_generator.to_json()
        if self.data_set_owner is not None:
            json[&#39;dataSetOwner&#39;] = self.data_set_owner.to_json()
        if self.intended_application is not None:
            json[&#39;intendedApplication&#39;] = self.intended_application
        if self.project_description is not None:
            json[&#39;projectDescription&#39;] = self.project_description
        if self.publication is not None:
            json[&#39;publication&#39;] = self.publication.to_json()
        if self.geography_description is not None:
            json[&#39;geographyDescription&#39;] = self.geography_description
        return json

    def read_json(self, json: dict):
        super(ProcessDocumentation, self).read_json(json)
        val = json.get(&#39;timeDescription&#39;)
        if val is not None:
            self.time_description = val
        val = json.get(&#39;validUntil&#39;)
        if val is not None:
            self.valid_until = val
        val = json.get(&#39;validFrom&#39;)
        if val is not None:
            self.valid_from = val
        val = json.get(&#39;technologyDescription&#39;)
        if val is not None:
            self.technology_description = val
        val = json.get(&#39;dataCollectionDescription&#39;)
        if val is not None:
            self.data_collection_description = val
        val = json.get(&#39;completenessDescription&#39;)
        if val is not None:
            self.completeness_description = val
        val = json.get(&#39;dataSelectionDescription&#39;)
        if val is not None:
            self.data_selection_description = val
        val = json.get(&#39;reviewDetails&#39;)
        if val is not None:
            self.review_details = val
        val = json.get(&#39;dataTreatmentDescription&#39;)
        if val is not None:
            self.data_treatment_description = val
        val = json.get(&#39;inventoryMethodDescription&#39;)
        if val is not None:
            self.inventory_method_description = val
        val = json.get(&#39;modelingConstantsDescription&#39;)
        if val is not None:
            self.modeling_constants_description = val
        val = json.get(&#39;reviewer&#39;)
        if val is not None:
            self.reviewer = Ref()
            self.reviewer.read_json(val)
        val = json.get(&#39;samplingDescription&#39;)
        if val is not None:
            self.sampling_description = val
        val = json.get(&#39;sources&#39;)
        if val is not None:
            self.sources = []
            for d in val:
                e = Ref()
                e.read_json(d)
                self.sources.append(e)
        val = json.get(&#39;restrictionsDescription&#39;)
        if val is not None:
            self.restrictions_description = val
        val = json.get(&#39;copyright&#39;)
        if val is not None:
            self.copyright = val
        val = json.get(&#39;creationDate&#39;)
        if val is not None:
            self.creation_date = val
        val = json.get(&#39;dataDocumentor&#39;)
        if val is not None:
            self.data_documentor = Ref()
            self.data_documentor.read_json(val)
        val = json.get(&#39;dataGenerator&#39;)
        if val is not None:
            self.data_generator = Ref()
            self.data_generator.read_json(val)
        val = json.get(&#39;dataSetOwner&#39;)
        if val is not None:
            self.data_set_owner = Ref()
            self.data_set_owner.read_json(val)
        val = json.get(&#39;intendedApplication&#39;)
        if val is not None:
            self.intended_application = val
        val = json.get(&#39;projectDescription&#39;)
        if val is not None:
            self.project_description = val
        val = json.get(&#39;publication&#39;)
        if val is not None:
            self.publication = Ref()
            self.publication.read_json(val)
        val = json.get(&#39;geographyDescription&#39;)
        if val is not None:
            self.geography_description = val

    @staticmethod
    def from_json(json: dict):
        instance = ProcessDocumentation()
        instance.read_json(json)
        return instance


@dataclass
class ProcessLink(Entity):
    &#34;&#34;&#34;
    A process link is a connection between two processes in a product system.

    Attributes
    ----------
    provider: Ref
        The descriptor of the process or product system that provides a product
        or a waste treatment.

    flow: Ref
        The descriptor of the flow that is exchanged between the two processes.

    process: Ref
        The descriptor of the process that is linked to the provider.

    exchange: ExchangeRef
        The exchange of the linked process (this is useful if the linked
        process has multiple exchanges with the same flow that are linked to
        different provides, e.g. in an electricity mix).

    &#34;&#34;&#34;

    olca_type: str = &#39;ProcessLink&#39;
    provider: Optional[Ref] = None
    flow: Optional[Ref] = None
    process: Optional[Ref] = None
    exchange: Optional[ExchangeRef] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ProcessLink, self).to_json()
        if self.provider is not None:
            json[&#39;provider&#39;] = self.provider.to_json()
        if self.flow is not None:
            json[&#39;flow&#39;] = self.flow.to_json()
        if self.process is not None:
            json[&#39;process&#39;] = self.process.to_json()
        if self.exchange is not None:
            json[&#39;exchange&#39;] = self.exchange.to_json()
        return json

    def read_json(self, json: dict):
        super(ProcessLink, self).read_json(json)
        val = json.get(&#39;provider&#39;)
        if val is not None:
            self.provider = Ref()
            self.provider.read_json(val)
        val = json.get(&#39;flow&#39;)
        if val is not None:
            self.flow = Ref()
            self.flow.read_json(val)
        val = json.get(&#39;process&#39;)
        if val is not None:
            self.process = Ref()
            self.process.read_json(val)
        val = json.get(&#39;exchange&#39;)
        if val is not None:
            self.exchange = ExchangeRef()
            self.exchange.read_json(val)

    @staticmethod
    def from_json(json: dict):
        instance = ProcessLink()
        instance.read_json(json)
        return instance


@dataclass
class RootEntity(Entity):
    &#34;&#34;&#34;
    A standalone item in a database like a location, unit group, flow, or
    process. A root entity can be unambiguously identified by its id (the
    JSON-LD @id field), version, and lastChange fields.

    Attributes
    ----------
    name: str
        The name of the entity.

    description: str
        The description of the entity.

    version: str
        A version number in MAJOR.MINOR.PATCH format where the MINOR and PATCH
        fields are optional and the fields may have leading zeros (so 01.00.00
        is the same as 1.0.0 or 1).

    last_change: str
        The timestamp when the entity was changed the last time.

    &#34;&#34;&#34;

    name: Optional[str] = None
    description: Optional[str] = None
    version: Optional[str] = None
    last_change: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(RootEntity, self).to_json()
        if self.name is not None:
            json[&#39;name&#39;] = self.name
        if self.description is not None:
            json[&#39;description&#39;] = self.description
        if self.version is not None:
            json[&#39;version&#39;] = self.version
        if self.last_change is not None:
            json[&#39;lastChange&#39;] = self.last_change
        return json

    def read_json(self, json: dict):
        super(RootEntity, self).read_json(json)
        val = json.get(&#39;name&#39;)
        if val is not None:
            self.name = val
        val = json.get(&#39;description&#39;)
        if val is not None:
            self.description = val
        val = json.get(&#39;version&#39;)
        if val is not None:
            self.version = val
        val = json.get(&#39;lastChange&#39;)
        if val is not None:
            self.last_change = val

    @staticmethod
    def from_json(json: dict):
        instance = RootEntity()
        instance.read_json(json)
        return instance


@dataclass
class SimpleResult(Entity):
    &#34;&#34;&#34;


    Attributes
    ----------
    flow_results: list[FlowResult]

    impact_results: list[ImpactResult]

    &#34;&#34;&#34;

    olca_type: str = &#39;SimpleResult&#39;
    flow_results: Optional[list[FlowResult]] = None
    impact_results: Optional[list[ImpactResult]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(SimpleResult, self).to_json()
        if self.flow_results is not None:
            json[&#39;flowResults&#39;] = []
            for e in self.flow_results:
                json[&#39;flowResults&#39;].append(e.to_json())
        if self.impact_results is not None:
            json[&#39;impactResults&#39;] = []
            for e in self.impact_results:
                json[&#39;impactResults&#39;].append(e.to_json())
        return json

    def read_json(self, json: dict):
        super(SimpleResult, self).read_json(json)
        val = json.get(&#39;flowResults&#39;)
        if val is not None:
            self.flow_results = []
            for d in val:
                e = FlowResult()
                e.read_json(d)
                self.flow_results.append(e)
        val = json.get(&#39;impactResults&#39;)
        if val is not None:
            self.impact_results = []
            for d in val:
                e = ImpactResult()
                e.read_json(d)
                self.impact_results.append(e)

    @staticmethod
    def from_json(json: dict):
        instance = SimpleResult()
        instance.read_json(json)
        return instance


@dataclass
class SocialAspect(Entity):
    &#34;&#34;&#34;
    An instance of this class describes a social aspect related to a social
    indicator in a process.

    Attributes
    ----------
    activity_value: float
        The value of the activity variable of the related indicator.

    comment: str

    quality: str
        A data quality entry, e.g. `(3,1,2,4,1)`.

    raw_amount: str
        The raw amount of the indicator&#39;s unit of measurement (not required to
        be numeric currently)

    risk_level: RiskLevel

    social_indicator: Ref

    source: Ref

    &#34;&#34;&#34;

    olca_type: str = &#39;SocialAspect&#39;
    activity_value: Optional[float] = None
    comment: Optional[str] = None
    quality: Optional[str] = None
    raw_amount: Optional[str] = None
    risk_level: Optional[RiskLevel] = None
    social_indicator: Optional[Ref] = None
    source: Optional[Ref] = None

    def to_json(self) -&gt; dict:
        json: dict = super(SocialAspect, self).to_json()
        if self.activity_value is not None:
            json[&#39;activityValue&#39;] = self.activity_value
        if self.comment is not None:
            json[&#39;comment&#39;] = self.comment
        if self.quality is not None:
            json[&#39;quality&#39;] = self.quality
        if self.raw_amount is not None:
            json[&#39;rawAmount&#39;] = self.raw_amount
        if self.risk_level is not None:
            json[&#39;riskLevel&#39;] = self.risk_level.value
        if self.social_indicator is not None:
            json[&#39;socialIndicator&#39;] = self.social_indicator.to_json()
        if self.source is not None:
            json[&#39;source&#39;] = self.source.to_json()
        return json

    def read_json(self, json: dict):
        super(SocialAspect, self).read_json(json)
        val = json.get(&#39;activityValue&#39;)
        if val is not None:
            self.activity_value = val
        val = json.get(&#39;comment&#39;)
        if val is not None:
            self.comment = val
        val = json.get(&#39;quality&#39;)
        if val is not None:
            self.quality = val
        val = json.get(&#39;rawAmount&#39;)
        if val is not None:
            self.raw_amount = val
        val = json.get(&#39;riskLevel&#39;)
        if val is not None:
            self.risk_level = RiskLevel(val)
        val = json.get(&#39;socialIndicator&#39;)
        if val is not None:
            self.social_indicator = Ref()
            self.social_indicator.read_json(val)
        val = json.get(&#39;source&#39;)
        if val is not None:
            self.source = Ref()
            self.source.read_json(val)

    @staticmethod
    def from_json(json: dict):
        instance = SocialAspect()
        instance.read_json(json)
        return instance


@dataclass
class Uncertainty(Entity):
    &#34;&#34;&#34;
    Defines the parameter values of an uncertainty distribution. Depending on
    the uncertainty distribution type different parameters could be used.

    Attributes
    ----------
    distribution_type: UncertaintyType
        The uncertainty distribution type

    mean: float
        The arithmetic mean (used for normal distributions).

    mean_formula: str
        A mathematical formula for the arithmetic mean.

    geom_mean: float
        The geometric mean value (used for log-normal distributions).

    geom_mean_formula: str
        A mathematical formula for the geometric mean.

    minimum: float
        The minimum value (used for uniform and triangle distributions).

    minimum_formula: str
        A mathematical formula for the minimum value.

    sd: float
        The arithmetic standard deviation (used for normal distributions).

    sd_formula: str
        A mathematical formula for the arithmetic standard deviation.

    geom_sd: float
        The geometric standard deviation (used for log-normal distributions).

    geom_sd_formula: str
        A mathematical formula for the geometric standard deviation.

    mode: float
        The most likely value (used for triangle distributions).

    mode_formula: str
        A mathematical formula for the most likely value.

    maximum: float
        The maximum value (used for uniform and triangle distributions).

    maximum_formula: str
        A mathematical formula for the maximum value.

    &#34;&#34;&#34;

    olca_type: str = &#39;Uncertainty&#39;
    distribution_type: Optional[UncertaintyType] = None
    mean: Optional[float] = None
    mean_formula: Optional[str] = None
    geom_mean: Optional[float] = None
    geom_mean_formula: Optional[str] = None
    minimum: Optional[float] = None
    minimum_formula: Optional[str] = None
    sd: Optional[float] = None
    sd_formula: Optional[str] = None
    geom_sd: Optional[float] = None
    geom_sd_formula: Optional[str] = None
    mode: Optional[float] = None
    mode_formula: Optional[str] = None
    maximum: Optional[float] = None
    maximum_formula: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Uncertainty, self).to_json()
        if self.distribution_type is not None:
            json[&#39;distributionType&#39;] = self.distribution_type.value
        if self.mean is not None:
            json[&#39;mean&#39;] = self.mean
        if self.mean_formula is not None:
            json[&#39;meanFormula&#39;] = self.mean_formula
        if self.geom_mean is not None:
            json[&#39;geomMean&#39;] = self.geom_mean
        if self.geom_mean_formula is not None:
            json[&#39;geomMeanFormula&#39;] = self.geom_mean_formula
        if self.minimum is not None:
            json[&#39;minimum&#39;] = self.minimum
        if self.minimum_formula is not None:
            json[&#39;minimumFormula&#39;] = self.minimum_formula
        if self.sd is not None:
            json[&#39;sd&#39;] = self.sd
        if self.sd_formula is not None:
            json[&#39;sdFormula&#39;] = self.sd_formula
        if self.geom_sd is not None:
            json[&#39;geomSd&#39;] = self.geom_sd
        if self.geom_sd_formula is not None:
            json[&#39;geomSdFormula&#39;] = self.geom_sd_formula
        if self.mode is not None:
            json[&#39;mode&#39;] = self.mode
        if self.mode_formula is not None:
            json[&#39;modeFormula&#39;] = self.mode_formula
        if self.maximum is not None:
            json[&#39;maximum&#39;] = self.maximum
        if self.maximum_formula is not None:
            json[&#39;maximumFormula&#39;] = self.maximum_formula
        return json

    def read_json(self, json: dict):
        super(Uncertainty, self).read_json(json)
        val = json.get(&#39;distributionType&#39;)
        if val is not None:
            self.distribution_type = UncertaintyType(val)
        val = json.get(&#39;mean&#39;)
        if val is not None:
            self.mean = val
        val = json.get(&#39;meanFormula&#39;)
        if val is not None:
            self.mean_formula = val
        val = json.get(&#39;geomMean&#39;)
        if val is not None:
            self.geom_mean = val
        val = json.get(&#39;geomMeanFormula&#39;)
        if val is not None:
            self.geom_mean_formula = val
        val = json.get(&#39;minimum&#39;)
        if val is not None:
            self.minimum = val
        val = json.get(&#39;minimumFormula&#39;)
        if val is not None:
            self.minimum_formula = val
        val = json.get(&#39;sd&#39;)
        if val is not None:
            self.sd = val
        val = json.get(&#39;sdFormula&#39;)
        if val is not None:
            self.sd_formula = val
        val = json.get(&#39;geomSd&#39;)
        if val is not None:
            self.geom_sd = val
        val = json.get(&#39;geomSdFormula&#39;)
        if val is not None:
            self.geom_sd_formula = val
        val = json.get(&#39;mode&#39;)
        if val is not None:
            self.mode = val
        val = json.get(&#39;modeFormula&#39;)
        if val is not None:
            self.mode_formula = val
        val = json.get(&#39;maximum&#39;)
        if val is not None:
            self.maximum = val
        val = json.get(&#39;maximumFormula&#39;)
        if val is not None:
            self.maximum_formula = val

    @staticmethod
    def from_json(json: dict):
        instance = Uncertainty()
        instance.read_json(json)
        return instance


@dataclass
class CategorizedEntity(RootEntity):
    &#34;&#34;&#34;
    A root entity which can have a category.

    Attributes
    ----------
    category: Ref
        The category of the entity.

    tags: list[str]
        A list of optional tags. A tag is just a string which should not
        contain commas (and other special characters).

    library: str
        If this entity is part of a library, this field contains the identifier
        of that library. The identifier is typically just the combination of
        the library name and version.

    &#34;&#34;&#34;

    category: Optional[Ref] = None
    tags: Optional[list[str]] = None
    library: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(CategorizedEntity, self).to_json()
        if self.category is not None:
            json[&#39;category&#39;] = self.category.to_json()
        if self.tags is not None:
            json[&#39;tags&#39;] = []
            for e in self.tags:
                json[&#39;tags&#39;].append(e)
        if self.library is not None:
            json[&#39;library&#39;] = self.library
        return json

    def read_json(self, json: dict):
        super(CategorizedEntity, self).read_json(json)
        val = json.get(&#39;category&#39;)
        if val is not None:
            self.category = Ref()
            self.category.read_json(val)
        val = json.get(&#39;tags&#39;)
        if val is not None:
            self.tags = []
            for d in val:
                e = d
                self.tags.append(e)
        val = json.get(&#39;library&#39;)
        if val is not None:
            self.library = val

    @staticmethod
    def from_json(json: dict):
        instance = CategorizedEntity()
        instance.read_json(json)
        return instance


@dataclass
class FlowMap(RootEntity):
    &#34;&#34;&#34;
    A crosswalk of flows from a source flow list to a target flow list.

    Attributes
    ----------
    source: Ref
        The reference (id, name, description) of the source flow list.

    target: Ref
        The reference (id, name, description) of the target flow list.

    mappings: list[FlowMapEntry]
        A list of flow mappings from flows in a source flow list to flows in a
        target flow list.

    &#34;&#34;&#34;

    olca_type: str = &#39;FlowMap&#39;
    source: Optional[Ref] = None
    target: Optional[Ref] = None
    mappings: Optional[list[FlowMapEntry]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(FlowMap, self).to_json()
        if self.source is not None:
            json[&#39;source&#39;] = self.source.to_json()
        if self.target is not None:
            json[&#39;target&#39;] = self.target.to_json()
        if self.mappings is not None:
            json[&#39;mappings&#39;] = []
            for e in self.mappings:
                json[&#39;mappings&#39;].append(e.to_json())
        return json

    def read_json(self, json: dict):
        super(FlowMap, self).read_json(json)
        val = json.get(&#39;source&#39;)
        if val is not None:
            self.source = Ref()
            self.source.read_json(val)
        val = json.get(&#39;target&#39;)
        if val is not None:
            self.target = Ref()
            self.target.read_json(val)
        val = json.get(&#39;mappings&#39;)
        if val is not None:
            self.mappings = []
            for d in val:
                e = FlowMapEntry()
                e.read_json(d)
                self.mappings.append(e)

    @staticmethod
    def from_json(json: dict):
        instance = FlowMap()
        instance.read_json(json)
        return instance


@dataclass
class NwSet(RootEntity):
    &#34;&#34;&#34;
    A normalization and weighting set.

    Attributes
    ----------
    weighted_score_unit: str
        This is the optional unit of the (normalized and) weighted score when
        this normalization and weighting set was applied on a LCIA result.

    factors: list[NwFactor]
        The list of normalization and weighting factors of this set.

    &#34;&#34;&#34;

    olca_type: str = &#39;NwSet&#39;
    weighted_score_unit: Optional[str] = None
    factors: Optional[list[NwFactor]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(NwSet, self).to_json()
        if self.weighted_score_unit is not None:
            json[&#39;weightedScoreUnit&#39;] = self.weighted_score_unit
        if self.factors is not None:
            json[&#39;factors&#39;] = []
            for e in self.factors:
                json[&#39;factors&#39;].append(e.to_json())
        return json

    def read_json(self, json: dict):
        super(NwSet, self).read_json(json)
        val = json.get(&#39;weightedScoreUnit&#39;)
        if val is not None:
            self.weighted_score_unit = val
        val = json.get(&#39;factors&#39;)
        if val is not None:
            self.factors = []
            for d in val:
                e = NwFactor()
                e.read_json(d)
                self.factors.append(e)

    @staticmethod
    def from_json(json: dict):
        instance = NwSet()
        instance.read_json(json)
        return instance


@dataclass
class Ref(RootEntity):
    &#34;&#34;&#34;
    A Ref is a reference to a [RootEntity]. When serializing an entity (e.g. a
    [Process]) that references another standalone entity (e.g. a [Flow] in an
    [Exchange]) we do not want to write the complete referenced entity into the
    serialized JSON object but just a reference. However, the reference
    contains some meta-data like name, category path etc. that are useful to
    display.

    Attributes
    ----------
    category_path: list[str]
        The full path of the category of the referenced entity from top to
        bottom, e.g. `&#34;Elementary flows&#34;, &#34;Emissions to air&#34;, &#34;unspecified&#34;`.

    library: str
        If the entity that is described by this reference is part of a library,
        this field contains the identifier of that library. The identifier is
        typically just the combination of the library name and version.

    ref_unit: str
        This field is only valid for references of flows or impact categories
        and contains the name (symbol) of the reference unit of that respective
        flow or impact category.

    location: str
        This field is only valid for references of processes or flows and
        contains the location name or code of that respective process or flow.

    flow_type: FlowType
        In case of a reference to a flow, this field can contain the type of
        flow that is referenced.

    process_type: ProcessType
        In case of a reference to a process, this fiel can contain the type of
        process that is referenced.

    &#34;&#34;&#34;

    olca_type: str = &#39;Ref&#39;
    category_path: Optional[list[str]] = None
    library: Optional[str] = None
    ref_unit: Optional[str] = None
    location: Optional[str] = None
    flow_type: Optional[FlowType] = None
    process_type: Optional[ProcessType] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Ref, self).to_json()
        if self.category_path is not None:
            json[&#39;categoryPath&#39;] = []
            for e in self.category_path:
                json[&#39;categoryPath&#39;].append(e)
        if self.library is not None:
            json[&#39;library&#39;] = self.library
        if self.ref_unit is not None:
            json[&#39;refUnit&#39;] = self.ref_unit
        if self.location is not None:
            json[&#39;location&#39;] = self.location
        if self.flow_type is not None:
            json[&#39;flowType&#39;] = self.flow_type.value
        if self.process_type is not None:
            json[&#39;processType&#39;] = self.process_type.value
        return json

    def read_json(self, json: dict):
        super(Ref, self).read_json(json)
        val = json.get(&#39;categoryPath&#39;)
        if val is not None:
            self.category_path = []
            for d in val:
                e = d
                self.category_path.append(e)
        val = json.get(&#39;library&#39;)
        if val is not None:
            self.library = val
        val = json.get(&#39;refUnit&#39;)
        if val is not None:
            self.ref_unit = val
        val = json.get(&#39;location&#39;)
        if val is not None:
            self.location = val
        val = json.get(&#39;flowType&#39;)
        if val is not None:
            self.flow_type = FlowType(val)
        val = json.get(&#39;processType&#39;)
        if val is not None:
            self.process_type = ProcessType(val)

    @staticmethod
    def from_json(json: dict):
        instance = Ref()
        instance.read_json(json)
        return instance


@dataclass
class Unit(RootEntity):
    &#34;&#34;&#34;
    An unit of measure

    Attributes
    ----------
    conversion_factor: float
        The conversion factor to the reference unit of the unit group to which
        this unit belongs.

    reference_unit: bool
        Indicates whether the unit is the reference unit of the unit group to
        which this unit belongs. If it is the reference unit the conversion
        factor must be 1.0. There should be always only one reference unit in a
        unit group. The reference unit is used to convert amounts given in one
        unit to amounts given in another unit of the respective unit group.

    synonyms: list[str]
        A list of synonyms for the unit.

    &#34;&#34;&#34;

    olca_type: str = &#39;Unit&#39;
    conversion_factor: Optional[float] = None
    reference_unit: Optional[bool] = None
    synonyms: Optional[list[str]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Unit, self).to_json()
        if self.conversion_factor is not None:
            json[&#39;conversionFactor&#39;] = self.conversion_factor
        if self.reference_unit is not None:
            json[&#39;referenceUnit&#39;] = self.reference_unit
        if self.synonyms is not None:
            json[&#39;synonyms&#39;] = []
            for e in self.synonyms:
                json[&#39;synonyms&#39;].append(e)
        return json

    def read_json(self, json: dict):
        super(Unit, self).read_json(json)
        val = json.get(&#39;conversionFactor&#39;)
        if val is not None:
            self.conversion_factor = val
        val = json.get(&#39;referenceUnit&#39;)
        if val is not None:
            self.reference_unit = val
        val = json.get(&#39;synonyms&#39;)
        if val is not None:
            self.synonyms = []
            for d in val:
                e = d
                self.synonyms.append(e)

    @staticmethod
    def from_json(json: dict):
        instance = Unit()
        instance.read_json(json)
        return instance


@dataclass
class Actor(CategorizedEntity):
    &#34;&#34;&#34;
    An actor is a person or organisation.

    Attributes
    ----------
    address: str

    city: str

    country: str

    email: str

    telefax: str

    telephone: str

    website: str

    zip_code: str

    &#34;&#34;&#34;

    olca_type: str = &#39;Actor&#39;
    address: Optional[str] = None
    city: Optional[str] = None
    country: Optional[str] = None
    email: Optional[str] = None
    telefax: Optional[str] = None
    telephone: Optional[str] = None
    website: Optional[str] = None
    zip_code: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Actor, self).to_json()
        if self.address is not None:
            json[&#39;address&#39;] = self.address
        if self.city is not None:
            json[&#39;city&#39;] = self.city
        if self.country is not None:
            json[&#39;country&#39;] = self.country
        if self.email is not None:
            json[&#39;email&#39;] = self.email
        if self.telefax is not None:
            json[&#39;telefax&#39;] = self.telefax
        if self.telephone is not None:
            json[&#39;telephone&#39;] = self.telephone
        if self.website is not None:
            json[&#39;website&#39;] = self.website
        if self.zip_code is not None:
            json[&#39;zipCode&#39;] = self.zip_code
        return json

    def read_json(self, json: dict):
        super(Actor, self).read_json(json)
        val = json.get(&#39;address&#39;)
        if val is not None:
            self.address = val
        val = json.get(&#39;city&#39;)
        if val is not None:
            self.city = val
        val = json.get(&#39;country&#39;)
        if val is not None:
            self.country = val
        val = json.get(&#39;email&#39;)
        if val is not None:
            self.email = val
        val = json.get(&#39;telefax&#39;)
        if val is not None:
            self.telefax = val
        val = json.get(&#39;telephone&#39;)
        if val is not None:
            self.telephone = val
        val = json.get(&#39;website&#39;)
        if val is not None:
            self.website = val
        val = json.get(&#39;zipCode&#39;)
        if val is not None:
            self.zip_code = val

    @staticmethod
    def from_json(json: dict):
        instance = Actor()
        instance.read_json(json)
        return instance


@dataclass
class Category(CategorizedEntity):
    &#34;&#34;&#34;
    A category is used for the categorisation of types like processes, flows,
    etc. The tricky thing is that the `Category` class inherits also from the
    [CategorizedEntity] type so that a category can have a category attribute
    which is then the parent category of this category (uff).

    Attributes
    ----------
    model_type: ModelType
        The type of models that can be linked to the category.

    &#34;&#34;&#34;

    olca_type: str = &#39;Category&#39;
    model_type: Optional[ModelType] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Category, self).to_json()
        if self.model_type is not None:
            json[&#39;modelType&#39;] = self.model_type.value
        return json

    def read_json(self, json: dict):
        super(Category, self).read_json(json)
        val = json.get(&#39;modelType&#39;)
        if val is not None:
            self.model_type = ModelType(val)

    @staticmethod
    def from_json(json: dict):
        instance = Category()
        instance.read_json(json)
        return instance


@dataclass
class Currency(CategorizedEntity):
    &#34;&#34;&#34;


    Attributes
    ----------
    code: str

    conversion_factor: float

    reference_currency: Ref

    &#34;&#34;&#34;

    olca_type: str = &#39;Currency&#39;
    code: Optional[str] = None
    conversion_factor: Optional[float] = None
    reference_currency: Optional[Ref] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Currency, self).to_json()
        if self.code is not None:
            json[&#39;code&#39;] = self.code
        if self.conversion_factor is not None:
            json[&#39;conversionFactor&#39;] = self.conversion_factor
        if self.reference_currency is not None:
            json[&#39;referenceCurrency&#39;] = self.reference_currency.to_json()
        return json

    def read_json(self, json: dict):
        super(Currency, self).read_json(json)
        val = json.get(&#39;code&#39;)
        if val is not None:
            self.code = val
        val = json.get(&#39;conversionFactor&#39;)
        if val is not None:
            self.conversion_factor = val
        val = json.get(&#39;referenceCurrency&#39;)
        if val is not None:
            self.reference_currency = Ref()
            self.reference_currency.read_json(val)

    @staticmethod
    def from_json(json: dict):
        instance = Currency()
        instance.read_json(json)
        return instance


@dataclass
class DQSystem(CategorizedEntity):
    &#34;&#34;&#34;
    A data quality system (DQS) in openLCA describes a pedigree matrix of $m$
    data quality indicators (DQIs) and $n$ data quality scores (DQ scores).
    Such a system can then be used to assess the data quality of processes and
    exchanges by tagging them with an instance of the system $D$ where $D$ is a
    $m * n$ matrix with an entry $d_{ij}$ containing the value of the data
    quality score $j$ for indicator $i$. As each indicator in $D$ can only have
    a single score value, $D$ can be stored in a vector $d$ where $d_i$
    contains the data quality score for indicator $i$. The possible values of
    the data quality scores are defined as a linear order $1 \dots n$. In
    openLCA, the data quality entry $d$ of a process or exchange is stored as a
    string like `(3;2;4;n.a.;2)` which means the data quality score for the
    first indicator is `3`, for the second `2` etc. A specific value is `n.a.`
    which stands for _not applicable_. In calculations, these data quality
    entries can be aggregated in different ways. For example, the data quality
    entry of a flow $f$ with a contribution of `0.5 kg` and a data quality
    entry of `(3;2;4;n.a.;2)` in a process $p$ and a contribution of `1.5 kg`
    and a data quality entry of `(2;3;1;n.a.;5)` in a process $q$ could be
    aggregated to `(2;3;2;n.a.;4)` by applying an weighted average and
    rounding. Finally, custom labels like `A, B, C, ...` or `Very good, Good,
    Fair, ...` for the DQ scores can be assigned by the user. These labels are
    then displayed instead of `1, 2, 3 ...` in the user interface or result
    exports. However, internally the numeric values are used in the data model
    and calculations.

    Attributes
    ----------
    has_uncertainties: bool

    source: Ref

    indicators: list[DQIndicator]

    &#34;&#34;&#34;

    olca_type: str = &#39;DQSystem&#39;
    has_uncertainties: Optional[bool] = None
    source: Optional[Ref] = None
    indicators: Optional[list[DQIndicator]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(DQSystem, self).to_json()
        if self.has_uncertainties is not None:
            json[&#39;hasUncertainties&#39;] = self.has_uncertainties
        if self.source is not None:
            json[&#39;source&#39;] = self.source.to_json()
        if self.indicators is not None:
            json[&#39;indicators&#39;] = []
            for e in self.indicators:
                json[&#39;indicators&#39;].append(e.to_json())
        return json

    def read_json(self, json: dict):
        super(DQSystem, self).read_json(json)
        val = json.get(&#39;hasUncertainties&#39;)
        if val is not None:
            self.has_uncertainties = val
        val = json.get(&#39;source&#39;)
        if val is not None:
            self.source = Ref()
            self.source.read_json(val)
        val = json.get(&#39;indicators&#39;)
        if val is not None:
            self.indicators = []
            for d in val:
                e = DQIndicator()
                e.read_json(d)
                self.indicators.append(e)

    @staticmethod
    def from_json(json: dict):
        instance = DQSystem()
        instance.read_json(json)
        return instance


@dataclass
class Flow(CategorizedEntity):
    &#34;&#34;&#34;
    Everything that can be an input or output of a process (e.g. a substance, a
    product, a waste, a service etc.)

    Attributes
    ----------
    flow_type: FlowType
        The type of the flow. Note that this type is more a descriptor of how
        the flow is handled in calculations.

    cas: str
        A CAS number of the flow.

    formula: str
        A chemical formula of the flow.

    flow_properties: list[FlowPropertyFactor]
        The flow properties (quantities) in which amounts of the flow can be
        expressed together with conversion factors between these flow flow
        properties.

    location: Ref
        The location of the flow. Normally the location of a flow is defined by
        the process location where the flow is an input or output. However,
        some data formats define a location as a property of a flow.

    synonyms: str
        A list of synonyms but packed into a single field. Best is to use
        semicolons as separator as commas are sometimes used in names of
        chemicals.

    infrastructure_flow: bool
        Indicates whether this flow describes an infrastructure product. This
        field is part of the openLCA schema because of backward compatibility
        with EcoSpold 1. It does not really have a meaning in openLCA and
        should not be used anymore.

    &#34;&#34;&#34;

    olca_type: str = &#39;Flow&#39;
    flow_type: Optional[FlowType] = None
    cas: Optional[str] = None
    formula: Optional[str] = None
    flow_properties: Optional[list[FlowPropertyFactor]] = None
    location: Optional[Ref] = None
    synonyms: Optional[str] = None
    infrastructure_flow: Optional[bool] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Flow, self).to_json()
        if self.flow_type is not None:
            json[&#39;flowType&#39;] = self.flow_type.value
        if self.cas is not None:
            json[&#39;cas&#39;] = self.cas
        if self.formula is not None:
            json[&#39;formula&#39;] = self.formula
        if self.flow_properties is not None:
            json[&#39;flowProperties&#39;] = []
            for e in self.flow_properties:
                json[&#39;flowProperties&#39;].append(e.to_json())
        if self.location is not None:
            json[&#39;location&#39;] = self.location.to_json()
        if self.synonyms is not None:
            json[&#39;synonyms&#39;] = self.synonyms
        if self.infrastructure_flow is not None:
            json[&#39;infrastructureFlow&#39;] = self.infrastructure_flow
        return json

    def read_json(self, json: dict):
        super(Flow, self).read_json(json)
        val = json.get(&#39;flowType&#39;)
        if val is not None:
            self.flow_type = FlowType(val)
        val = json.get(&#39;cas&#39;)
        if val is not None:
            self.cas = val
        val = json.get(&#39;formula&#39;)
        if val is not None:
            self.formula = val
        val = json.get(&#39;flowProperties&#39;)
        if val is not None:
            self.flow_properties = []
            for d in val:
                e = FlowPropertyFactor()
                e.read_json(d)
                self.flow_properties.append(e)
        val = json.get(&#39;location&#39;)
        if val is not None:
            self.location = Ref()
            self.location.read_json(val)
        val = json.get(&#39;synonyms&#39;)
        if val is not None:
            self.synonyms = val
        val = json.get(&#39;infrastructureFlow&#39;)
        if val is not None:
            self.infrastructure_flow = val

    @staticmethod
    def from_json(json: dict):
        instance = Flow()
        instance.read_json(json)
        return instance


@dataclass
class FlowProperty(CategorizedEntity):
    &#34;&#34;&#34;
    A flow property is a quantity that can be used to express amounts of a
    flow.

    Attributes
    ----------
    flow_property_type: FlowPropertyType
        The type of the flow property

    unit_group: Ref
        The units of measure that can be used to express quantities of the flow
        property.

    &#34;&#34;&#34;

    olca_type: str = &#39;FlowProperty&#39;
    flow_property_type: Optional[FlowPropertyType] = None
    unit_group: Optional[Ref] = None

    def to_json(self) -&gt; dict:
        json: dict = super(FlowProperty, self).to_json()
        if self.flow_property_type is not None:
            json[&#39;flowPropertyType&#39;] = self.flow_property_type.value
        if self.unit_group is not None:
            json[&#39;unitGroup&#39;] = self.unit_group.to_json()
        return json

    def read_json(self, json: dict):
        super(FlowProperty, self).read_json(json)
        val = json.get(&#39;flowPropertyType&#39;)
        if val is not None:
            self.flow_property_type = FlowPropertyType(val)
        val = json.get(&#39;unitGroup&#39;)
        if val is not None:
            self.unit_group = Ref()
            self.unit_group.read_json(val)

    @staticmethod
    def from_json(json: dict):
        instance = FlowProperty()
        instance.read_json(json)
        return instance


@dataclass
class ImpactCategory(CategorizedEntity):
    &#34;&#34;&#34;


    Attributes
    ----------
    reference_unit_name: str
        The name of the reference unit of the LCIA category (e.g. kg CO2-eq.).

    parameters: list[Parameter]
        A set of parameters which can be used in formulas of the
        characterisation factors in this impact category.

    impact_factors: list[ImpactFactor]
        The characterisation factors of the LCIA category.

    &#34;&#34;&#34;

    olca_type: str = &#39;ImpactCategory&#39;
    reference_unit_name: Optional[str] = None
    parameters: Optional[list[Parameter]] = None
    impact_factors: Optional[list[ImpactFactor]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ImpactCategory, self).to_json()
        if self.reference_unit_name is not None:
            json[&#39;referenceUnitName&#39;] = self.reference_unit_name
        if self.parameters is not None:
            json[&#39;parameters&#39;] = []
            for e in self.parameters:
                json[&#39;parameters&#39;].append(e.to_json())
        if self.impact_factors is not None:
            json[&#39;impactFactors&#39;] = []
            for e in self.impact_factors:
                json[&#39;impactFactors&#39;].append(e.to_json())
        return json

    def read_json(self, json: dict):
        super(ImpactCategory, self).read_json(json)
        val = json.get(&#39;referenceUnitName&#39;)
        if val is not None:
            self.reference_unit_name = val
        val = json.get(&#39;parameters&#39;)
        if val is not None:
            self.parameters = []
            for d in val:
                e = Parameter()
                e.read_json(d)
                self.parameters.append(e)
        val = json.get(&#39;impactFactors&#39;)
        if val is not None:
            self.impact_factors = []
            for d in val:
                e = ImpactFactor()
                e.read_json(d)
                self.impact_factors.append(e)

    @staticmethod
    def from_json(json: dict):
        instance = ImpactCategory()
        instance.read_json(json)
        return instance


@dataclass
class ImpactMethod(CategorizedEntity):
    &#34;&#34;&#34;
    An impact assessment method.

    Attributes
    ----------
    impact_categories: list[Ref]
        The impact categories of the method.

    nw_sets: list[NwSet]
        The normalization and weighting sets of the method.

    &#34;&#34;&#34;

    olca_type: str = &#39;ImpactMethod&#39;
    impact_categories: Optional[list[Ref]] = None
    nw_sets: Optional[list[NwSet]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ImpactMethod, self).to_json()
        if self.impact_categories is not None:
            json[&#39;impactCategories&#39;] = []
            for e in self.impact_categories:
                json[&#39;impactCategories&#39;].append(e.to_json())
        if self.nw_sets is not None:
            json[&#39;nwSets&#39;] = []
            for e in self.nw_sets:
                json[&#39;nwSets&#39;].append(e.to_json())
        return json

    def read_json(self, json: dict):
        super(ImpactMethod, self).read_json(json)
        val = json.get(&#39;impactCategories&#39;)
        if val is not None:
            self.impact_categories = []
            for d in val:
                e = Ref()
                e.read_json(d)
                self.impact_categories.append(e)
        val = json.get(&#39;nwSets&#39;)
        if val is not None:
            self.nw_sets = []
            for d in val:
                e = NwSet()
                e.read_json(d)
                self.nw_sets.append(e)

    @staticmethod
    def from_json(json: dict):
        instance = ImpactMethod()
        instance.read_json(json)
        return instance


@dataclass
class Location(CategorizedEntity):
    &#34;&#34;&#34;
    A location like a country, state, city, etc.

    Attributes
    ----------
    code: str
        The code of the location (e.g. an ISO 2-letter country code).

    latitude: float
        The average latitude of the location.

    longitude: float
        The average longitude of the location.

    geometry: dict
        A GeoJSON object.

    &#34;&#34;&#34;

    olca_type: str = &#39;Location&#39;
    code: Optional[str] = None
    latitude: Optional[float] = None
    longitude: Optional[float] = None
    geometry: Optional[dict] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Location, self).to_json()
        if self.code is not None:
            json[&#39;code&#39;] = self.code
        if self.latitude is not None:
            json[&#39;latitude&#39;] = self.latitude
        if self.longitude is not None:
            json[&#39;longitude&#39;] = self.longitude
        if self.geometry is not None:
            json[&#39;geometry&#39;] = self.geometry
        return json

    def read_json(self, json: dict):
        super(Location, self).read_json(json)
        val = json.get(&#39;code&#39;)
        if val is not None:
            self.code = val
        val = json.get(&#39;latitude&#39;)
        if val is not None:
            self.latitude = val
        val = json.get(&#39;longitude&#39;)
        if val is not None:
            self.longitude = val
        val = json.get(&#39;geometry&#39;)
        if val is not None:
            self.geometry = val

    @staticmethod
    def from_json(json: dict):
        instance = Location()
        instance.read_json(json)
        return instance


@dataclass
class Parameter(CategorizedEntity):
    &#34;&#34;&#34;
    In openLCA, parameters can be defined in different scopes: global, process,
    or LCIA method. The parameter name can be used in formulas and, thus, need
    to conform to a specific syntax. Within a scope the parameter name should
    be unique (otherwise the evaluation is not deterministic). There are two
    types of parameters in openLCA: input parameters and dependent parameters.
    An input parameter can have an optional uncertainty distribution but not a
    formula. A dependent parameter can (should) have a formula (where also
    other parameters can be used) but no uncertainty distribution.

    Attributes
    ----------
    parameter_scope: ParameterScope
        The scope where the parameter is valid.

    input_parameter: bool
        Indicates whether the parameter is an input parameter (true) or a
        dependent/calculated parameter (false). A parameter can have a formula
        if it is not an input parameter.

    value: float
        The parameter value.

    formula: str
        A mathematical expression to calculate the parameter value.

    uncertainty: Uncertainty
        An uncertainty distribution of the parameter value. This is only valid
        for input parameters.

    &#34;&#34;&#34;

    olca_type: str = &#39;Parameter&#39;
    parameter_scope: Optional[ParameterScope] = None
    input_parameter: Optional[bool] = None
    value: Optional[float] = None
    formula: Optional[str] = None
    uncertainty: Optional[Uncertainty] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Parameter, self).to_json()
        if self.parameter_scope is not None:
            json[&#39;parameterScope&#39;] = self.parameter_scope.value
        if self.input_parameter is not None:
            json[&#39;inputParameter&#39;] = self.input_parameter
        if self.value is not None:
            json[&#39;value&#39;] = self.value
        if self.formula is not None:
            json[&#39;formula&#39;] = self.formula
        if self.uncertainty is not None:
            json[&#39;uncertainty&#39;] = self.uncertainty.to_json()
        return json

    def read_json(self, json: dict):
        super(Parameter, self).read_json(json)
        val = json.get(&#39;parameterScope&#39;)
        if val is not None:
            self.parameter_scope = ParameterScope(val)
        val = json.get(&#39;inputParameter&#39;)
        if val is not None:
            self.input_parameter = val
        val = json.get(&#39;value&#39;)
        if val is not None:
            self.value = val
        val = json.get(&#39;formula&#39;)
        if val is not None:
            self.formula = val
        val = json.get(&#39;uncertainty&#39;)
        if val is not None:
            self.uncertainty = Uncertainty()
            self.uncertainty.read_json(val)

    @staticmethod
    def from_json(json: dict):
        instance = Parameter()
        instance.read_json(json)
        return instance


@dataclass
class Process(CategorizedEntity):
    &#34;&#34;&#34;


    Attributes
    ----------
    allocation_factors: list[AllocationFactor]

    default_allocation_method: AllocationType

    exchanges: list[Exchange]
        The inputs and outputs of the process.

    last_internal_id: int
        This field holds the last internal ID that was used in an exchange
        (which may have been deleted, so it can be larger than the largest
        internal ID of the exchanges of the process.) The internal ID of an
        exchange is used to identify exchanges within a process (for updates,
        data exchanges (see process links), etc.). When you add an exchange to
        a process, you should increment this field in the process and set the
        resulting value as the internal ID of that exchange. The sequence of
        internal IDs should start with `1`.

    location: Ref
        The location of the process.

    parameters: list[Parameter]

    process_documentation: ProcessDocumentation

    process_type: ProcessType

    dq_system: Ref
        A reference to a data quality system ([DQSystem]) with which the
        overall quality of the process can be assessed.

    exchange_dq_system: Ref
        A reference to a data quality system ([DQSystem]) with which the
        quality of individual inputs and outputs ([Exchange]s) of the process
        can be assessed.

    social_dq_system: Ref
        A reference to a data quality system ([DQSystem]) with which the
        quality of individual social aspects of the process can be assessed.

    dq_entry: str
        A data quality entry like `(1;3;2;5;1)`. The entry is a vector of data
        quality values that need to match the overall data quality system of
        the process (the system that is stored in the `dqSystem` property). In
        such a system the data quality indicators have fixed positions and the
        respective values in the `dqEntry` vector map to these positions.

    infrastructure_process: bool
        Indicates whether this process describes an infrastructure process.
        This field is part of the openLCA schema because of backward
        compatibility with EcoSpold 1. It does not really have a meaning in
        openLCA and should not be used anymore.

    social_aspects: list[SocialAspect]
        A set of social aspects related to this process.

    &#34;&#34;&#34;

    olca_type: str = &#39;Process&#39;
    allocation_factors: Optional[list[AllocationFactor]] = None
    default_allocation_method: Optional[AllocationType] = None
    exchanges: Optional[list[Exchange]] = None
    last_internal_id: Optional[int] = None
    location: Optional[Ref] = None
    parameters: Optional[list[Parameter]] = None
    process_documentation: Optional[ProcessDocumentation] = None
    process_type: Optional[ProcessType] = None
    dq_system: Optional[Ref] = None
    exchange_dq_system: Optional[Ref] = None
    social_dq_system: Optional[Ref] = None
    dq_entry: Optional[str] = None
    infrastructure_process: Optional[bool] = None
    social_aspects: Optional[list[SocialAspect]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Process, self).to_json()
        if self.allocation_factors is not None:
            json[&#39;allocationFactors&#39;] = []
            for e in self.allocation_factors:
                json[&#39;allocationFactors&#39;].append(e.to_json())
        if self.default_allocation_method is not None:
            json[&#39;defaultAllocationMethod&#39;] = self.default_allocation_method.value
        if self.exchanges is not None:
            json[&#39;exchanges&#39;] = []
            for e in self.exchanges:
                json[&#39;exchanges&#39;].append(e.to_json())
        if self.last_internal_id is not None:
            json[&#39;lastInternalId&#39;] = self.last_internal_id
        if self.location is not None:
            json[&#39;location&#39;] = self.location.to_json()
        if self.parameters is not None:
            json[&#39;parameters&#39;] = []
            for e in self.parameters:
                json[&#39;parameters&#39;].append(e.to_json())
        if self.process_documentation is not None:
            json[&#39;processDocumentation&#39;] = self.process_documentation.to_json()
        if self.process_type is not None:
            json[&#39;processType&#39;] = self.process_type.value
        if self.dq_system is not None:
            json[&#39;dqSystem&#39;] = self.dq_system.to_json()
        if self.exchange_dq_system is not None:
            json[&#39;exchangeDqSystem&#39;] = self.exchange_dq_system.to_json()
        if self.social_dq_system is not None:
            json[&#39;socialDqSystem&#39;] = self.social_dq_system.to_json()
        if self.dq_entry is not None:
            json[&#39;dqEntry&#39;] = self.dq_entry
        if self.infrastructure_process is not None:
            json[&#39;infrastructureProcess&#39;] = self.infrastructure_process
        if self.social_aspects is not None:
            json[&#39;socialAspects&#39;] = []
            for e in self.social_aspects:
                json[&#39;socialAspects&#39;].append(e.to_json())
        return json

    def read_json(self, json: dict):
        super(Process, self).read_json(json)
        val = json.get(&#39;allocationFactors&#39;)
        if val is not None:
            self.allocation_factors = []
            for d in val:
                e = AllocationFactor()
                e.read_json(d)
                self.allocation_factors.append(e)
        val = json.get(&#39;defaultAllocationMethod&#39;)
        if val is not None:
            self.default_allocation_method = AllocationType(val)
        val = json.get(&#39;exchanges&#39;)
        if val is not None:
            self.exchanges = []
            for d in val:
                e = Exchange()
                e.read_json(d)
                self.exchanges.append(e)
        val = json.get(&#39;lastInternalId&#39;)
        if val is not None:
            self.last_internal_id = val
        val = json.get(&#39;location&#39;)
        if val is not None:
            self.location = Ref()
            self.location.read_json(val)
        val = json.get(&#39;parameters&#39;)
        if val is not None:
            self.parameters = []
            for d in val:
                e = Parameter()
                e.read_json(d)
                self.parameters.append(e)
        val = json.get(&#39;processDocumentation&#39;)
        if val is not None:
            self.process_documentation = ProcessDocumentation()
            self.process_documentation.read_json(val)
        val = json.get(&#39;processType&#39;)
        if val is not None:
            self.process_type = ProcessType(val)
        val = json.get(&#39;dqSystem&#39;)
        if val is not None:
            self.dq_system = Ref()
            self.dq_system.read_json(val)
        val = json.get(&#39;exchangeDqSystem&#39;)
        if val is not None:
            self.exchange_dq_system = Ref()
            self.exchange_dq_system.read_json(val)
        val = json.get(&#39;socialDqSystem&#39;)
        if val is not None:
            self.social_dq_system = Ref()
            self.social_dq_system.read_json(val)
        val = json.get(&#39;dqEntry&#39;)
        if val is not None:
            self.dq_entry = val
        val = json.get(&#39;infrastructureProcess&#39;)
        if val is not None:
            self.infrastructure_process = val
        val = json.get(&#39;socialAspects&#39;)
        if val is not None:
            self.social_aspects = []
            for d in val:
                e = SocialAspect()
                e.read_json(d)
                self.social_aspects.append(e)

    @staticmethod
    def from_json(json: dict):
        instance = Process()
        instance.read_json(json)
        return instance


@dataclass
class ProductSystem(CategorizedEntity):
    &#34;&#34;&#34;
    A product system describes the supply chain of a product (the functional
    unit) ...

    Attributes
    ----------
    processes: list[Ref]
        The descriptors of all processes and sub-systems that are contained in
        the product system.

    reference_process: Ref
        The descriptor of the process that provides the flow of the functional
        unit of the product system.

    reference_exchange: ExchangeRef
        The exchange of the reference processes (typically the product output)
        that provides the flow of the functional unit of the product system.

    target_amount: float
        The flow amount of the functional unit of the product system.

    target_unit: Ref
        The unit in which the flow amount of the functional unit is given.

    target_flow_property: Ref
        The flow property in which the flow amount of the functional unit is
        given.

    process_links: list[ProcessLink]
        The process links of the product system.

    parameter_sets: list[ParameterRedefSet]
        A list of possible sets of parameter redefinitions for this product
        system.

    &#34;&#34;&#34;

    olca_type: str = &#39;ProductSystem&#39;
    processes: Optional[list[Ref]] = None
    reference_process: Optional[Ref] = None
    reference_exchange: Optional[ExchangeRef] = None
    target_amount: Optional[float] = None
    target_unit: Optional[Ref] = None
    target_flow_property: Optional[Ref] = None
    process_links: Optional[list[ProcessLink]] = None
    parameter_sets: Optional[list[ParameterRedefSet]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ProductSystem, self).to_json()
        if self.processes is not None:
            json[&#39;processes&#39;] = []
            for e in self.processes:
                json[&#39;processes&#39;].append(e.to_json())
        if self.reference_process is not None:
            json[&#39;referenceProcess&#39;] = self.reference_process.to_json()
        if self.reference_exchange is not None:
            json[&#39;referenceExchange&#39;] = self.reference_exchange.to_json()
        if self.target_amount is not None:
            json[&#39;targetAmount&#39;] = self.target_amount
        if self.target_unit is not None:
            json[&#39;targetUnit&#39;] = self.target_unit.to_json()
        if self.target_flow_property is not None:
            json[&#39;targetFlowProperty&#39;] = self.target_flow_property.to_json()
        if self.process_links is not None:
            json[&#39;processLinks&#39;] = []
            for e in self.process_links:
                json[&#39;processLinks&#39;].append(e.to_json())
        if self.parameter_sets is not None:
            json[&#39;parameterSets&#39;] = []
            for e in self.parameter_sets:
                json[&#39;parameterSets&#39;].append(e.to_json())
        return json

    def read_json(self, json: dict):
        super(ProductSystem, self).read_json(json)
        val = json.get(&#39;processes&#39;)
        if val is not None:
            self.processes = []
            for d in val:
                e = Ref()
                e.read_json(d)
                self.processes.append(e)
        val = json.get(&#39;referenceProcess&#39;)
        if val is not None:
            self.reference_process = Ref()
            self.reference_process.read_json(val)
        val = json.get(&#39;referenceExchange&#39;)
        if val is not None:
            self.reference_exchange = ExchangeRef()
            self.reference_exchange.read_json(val)
        val = json.get(&#39;targetAmount&#39;)
        if val is not None:
            self.target_amount = val
        val = json.get(&#39;targetUnit&#39;)
        if val is not None:
            self.target_unit = Ref()
            self.target_unit.read_json(val)
        val = json.get(&#39;targetFlowProperty&#39;)
        if val is not None:
            self.target_flow_property = Ref()
            self.target_flow_property.read_json(val)
        val = json.get(&#39;processLinks&#39;)
        if val is not None:
            self.process_links = []
            for d in val:
                e = ProcessLink()
                e.read_json(d)
                self.process_links.append(e)
        val = json.get(&#39;parameterSets&#39;)
        if val is not None:
            self.parameter_sets = []
            for d in val:
                e = ParameterRedefSet()
                e.read_json(d)
                self.parameter_sets.append(e)

    @staticmethod
    def from_json(json: dict):
        instance = ProductSystem()
        instance.read_json(json)
        return instance


@dataclass
class Project(CategorizedEntity):
    &#34;&#34;&#34;


    Attributes
    ----------
    impact_method: Ref

    nw_set: NwSet

    &#34;&#34;&#34;

    olca_type: str = &#39;Project&#39;
    impact_method: Optional[Ref] = None
    nw_set: Optional[NwSet] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Project, self).to_json()
        if self.impact_method is not None:
            json[&#39;impactMethod&#39;] = self.impact_method.to_json()
        if self.nw_set is not None:
            json[&#39;nwSet&#39;] = self.nw_set.to_json()
        return json

    def read_json(self, json: dict):
        super(Project, self).read_json(json)
        val = json.get(&#39;impactMethod&#39;)
        if val is not None:
            self.impact_method = Ref()
            self.impact_method.read_json(val)
        val = json.get(&#39;nwSet&#39;)
        if val is not None:
            self.nw_set = NwSet()
            self.nw_set.read_json(val)

    @staticmethod
    def from_json(json: dict):
        instance = Project()
        instance.read_json(json)
        return instance


@dataclass
class SocialIndicator(CategorizedEntity):
    &#34;&#34;&#34;


    Attributes
    ----------
    activity_variable: str
        The name of the activity variable of the indicator.

    activity_quantity: Ref
        The quantity of the activity variable.

    activity_unit: Ref
        The unit of the activity variable.

    unit_of_measurement: str
        The unit in which the indicator is measured.

    evaluation_scheme: str
        Documentation of the evaluation scheme of the indicator.

    &#34;&#34;&#34;

    olca_type: str = &#39;SocialIndicator&#39;
    activity_variable: Optional[str] = None
    activity_quantity: Optional[Ref] = None
    activity_unit: Optional[Ref] = None
    unit_of_measurement: Optional[str] = None
    evaluation_scheme: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(SocialIndicator, self).to_json()
        if self.activity_variable is not None:
            json[&#39;activityVariable&#39;] = self.activity_variable
        if self.activity_quantity is not None:
            json[&#39;activityQuantity&#39;] = self.activity_quantity.to_json()
        if self.activity_unit is not None:
            json[&#39;activityUnit&#39;] = self.activity_unit.to_json()
        if self.unit_of_measurement is not None:
            json[&#39;unitOfMeasurement&#39;] = self.unit_of_measurement
        if self.evaluation_scheme is not None:
            json[&#39;evaluationScheme&#39;] = self.evaluation_scheme
        return json

    def read_json(self, json: dict):
        super(SocialIndicator, self).read_json(json)
        val = json.get(&#39;activityVariable&#39;)
        if val is not None:
            self.activity_variable = val
        val = json.get(&#39;activityQuantity&#39;)
        if val is not None:
            self.activity_quantity = Ref()
            self.activity_quantity.read_json(val)
        val = json.get(&#39;activityUnit&#39;)
        if val is not None:
            self.activity_unit = Ref()
            self.activity_unit.read_json(val)
        val = json.get(&#39;unitOfMeasurement&#39;)
        if val is not None:
            self.unit_of_measurement = val
        val = json.get(&#39;evaluationScheme&#39;)
        if val is not None:
            self.evaluation_scheme = val

    @staticmethod
    def from_json(json: dict):
        instance = SocialIndicator()
        instance.read_json(json)
        return instance


@dataclass
class Source(CategorizedEntity):
    &#34;&#34;&#34;
    A source is a literature reference.

    Attributes
    ----------
    url: str
        A URL that points to the source.

    text_reference: str
        The full text reference of the source.

    year: int
        The publication year of the source.

    external_file: str
        A direct link (relative or absolute URL) to the source file.

    &#34;&#34;&#34;

    olca_type: str = &#39;Source&#39;
    url: Optional[str] = None
    text_reference: Optional[str] = None
    year: Optional[int] = None
    external_file: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Source, self).to_json()
        if self.url is not None:
            json[&#39;url&#39;] = self.url
        if self.text_reference is not None:
            json[&#39;textReference&#39;] = self.text_reference
        if self.year is not None:
            json[&#39;year&#39;] = self.year
        if self.external_file is not None:
            json[&#39;externalFile&#39;] = self.external_file
        return json

    def read_json(self, json: dict):
        super(Source, self).read_json(json)
        val = json.get(&#39;url&#39;)
        if val is not None:
            self.url = val
        val = json.get(&#39;textReference&#39;)
        if val is not None:
            self.text_reference = val
        val = json.get(&#39;year&#39;)
        if val is not None:
            self.year = val
        val = json.get(&#39;externalFile&#39;)
        if val is not None:
            self.external_file = val

    @staticmethod
    def from_json(json: dict):
        instance = Source()
        instance.read_json(json)
        return instance


@dataclass
class UnitGroup(CategorizedEntity):
    &#34;&#34;&#34;
    A group of units that can be converted into each other.

    Attributes
    ----------
    default_flow_property: Ref
        Some LCA data formats do not have the concept of flow properties or
        quantities. This field provides a default link to a flow property for
        units that are contained in this group.

    units: list[Unit]
        The units of the unit group.

    &#34;&#34;&#34;

    olca_type: str = &#39;UnitGroup&#39;
    default_flow_property: Optional[Ref] = None
    units: Optional[list[Unit]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(UnitGroup, self).to_json()
        if self.default_flow_property is not None:
            json[&#39;defaultFlowProperty&#39;] = self.default_flow_property.to_json()
        if self.units is not None:
            json[&#39;units&#39;] = []
            for e in self.units:
                json[&#39;units&#39;].append(e.to_json())
        return json

    def read_json(self, json: dict):
        super(UnitGroup, self).read_json(json)
        val = json.get(&#39;defaultFlowProperty&#39;)
        if val is not None:
            self.default_flow_property = Ref()
            self.default_flow_property.read_json(val)
        val = json.get(&#39;units&#39;)
        if val is not None:
            self.units = []
            for d in val:
                e = Unit()
                e.read_json(d)
                self.units.append(e)

    @staticmethod
    def from_json(json: dict):
        instance = UnitGroup()
        instance.read_json(json)
        return instance</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="olca.schema.Actor"><code class="flex name class">
<span>class <span class="ident">Actor</span></span>
<span>(</span><span>id:str='', olca_type:str='Actor', name:Optional[str]=None, description:Optional[str]=None, version:Optional[str]=None, last_change:Optional[str]=None, category:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, tags:Optional[list[str]]=None, library:Optional[str]=None, address:Optional[str]=None, city:Optional[str]=None, country:Optional[str]=None, email:Optional[str]=None, telefax:Optional[str]=None, telephone:Optional[str]=None, website:Optional[str]=None, zip_code:Optional[str]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>An actor is a person or organisation.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>address</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>city</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>country</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>email</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>telefax</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>telephone</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>website</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>zip_code</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Actor(CategorizedEntity):
    &#34;&#34;&#34;
    An actor is a person or organisation.

    Attributes
    ----------
    address: str

    city: str

    country: str

    email: str

    telefax: str

    telephone: str

    website: str

    zip_code: str

    &#34;&#34;&#34;

    olca_type: str = &#39;Actor&#39;
    address: Optional[str] = None
    city: Optional[str] = None
    country: Optional[str] = None
    email: Optional[str] = None
    telefax: Optional[str] = None
    telephone: Optional[str] = None
    website: Optional[str] = None
    zip_code: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Actor, self).to_json()
        if self.address is not None:
            json[&#39;address&#39;] = self.address
        if self.city is not None:
            json[&#39;city&#39;] = self.city
        if self.country is not None:
            json[&#39;country&#39;] = self.country
        if self.email is not None:
            json[&#39;email&#39;] = self.email
        if self.telefax is not None:
            json[&#39;telefax&#39;] = self.telefax
        if self.telephone is not None:
            json[&#39;telephone&#39;] = self.telephone
        if self.website is not None:
            json[&#39;website&#39;] = self.website
        if self.zip_code is not None:
            json[&#39;zipCode&#39;] = self.zip_code
        return json

    def read_json(self, json: dict):
        super(Actor, self).read_json(json)
        val = json.get(&#39;address&#39;)
        if val is not None:
            self.address = val
        val = json.get(&#39;city&#39;)
        if val is not None:
            self.city = val
        val = json.get(&#39;country&#39;)
        if val is not None:
            self.country = val
        val = json.get(&#39;email&#39;)
        if val is not None:
            self.email = val
        val = json.get(&#39;telefax&#39;)
        if val is not None:
            self.telefax = val
        val = json.get(&#39;telephone&#39;)
        if val is not None:
            self.telephone = val
        val = json.get(&#39;website&#39;)
        if val is not None:
            self.website = val
        val = json.get(&#39;zipCode&#39;)
        if val is not None:
            self.zip_code = val

    @staticmethod
    def from_json(json: dict):
        instance = Actor()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.CategorizedEntity" href="#olca.schema.CategorizedEntity">CategorizedEntity</a></li>
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.Actor.address"><code class="name">var <span class="ident">address</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Actor.city"><code class="name">var <span class="ident">city</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Actor.country"><code class="name">var <span class="ident">country</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Actor.email"><code class="name">var <span class="ident">email</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Actor.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Actor.telefax"><code class="name">var <span class="ident">telefax</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Actor.telephone"><code class="name">var <span class="ident">telephone</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Actor.website"><code class="name">var <span class="ident">website</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Actor.zip_code"><code class="name">var <span class="ident">zip_code</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.Actor.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = Actor()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.Actor.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(Actor, self).read_json(json)
    val = json.get(&#39;address&#39;)
    if val is not None:
        self.address = val
    val = json.get(&#39;city&#39;)
    if val is not None:
        self.city = val
    val = json.get(&#39;country&#39;)
    if val is not None:
        self.country = val
    val = json.get(&#39;email&#39;)
    if val is not None:
        self.email = val
    val = json.get(&#39;telefax&#39;)
    if val is not None:
        self.telefax = val
    val = json.get(&#39;telephone&#39;)
    if val is not None:
        self.telephone = val
    val = json.get(&#39;website&#39;)
    if val is not None:
        self.website = val
    val = json.get(&#39;zipCode&#39;)
    if val is not None:
        self.zip_code = val</code></pre>
</details>
</dd>
<dt id="olca.schema.Actor.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(Actor, self).to_json()
    if self.address is not None:
        json[&#39;address&#39;] = self.address
    if self.city is not None:
        json[&#39;city&#39;] = self.city
    if self.country is not None:
        json[&#39;country&#39;] = self.country
    if self.email is not None:
        json[&#39;email&#39;] = self.email
    if self.telefax is not None:
        json[&#39;telefax&#39;] = self.telefax
    if self.telephone is not None:
        json[&#39;telephone&#39;] = self.telephone
    if self.website is not None:
        json[&#39;website&#39;] = self.website
    if self.zip_code is not None:
        json[&#39;zipCode&#39;] = self.zip_code
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.AllocationFactor"><code class="flex name class">
<span>class <span class="ident">AllocationFactor</span></span>
<span>(</span><span>id:str='', olca_type:str='AllocationFactor', allocation_type:Optional[<a title="olca.schema.AllocationType" href="#olca.schema.AllocationType">AllocationType</a>]=None, product:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, value:Optional[float]=None, formula:Optional[str]=None, exchange:Optional[<a title="olca.schema.ExchangeRef" href="#olca.schema.ExchangeRef">ExchangeRef</a>]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A single allocation factor in a process.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>allocation_type</code></strong> :&ensp;<code><a title="olca.schema.AllocationType" href="#olca.schema.AllocationType">AllocationType</a></code></dt>
<dd>The type of allocation.</dd>
<dt><strong><code>product</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The output product (or waste input) to which this allocation factor is
related. The must be an exchange with this product output (or waste
input) in this process.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value of the allocation factor.</dd>
<dt><strong><code>formula</code></strong> :&ensp;<code>str</code></dt>
<dd>An optional formula from which the value of the allocation factor is
calculated.</dd>
<dt><strong><code>exchange</code></strong> :&ensp;<code><a title="olca.schema.ExchangeRef" href="#olca.schema.ExchangeRef">ExchangeRef</a></code></dt>
<dd>A product input, waste output, or elementary flow exchange which is
allocated by this factor. This is only valid for causal allocation
where allocation factors can be assigned to single exchanges.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class AllocationFactor(Entity):
    &#34;&#34;&#34;
    A single allocation factor in a process.

    Attributes
    ----------
    allocation_type: AllocationType
        The type of allocation.

    product: Ref
        The output product (or waste input) to which this allocation factor is
        related. The must be an exchange with this product output (or waste
        input) in this process.

    value: float
        The value of the allocation factor.

    formula: str
        An optional formula from which the value of the allocation factor is
        calculated.

    exchange: ExchangeRef
        A product input, waste output, or elementary flow exchange which is
        allocated by this factor. This is only valid for causal allocation
        where allocation factors can be assigned to single exchanges.

    &#34;&#34;&#34;

    olca_type: str = &#39;AllocationFactor&#39;
    allocation_type: Optional[AllocationType] = None
    product: Optional[Ref] = None
    value: Optional[float] = None
    formula: Optional[str] = None
    exchange: Optional[ExchangeRef] = None

    def to_json(self) -&gt; dict:
        json: dict = super(AllocationFactor, self).to_json()
        if self.allocation_type is not None:
            json[&#39;allocationType&#39;] = self.allocation_type.value
        if self.product is not None:
            json[&#39;product&#39;] = self.product.to_json()
        if self.value is not None:
            json[&#39;value&#39;] = self.value
        if self.formula is not None:
            json[&#39;formula&#39;] = self.formula
        if self.exchange is not None:
            json[&#39;exchange&#39;] = self.exchange.to_json()
        return json

    def read_json(self, json: dict):
        super(AllocationFactor, self).read_json(json)
        val = json.get(&#39;allocationType&#39;)
        if val is not None:
            self.allocation_type = AllocationType(val)
        val = json.get(&#39;product&#39;)
        if val is not None:
            self.product = Ref()
            self.product.read_json(val)
        val = json.get(&#39;value&#39;)
        if val is not None:
            self.value = val
        val = json.get(&#39;formula&#39;)
        if val is not None:
            self.formula = val
        val = json.get(&#39;exchange&#39;)
        if val is not None:
            self.exchange = ExchangeRef()
            self.exchange.read_json(val)

    @staticmethod
    def from_json(json: dict):
        instance = AllocationFactor()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.AllocationFactor.allocation_type"><code class="name">var <span class="ident">allocation_type</span> :Optional[<a title="olca.schema.AllocationType" href="#olca.schema.AllocationType">AllocationType</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.AllocationFactor.exchange"><code class="name">var <span class="ident">exchange</span> :Optional[<a title="olca.schema.ExchangeRef" href="#olca.schema.ExchangeRef">ExchangeRef</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.AllocationFactor.formula"><code class="name">var <span class="ident">formula</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.AllocationFactor.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.AllocationFactor.product"><code class="name">var <span class="ident">product</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.AllocationFactor.value"><code class="name">var <span class="ident">value</span> :Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.AllocationFactor.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = AllocationFactor()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.AllocationFactor.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(AllocationFactor, self).read_json(json)
    val = json.get(&#39;allocationType&#39;)
    if val is not None:
        self.allocation_type = AllocationType(val)
    val = json.get(&#39;product&#39;)
    if val is not None:
        self.product = Ref()
        self.product.read_json(val)
    val = json.get(&#39;value&#39;)
    if val is not None:
        self.value = val
    val = json.get(&#39;formula&#39;)
    if val is not None:
        self.formula = val
    val = json.get(&#39;exchange&#39;)
    if val is not None:
        self.exchange = ExchangeRef()
        self.exchange.read_json(val)</code></pre>
</details>
</dd>
<dt id="olca.schema.AllocationFactor.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(AllocationFactor, self).to_json()
    if self.allocation_type is not None:
        json[&#39;allocationType&#39;] = self.allocation_type.value
    if self.product is not None:
        json[&#39;product&#39;] = self.product.to_json()
    if self.value is not None:
        json[&#39;value&#39;] = self.value
    if self.formula is not None:
        json[&#39;formula&#39;] = self.formula
    if self.exchange is not None:
        json[&#39;exchange&#39;] = self.exchange.to_json()
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.AllocationType"><code class="flex name class">
<span>class <span class="ident">AllocationType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration type for allocation methods. This type is used to define the
type of an [AllocationFactor], the default allocation method of a
multi-functional [Process], or the allocation method in a
[CalculationSetup].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AllocationType(Enum):
    &#34;&#34;&#34;
    An enumeration type for allocation methods. This type is used to define the
    type of an [AllocationFactor], the default allocation method of a
    multi-functional [Process], or the allocation method in a
    [CalculationSetup].
    &#34;&#34;&#34;

    PHYSICAL_ALLOCATION = &#39;PHYSICAL_ALLOCATION&#39;
    ECONOMIC_ALLOCATION = &#39;ECONOMIC_ALLOCATION&#39;
    CAUSAL_ALLOCATION = &#39;CAUSAL_ALLOCATION&#39;
    USE_DEFAULT_ALLOCATION = &#39;USE_DEFAULT_ALLOCATION&#39;
    NO_ALLOCATION = &#39;NO_ALLOCATION&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.AllocationType.CAUSAL_ALLOCATION"><code class="name">var <span class="ident">CAUSAL_ALLOCATION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.AllocationType.ECONOMIC_ALLOCATION"><code class="name">var <span class="ident">ECONOMIC_ALLOCATION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.AllocationType.NO_ALLOCATION"><code class="name">var <span class="ident">NO_ALLOCATION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.AllocationType.PHYSICAL_ALLOCATION"><code class="name">var <span class="ident">PHYSICAL_ALLOCATION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.AllocationType.USE_DEFAULT_ALLOCATION"><code class="name">var <span class="ident">USE_DEFAULT_ALLOCATION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="olca.schema.CalculationSetup"><code class="flex name class">
<span>class <span class="ident">CalculationSetup</span></span>
<span>(</span><span>id:str='', olca_type:str='CalculationSetup', calculation_type:Optional[<a title="olca.schema.CalculationType" href="#olca.schema.CalculationType">CalculationType</a>]=None, product_system:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, impact_method:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, with_costs:Optional[bool]=None, with_regionalization:Optional[bool]=None, nw_set:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, allocation_method:Optional[<a title="olca.schema.AllocationType" href="#olca.schema.AllocationType">AllocationType</a>]=None, parameter_redefs:Optional[list[<a title="olca.schema.ParameterRedef" href="#olca.schema.ParameterRedef">ParameterRedef</a>]]=None, amount:Optional[float]=None, unit:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, flow_property:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A setup for a product system calculation.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>calculation_type</code></strong> :&ensp;<code><a title="olca.schema.CalculationType" href="#olca.schema.CalculationType">CalculationType</a></code></dt>
<dd>The type of calculation that should be performed.</dd>
<dt><strong><code>product_system</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The product system that should be calculated (required).</dd>
<dt><strong><code>impact_method</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The LCIA method for the calculation (optional).</dd>
<dt><strong><code>with_costs</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates whether life cycle costs should be also calculated
(optional).</dd>
<dt><strong><code>with_regionalization</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates whether a regionalized result should be calculated or not. If
this is set to true, the intervention matrix is indexed by (elementary
flow, location) - pairs instead of just elementary flows. The LCI
result then contains results for these pairs which can be then used in
regionalized impact assessments.</dd>
<dt><strong><code>nw_set</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The normalisation and weighting set for the calculation (optional).</dd>
<dt><strong><code>allocation_method</code></strong> :&ensp;<code><a title="olca.schema.AllocationType" href="#olca.schema.AllocationType">AllocationType</a></code></dt>
<dd>The calculation type to be used in the calculation (optional).</dd>
<dt><strong><code>parameter_redefs</code></strong> :&ensp;<code>list[<a title="olca.schema.ParameterRedef" href="#olca.schema.ParameterRedef">ParameterRedef</a>]</code></dt>
<dd>A list of parameter redefinitions to be used in the calculation
(optional).</dd>
<dt><strong><code>amount</code></strong> :&ensp;<code>float</code></dt>
<dd>(optional)</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>(optional)</dd>
<dt><strong><code>flow_property</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>(optional)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class CalculationSetup(Entity):
    &#34;&#34;&#34;
    A setup for a product system calculation.

    Attributes
    ----------
    calculation_type: CalculationType
        The type of calculation that should be performed.

    product_system: Ref
        The product system that should be calculated (required).

    impact_method: Ref
        The LCIA method for the calculation (optional).

    with_costs: bool
        Indicates whether life cycle costs should be also calculated
        (optional).

    with_regionalization: bool
        Indicates whether a regionalized result should be calculated or not. If
        this is set to true, the intervention matrix is indexed by (elementary
        flow, location) - pairs instead of just elementary flows. The LCI
        result then contains results for these pairs which can be then used in
        regionalized impact assessments.

    nw_set: Ref
        The normalisation and weighting set for the calculation (optional).

    allocation_method: AllocationType
        The calculation type to be used in the calculation (optional).

    parameter_redefs: list[ParameterRedef]
        A list of parameter redefinitions to be used in the calculation
        (optional).

    amount: float
        (optional)

    unit: Ref
        (optional)

    flow_property: Ref
        (optional)

    &#34;&#34;&#34;

    olca_type: str = &#39;CalculationSetup&#39;
    calculation_type: Optional[CalculationType] = None
    product_system: Optional[Ref] = None
    impact_method: Optional[Ref] = None
    with_costs: Optional[bool] = None
    with_regionalization: Optional[bool] = None
    nw_set: Optional[Ref] = None
    allocation_method: Optional[AllocationType] = None
    parameter_redefs: Optional[list[ParameterRedef]] = None
    amount: Optional[float] = None
    unit: Optional[Ref] = None
    flow_property: Optional[Ref] = None

    def to_json(self) -&gt; dict:
        json: dict = super(CalculationSetup, self).to_json()
        if self.calculation_type is not None:
            json[&#39;calculationType&#39;] = self.calculation_type.value
        if self.product_system is not None:
            json[&#39;productSystem&#39;] = self.product_system.to_json()
        if self.impact_method is not None:
            json[&#39;impactMethod&#39;] = self.impact_method.to_json()
        if self.with_costs is not None:
            json[&#39;withCosts&#39;] = self.with_costs
        if self.with_regionalization is not None:
            json[&#39;withRegionalization&#39;] = self.with_regionalization
        if self.nw_set is not None:
            json[&#39;nwSet&#39;] = self.nw_set.to_json()
        if self.allocation_method is not None:
            json[&#39;allocationMethod&#39;] = self.allocation_method.value
        if self.parameter_redefs is not None:
            json[&#39;parameterRedefs&#39;] = []
            for e in self.parameter_redefs:
                json[&#39;parameterRedefs&#39;].append(e.to_json())
        if self.amount is not None:
            json[&#39;amount&#39;] = self.amount
        if self.unit is not None:
            json[&#39;unit&#39;] = self.unit.to_json()
        if self.flow_property is not None:
            json[&#39;flowProperty&#39;] = self.flow_property.to_json()
        return json

    def read_json(self, json: dict):
        super(CalculationSetup, self).read_json(json)
        val = json.get(&#39;calculationType&#39;)
        if val is not None:
            self.calculation_type = CalculationType(val)
        val = json.get(&#39;productSystem&#39;)
        if val is not None:
            self.product_system = Ref()
            self.product_system.read_json(val)
        val = json.get(&#39;impactMethod&#39;)
        if val is not None:
            self.impact_method = Ref()
            self.impact_method.read_json(val)
        val = json.get(&#39;withCosts&#39;)
        if val is not None:
            self.with_costs = val
        val = json.get(&#39;withRegionalization&#39;)
        if val is not None:
            self.with_regionalization = val
        val = json.get(&#39;nwSet&#39;)
        if val is not None:
            self.nw_set = Ref()
            self.nw_set.read_json(val)
        val = json.get(&#39;allocationMethod&#39;)
        if val is not None:
            self.allocation_method = AllocationType(val)
        val = json.get(&#39;parameterRedefs&#39;)
        if val is not None:
            self.parameter_redefs = []
            for d in val:
                e = ParameterRedef()
                e.read_json(d)
                self.parameter_redefs.append(e)
        val = json.get(&#39;amount&#39;)
        if val is not None:
            self.amount = val
        val = json.get(&#39;unit&#39;)
        if val is not None:
            self.unit = Ref()
            self.unit.read_json(val)
        val = json.get(&#39;flowProperty&#39;)
        if val is not None:
            self.flow_property = Ref()
            self.flow_property.read_json(val)

    @staticmethod
    def from_json(json: dict):
        instance = CalculationSetup()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.CalculationSetup.allocation_method"><code class="name">var <span class="ident">allocation_method</span> :Optional[<a title="olca.schema.AllocationType" href="#olca.schema.AllocationType">AllocationType</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.CalculationSetup.amount"><code class="name">var <span class="ident">amount</span> :Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.CalculationSetup.calculation_type"><code class="name">var <span class="ident">calculation_type</span> :Optional[<a title="olca.schema.CalculationType" href="#olca.schema.CalculationType">CalculationType</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.CalculationSetup.flow_property"><code class="name">var <span class="ident">flow_property</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.CalculationSetup.impact_method"><code class="name">var <span class="ident">impact_method</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.CalculationSetup.nw_set"><code class="name">var <span class="ident">nw_set</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.CalculationSetup.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.CalculationSetup.parameter_redefs"><code class="name">var <span class="ident">parameter_redefs</span> :Optional[list]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.CalculationSetup.product_system"><code class="name">var <span class="ident">product_system</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.CalculationSetup.unit"><code class="name">var <span class="ident">unit</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.CalculationSetup.with_costs"><code class="name">var <span class="ident">with_costs</span> :Optional[bool]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.CalculationSetup.with_regionalization"><code class="name">var <span class="ident">with_regionalization</span> :Optional[bool]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.CalculationSetup.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = CalculationSetup()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.CalculationSetup.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(CalculationSetup, self).read_json(json)
    val = json.get(&#39;calculationType&#39;)
    if val is not None:
        self.calculation_type = CalculationType(val)
    val = json.get(&#39;productSystem&#39;)
    if val is not None:
        self.product_system = Ref()
        self.product_system.read_json(val)
    val = json.get(&#39;impactMethod&#39;)
    if val is not None:
        self.impact_method = Ref()
        self.impact_method.read_json(val)
    val = json.get(&#39;withCosts&#39;)
    if val is not None:
        self.with_costs = val
    val = json.get(&#39;withRegionalization&#39;)
    if val is not None:
        self.with_regionalization = val
    val = json.get(&#39;nwSet&#39;)
    if val is not None:
        self.nw_set = Ref()
        self.nw_set.read_json(val)
    val = json.get(&#39;allocationMethod&#39;)
    if val is not None:
        self.allocation_method = AllocationType(val)
    val = json.get(&#39;parameterRedefs&#39;)
    if val is not None:
        self.parameter_redefs = []
        for d in val:
            e = ParameterRedef()
            e.read_json(d)
            self.parameter_redefs.append(e)
    val = json.get(&#39;amount&#39;)
    if val is not None:
        self.amount = val
    val = json.get(&#39;unit&#39;)
    if val is not None:
        self.unit = Ref()
        self.unit.read_json(val)
    val = json.get(&#39;flowProperty&#39;)
    if val is not None:
        self.flow_property = Ref()
        self.flow_property.read_json(val)</code></pre>
</details>
</dd>
<dt id="olca.schema.CalculationSetup.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(CalculationSetup, self).to_json()
    if self.calculation_type is not None:
        json[&#39;calculationType&#39;] = self.calculation_type.value
    if self.product_system is not None:
        json[&#39;productSystem&#39;] = self.product_system.to_json()
    if self.impact_method is not None:
        json[&#39;impactMethod&#39;] = self.impact_method.to_json()
    if self.with_costs is not None:
        json[&#39;withCosts&#39;] = self.with_costs
    if self.with_regionalization is not None:
        json[&#39;withRegionalization&#39;] = self.with_regionalization
    if self.nw_set is not None:
        json[&#39;nwSet&#39;] = self.nw_set.to_json()
    if self.allocation_method is not None:
        json[&#39;allocationMethod&#39;] = self.allocation_method.value
    if self.parameter_redefs is not None:
        json[&#39;parameterRedefs&#39;] = []
        for e in self.parameter_redefs:
            json[&#39;parameterRedefs&#39;].append(e.to_json())
    if self.amount is not None:
        json[&#39;amount&#39;] = self.amount
    if self.unit is not None:
        json[&#39;unit&#39;] = self.unit.to_json()
    if self.flow_property is not None:
        json[&#39;flowProperty&#39;] = self.flow_property.to_json()
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.CalculationType"><code class="flex name class">
<span>class <span class="ident">CalculationType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration of the different calculation methods supported by openLCA.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CalculationType(Enum):
    &#34;&#34;&#34;
    An enumeration of the different calculation methods supported by openLCA.
    &#34;&#34;&#34;

    SIMPLE_CALCULATION = &#39;SIMPLE_CALCULATION&#39;
    &#34;&#34;&#34;
    Calculates the total results for elementary flows, LCIA indicators, costs,
    etc. of a product system.
    &#34;&#34;&#34;

    CONTRIBUTION_ANALYSIS = &#39;CONTRIBUTION_ANALYSIS&#39;
    &#34;&#34;&#34;
    Includes the total result vectors of a simple calculation but calculates
    also the direct contributions of each process (or better process product in
    case of multi-output processes) to these total results.
    &#34;&#34;&#34;

    UPSTREAM_ANALYSIS = &#39;UPSTREAM_ANALYSIS&#39;
    &#34;&#34;&#34;
    Extends the contribution analysis by providing also the upstream results of
    each process (process product) in the product system. The upstream result
    contains the direct contributions of the respective process but also the
    result of the supply chain up to this process scaled to the demand of the
    process in the product system.
    &#34;&#34;&#34;

    REGIONALIZED_CALCULATION = &#39;REGIONALIZED_CALCULATION&#39;
    &#34;&#34;&#34;
    A regionalized calculation is a contribution analysis but with an LCIA
    method that supports regionalized characterization factors (via region
    specific parameters in formulas) and a product system with processes that
    have geographic information assigned (point, line, or polygon shapes).
    &#34;&#34;&#34;

    MONTE_CARLO_SIMULATION = &#39;MONTE_CARLO_SIMULATION&#39;
    &#34;&#34;&#34;
    A Monte Carlo simulation generates for each run, of a given number of a
    given number of iterations, random values according to the uncertainty
    distributions of process inputs/outputs, parameters, characterization
    factors, etc. of a product system and then performs a simple calculation
    for that specific run.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.CalculationType.CONTRIBUTION_ANALYSIS"><code class="name">var <span class="ident">CONTRIBUTION_ANALYSIS</span></code></dt>
<dd>
<div class="desc"><p>Includes the total result vectors of a simple calculation but calculates
also the direct contributions of each process (or better process product in
case of multi-output processes) to these total results.</p></div>
</dd>
<dt id="olca.schema.CalculationType.MONTE_CARLO_SIMULATION"><code class="name">var <span class="ident">MONTE_CARLO_SIMULATION</span></code></dt>
<dd>
<div class="desc"><p>A Monte Carlo simulation generates for each run, of a given number of a
given number of iterations, random values according to the uncertainty
distributions of process inputs/outputs, parameters, characterization
factors, etc. of a product system and then performs a simple calculation
for that specific run.</p></div>
</dd>
<dt id="olca.schema.CalculationType.REGIONALIZED_CALCULATION"><code class="name">var <span class="ident">REGIONALIZED_CALCULATION</span></code></dt>
<dd>
<div class="desc"><p>A regionalized calculation is a contribution analysis but with an LCIA
method that supports regionalized characterization factors (via region
specific parameters in formulas) and a product system with processes that
have geographic information assigned (point, line, or polygon shapes).</p></div>
</dd>
<dt id="olca.schema.CalculationType.SIMPLE_CALCULATION"><code class="name">var <span class="ident">SIMPLE_CALCULATION</span></code></dt>
<dd>
<div class="desc"><p>Calculates the total results for elementary flows, LCIA indicators, costs,
etc. of a product system.</p></div>
</dd>
<dt id="olca.schema.CalculationType.UPSTREAM_ANALYSIS"><code class="name">var <span class="ident">UPSTREAM_ANALYSIS</span></code></dt>
<dd>
<div class="desc"><p>Extends the contribution analysis by providing also the upstream results of
each process (process product) in the product system. The upstream result
contains the direct contributions of the respective process but also the
result of the supply chain up to this process scaled to the demand of the
process in the product system.</p></div>
</dd>
</dl>
</dd>
<dt id="olca.schema.CategorizedEntity"><code class="flex name class">
<span>class <span class="ident">CategorizedEntity</span></span>
<span>(</span><span>id:str='', olca_type:str='', name:Optional[str]=None, description:Optional[str]=None, version:Optional[str]=None, last_change:Optional[str]=None, category:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, tags:Optional[list[str]]=None, library:Optional[str]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A root entity which can have a category.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>category</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The category of the entity.</dd>
<dt><strong><code>tags</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>A list of optional tags. A tag is just a string which should not
contain commas (and other special characters).</dd>
<dt><strong><code>library</code></strong> :&ensp;<code>str</code></dt>
<dd>If this entity is part of a library, this field contains the identifier
of that library. The identifier is typically just the combination of
the library name and version.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class CategorizedEntity(RootEntity):
    &#34;&#34;&#34;
    A root entity which can have a category.

    Attributes
    ----------
    category: Ref
        The category of the entity.

    tags: list[str]
        A list of optional tags. A tag is just a string which should not
        contain commas (and other special characters).

    library: str
        If this entity is part of a library, this field contains the identifier
        of that library. The identifier is typically just the combination of
        the library name and version.

    &#34;&#34;&#34;

    category: Optional[Ref] = None
    tags: Optional[list[str]] = None
    library: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(CategorizedEntity, self).to_json()
        if self.category is not None:
            json[&#39;category&#39;] = self.category.to_json()
        if self.tags is not None:
            json[&#39;tags&#39;] = []
            for e in self.tags:
                json[&#39;tags&#39;].append(e)
        if self.library is not None:
            json[&#39;library&#39;] = self.library
        return json

    def read_json(self, json: dict):
        super(CategorizedEntity, self).read_json(json)
        val = json.get(&#39;category&#39;)
        if val is not None:
            self.category = Ref()
            self.category.read_json(val)
        val = json.get(&#39;tags&#39;)
        if val is not None:
            self.tags = []
            for d in val:
                e = d
                self.tags.append(e)
        val = json.get(&#39;library&#39;)
        if val is not None:
            self.library = val

    @staticmethod
    def from_json(json: dict):
        instance = CategorizedEntity()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="olca.schema.Actor" href="#olca.schema.Actor">Actor</a></li>
<li><a title="olca.schema.Category" href="#olca.schema.Category">Category</a></li>
<li><a title="olca.schema.Currency" href="#olca.schema.Currency">Currency</a></li>
<li><a title="olca.schema.DQSystem" href="#olca.schema.DQSystem">DQSystem</a></li>
<li><a title="olca.schema.Flow" href="#olca.schema.Flow">Flow</a></li>
<li><a title="olca.schema.FlowProperty" href="#olca.schema.FlowProperty">FlowProperty</a></li>
<li><a title="olca.schema.ImpactCategory" href="#olca.schema.ImpactCategory">ImpactCategory</a></li>
<li><a title="olca.schema.ImpactMethod" href="#olca.schema.ImpactMethod">ImpactMethod</a></li>
<li><a title="olca.schema.Location" href="#olca.schema.Location">Location</a></li>
<li><a title="olca.schema.Parameter" href="#olca.schema.Parameter">Parameter</a></li>
<li><a title="olca.schema.Process" href="#olca.schema.Process">Process</a></li>
<li><a title="olca.schema.ProductSystem" href="#olca.schema.ProductSystem">ProductSystem</a></li>
<li><a title="olca.schema.Project" href="#olca.schema.Project">Project</a></li>
<li><a title="olca.schema.SocialIndicator" href="#olca.schema.SocialIndicator">SocialIndicator</a></li>
<li><a title="olca.schema.Source" href="#olca.schema.Source">Source</a></li>
<li><a title="olca.schema.UnitGroup" href="#olca.schema.UnitGroup">UnitGroup</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.CategorizedEntity.category"><code class="name">var <span class="ident">category</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.CategorizedEntity.library"><code class="name">var <span class="ident">library</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.CategorizedEntity.tags"><code class="name">var <span class="ident">tags</span> :Optional[list]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.CategorizedEntity.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = CategorizedEntity()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.CategorizedEntity.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(CategorizedEntity, self).read_json(json)
    val = json.get(&#39;category&#39;)
    if val is not None:
        self.category = Ref()
        self.category.read_json(val)
    val = json.get(&#39;tags&#39;)
    if val is not None:
        self.tags = []
        for d in val:
            e = d
            self.tags.append(e)
    val = json.get(&#39;library&#39;)
    if val is not None:
        self.library = val</code></pre>
</details>
</dd>
<dt id="olca.schema.CategorizedEntity.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(CategorizedEntity, self).to_json()
    if self.category is not None:
        json[&#39;category&#39;] = self.category.to_json()
    if self.tags is not None:
        json[&#39;tags&#39;] = []
        for e in self.tags:
            json[&#39;tags&#39;].append(e)
    if self.library is not None:
        json[&#39;library&#39;] = self.library
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.Category"><code class="flex name class">
<span>class <span class="ident">Category</span></span>
<span>(</span><span>id:str='', olca_type:str='Category', name:Optional[str]=None, description:Optional[str]=None, version:Optional[str]=None, last_change:Optional[str]=None, category:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, tags:Optional[list[str]]=None, library:Optional[str]=None, model_type:Optional[<a title="olca.schema.ModelType" href="#olca.schema.ModelType">ModelType</a>]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A category is used for the categorisation of types like processes, flows,
etc. The tricky thing is that the <code><a title="olca.schema.Category" href="#olca.schema.Category">Category</a></code> class inherits also from the
[CategorizedEntity] type so that a category can have a category attribute
which is then the parent category of this category (uff).</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>model_type</code></strong> :&ensp;<code><a title="olca.schema.ModelType" href="#olca.schema.ModelType">ModelType</a></code></dt>
<dd>The type of models that can be linked to the category.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Category(CategorizedEntity):
    &#34;&#34;&#34;
    A category is used for the categorisation of types like processes, flows,
    etc. The tricky thing is that the `Category` class inherits also from the
    [CategorizedEntity] type so that a category can have a category attribute
    which is then the parent category of this category (uff).

    Attributes
    ----------
    model_type: ModelType
        The type of models that can be linked to the category.

    &#34;&#34;&#34;

    olca_type: str = &#39;Category&#39;
    model_type: Optional[ModelType] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Category, self).to_json()
        if self.model_type is not None:
            json[&#39;modelType&#39;] = self.model_type.value
        return json

    def read_json(self, json: dict):
        super(Category, self).read_json(json)
        val = json.get(&#39;modelType&#39;)
        if val is not None:
            self.model_type = ModelType(val)

    @staticmethod
    def from_json(json: dict):
        instance = Category()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.CategorizedEntity" href="#olca.schema.CategorizedEntity">CategorizedEntity</a></li>
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.Category.model_type"><code class="name">var <span class="ident">model_type</span> :Optional[<a title="olca.schema.ModelType" href="#olca.schema.ModelType">ModelType</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Category.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.Category.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = Category()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.Category.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(Category, self).read_json(json)
    val = json.get(&#39;modelType&#39;)
    if val is not None:
        self.model_type = ModelType(val)</code></pre>
</details>
</dd>
<dt id="olca.schema.Category.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(Category, self).to_json()
    if self.model_type is not None:
        json[&#39;modelType&#39;] = self.model_type.value
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.Currency"><code class="flex name class">
<span>class <span class="ident">Currency</span></span>
<span>(</span><span>id:str='', olca_type:str='Currency', name:Optional[str]=None, description:Optional[str]=None, version:Optional[str]=None, last_change:Optional[str]=None, category:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, tags:Optional[list[str]]=None, library:Optional[str]=None, code:Optional[str]=None, conversion_factor:Optional[float]=None, reference_currency:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>code</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>conversion_factor</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>reference_currency</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Currency(CategorizedEntity):
    &#34;&#34;&#34;


    Attributes
    ----------
    code: str

    conversion_factor: float

    reference_currency: Ref

    &#34;&#34;&#34;

    olca_type: str = &#39;Currency&#39;
    code: Optional[str] = None
    conversion_factor: Optional[float] = None
    reference_currency: Optional[Ref] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Currency, self).to_json()
        if self.code is not None:
            json[&#39;code&#39;] = self.code
        if self.conversion_factor is not None:
            json[&#39;conversionFactor&#39;] = self.conversion_factor
        if self.reference_currency is not None:
            json[&#39;referenceCurrency&#39;] = self.reference_currency.to_json()
        return json

    def read_json(self, json: dict):
        super(Currency, self).read_json(json)
        val = json.get(&#39;code&#39;)
        if val is not None:
            self.code = val
        val = json.get(&#39;conversionFactor&#39;)
        if val is not None:
            self.conversion_factor = val
        val = json.get(&#39;referenceCurrency&#39;)
        if val is not None:
            self.reference_currency = Ref()
            self.reference_currency.read_json(val)

    @staticmethod
    def from_json(json: dict):
        instance = Currency()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.CategorizedEntity" href="#olca.schema.CategorizedEntity">CategorizedEntity</a></li>
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.Currency.code"><code class="name">var <span class="ident">code</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Currency.conversion_factor"><code class="name">var <span class="ident">conversion_factor</span> :Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Currency.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Currency.reference_currency"><code class="name">var <span class="ident">reference_currency</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.Currency.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = Currency()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.Currency.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(Currency, self).read_json(json)
    val = json.get(&#39;code&#39;)
    if val is not None:
        self.code = val
    val = json.get(&#39;conversionFactor&#39;)
    if val is not None:
        self.conversion_factor = val
    val = json.get(&#39;referenceCurrency&#39;)
    if val is not None:
        self.reference_currency = Ref()
        self.reference_currency.read_json(val)</code></pre>
</details>
</dd>
<dt id="olca.schema.Currency.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(Currency, self).to_json()
    if self.code is not None:
        json[&#39;code&#39;] = self.code
    if self.conversion_factor is not None:
        json[&#39;conversionFactor&#39;] = self.conversion_factor
    if self.reference_currency is not None:
        json[&#39;referenceCurrency&#39;] = self.reference_currency.to_json()
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.DQIndicator"><code class="flex name class">
<span>class <span class="ident">DQIndicator</span></span>
<span>(</span><span>id:str='', olca_type:str='DQIndicator', name:Optional[str]=None, position:Optional[int]=None, scores:Optional[list[<a title="olca.schema.DQScore" href="#olca.schema.DQScore">DQScore</a>]]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>An indicator of a data quality system ([DQSystem]).</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>scores</code></strong> :&ensp;<code>list[<a title="olca.schema.DQScore" href="#olca.schema.DQScore">DQScore</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class DQIndicator(Entity):
    &#34;&#34;&#34;
    An indicator of a data quality system ([DQSystem]).

    Attributes
    ----------
    name: str

    position: int

    scores: list[DQScore]

    &#34;&#34;&#34;

    olca_type: str = &#39;DQIndicator&#39;
    name: Optional[str] = None
    position: Optional[int] = None
    scores: Optional[list[DQScore]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(DQIndicator, self).to_json()
        if self.name is not None:
            json[&#39;name&#39;] = self.name
        if self.position is not None:
            json[&#39;position&#39;] = self.position
        if self.scores is not None:
            json[&#39;scores&#39;] = []
            for e in self.scores:
                json[&#39;scores&#39;].append(e.to_json())
        return json

    def read_json(self, json: dict):
        super(DQIndicator, self).read_json(json)
        val = json.get(&#39;name&#39;)
        if val is not None:
            self.name = val
        val = json.get(&#39;position&#39;)
        if val is not None:
            self.position = val
        val = json.get(&#39;scores&#39;)
        if val is not None:
            self.scores = []
            for d in val:
                e = DQScore()
                e.read_json(d)
                self.scores.append(e)

    @staticmethod
    def from_json(json: dict):
        instance = DQIndicator()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.DQIndicator.name"><code class="name">var <span class="ident">name</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.DQIndicator.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.DQIndicator.position"><code class="name">var <span class="ident">position</span> :Optional[int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.DQIndicator.scores"><code class="name">var <span class="ident">scores</span> :Optional[list]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.DQIndicator.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = DQIndicator()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.DQIndicator.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(DQIndicator, self).read_json(json)
    val = json.get(&#39;name&#39;)
    if val is not None:
        self.name = val
    val = json.get(&#39;position&#39;)
    if val is not None:
        self.position = val
    val = json.get(&#39;scores&#39;)
    if val is not None:
        self.scores = []
        for d in val:
            e = DQScore()
            e.read_json(d)
            self.scores.append(e)</code></pre>
</details>
</dd>
<dt id="olca.schema.DQIndicator.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(DQIndicator, self).to_json()
    if self.name is not None:
        json[&#39;name&#39;] = self.name
    if self.position is not None:
        json[&#39;position&#39;] = self.position
    if self.scores is not None:
        json[&#39;scores&#39;] = []
        for e in self.scores:
            json[&#39;scores&#39;].append(e.to_json())
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.DQScore"><code class="flex name class">
<span>class <span class="ident">DQScore</span></span>
<span>(</span><span>id:str='', olca_type:str='DQScore', position:Optional[int]=None, label:Optional[str]=None, description:Optional[str]=None, uncertainty:Optional[float]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>An score value of an indicator ([DQIndicator]) in a data quality system
([DQSystem]).</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>label</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>uncertainty</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class DQScore(Entity):
    &#34;&#34;&#34;
    An score value of an indicator ([DQIndicator]) in a data quality system
    ([DQSystem]).

    Attributes
    ----------
    position: int

    label: str

    description: str

    uncertainty: float

    &#34;&#34;&#34;

    olca_type: str = &#39;DQScore&#39;
    position: Optional[int] = None
    label: Optional[str] = None
    description: Optional[str] = None
    uncertainty: Optional[float] = None

    def to_json(self) -&gt; dict:
        json: dict = super(DQScore, self).to_json()
        if self.position is not None:
            json[&#39;position&#39;] = self.position
        if self.label is not None:
            json[&#39;label&#39;] = self.label
        if self.description is not None:
            json[&#39;description&#39;] = self.description
        if self.uncertainty is not None:
            json[&#39;uncertainty&#39;] = self.uncertainty
        return json

    def read_json(self, json: dict):
        super(DQScore, self).read_json(json)
        val = json.get(&#39;position&#39;)
        if val is not None:
            self.position = val
        val = json.get(&#39;label&#39;)
        if val is not None:
            self.label = val
        val = json.get(&#39;description&#39;)
        if val is not None:
            self.description = val
        val = json.get(&#39;uncertainty&#39;)
        if val is not None:
            self.uncertainty = val

    @staticmethod
    def from_json(json: dict):
        instance = DQScore()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.DQScore.description"><code class="name">var <span class="ident">description</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.DQScore.label"><code class="name">var <span class="ident">label</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.DQScore.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.DQScore.position"><code class="name">var <span class="ident">position</span> :Optional[int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.DQScore.uncertainty"><code class="name">var <span class="ident">uncertainty</span> :Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.DQScore.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = DQScore()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.DQScore.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(DQScore, self).read_json(json)
    val = json.get(&#39;position&#39;)
    if val is not None:
        self.position = val
    val = json.get(&#39;label&#39;)
    if val is not None:
        self.label = val
    val = json.get(&#39;description&#39;)
    if val is not None:
        self.description = val
    val = json.get(&#39;uncertainty&#39;)
    if val is not None:
        self.uncertainty = val</code></pre>
</details>
</dd>
<dt id="olca.schema.DQScore.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(DQScore, self).to_json()
    if self.position is not None:
        json[&#39;position&#39;] = self.position
    if self.label is not None:
        json[&#39;label&#39;] = self.label
    if self.description is not None:
        json[&#39;description&#39;] = self.description
    if self.uncertainty is not None:
        json[&#39;uncertainty&#39;] = self.uncertainty
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.DQSystem"><code class="flex name class">
<span>class <span class="ident">DQSystem</span></span>
<span>(</span><span>id:str='', olca_type:str='DQSystem', name:Optional[str]=None, description:Optional[str]=None, version:Optional[str]=None, last_change:Optional[str]=None, category:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, tags:Optional[list[str]]=None, library:Optional[str]=None, has_uncertainties:Optional[bool]=None, source:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, indicators:Optional[list[<a title="olca.schema.DQIndicator" href="#olca.schema.DQIndicator">DQIndicator</a>]]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A data quality system (DQS) in openLCA describes a pedigree matrix of $m$
data quality indicators (DQIs) and $n$ data quality scores (DQ scores).
Such a system can then be used to assess the data quality of processes and
exchanges by tagging them with an instance of the system $D$ where $D$ is a
$m * n$ matrix with an entry $d_{ij}$ containing the value of the data
quality score $j$ for indicator $i$. As each indicator in $D$ can only have
a single score value, $D$ can be stored in a vector $d$ where $d_i$
contains the data quality score for indicator $i$. The possible values of
the data quality scores are defined as a linear order $1 \dots n$. In
openLCA, the data quality entry $d$ of a process or exchange is stored as a
string like <code>(3;2;4;n.a.;2)</code> which means the data quality score for the
first indicator is <code>3</code>, for the second <code>2</code> etc. A specific value is <code>n.a.</code>
which stands for <em>not applicable</em>. In calculations, these data quality
entries can be aggregated in different ways. For example, the data quality
entry of a flow $f$ with a contribution of <code>0.5 kg</code> and a data quality
entry of <code>(3;2;4;n.a.;2)</code> in a process $p$ and a contribution of <code>1.5 kg</code>
and a data quality entry of <code>(2;3;1;n.a.;5)</code> in a process $q$ could be
aggregated to <code>(2;3;2;n.a.;4)</code> by applying an weighted average and
rounding. Finally, custom labels like <code>A, B, C, &hellip;</code> or <code>Very good, Good,
Fair, ...</code> for the DQ scores can be assigned by the user. These labels are
then displayed instead of <code>1, 2, 3 &hellip;</code> in the user interface or result
exports. However, internally the numeric values are used in the data model
and calculations.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>has_uncertainties</code></strong> :&ensp;<code>bool</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>source</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>indicators</code></strong> :&ensp;<code>list[<a title="olca.schema.DQIndicator" href="#olca.schema.DQIndicator">DQIndicator</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class DQSystem(CategorizedEntity):
    &#34;&#34;&#34;
    A data quality system (DQS) in openLCA describes a pedigree matrix of $m$
    data quality indicators (DQIs) and $n$ data quality scores (DQ scores).
    Such a system can then be used to assess the data quality of processes and
    exchanges by tagging them with an instance of the system $D$ where $D$ is a
    $m * n$ matrix with an entry $d_{ij}$ containing the value of the data
    quality score $j$ for indicator $i$. As each indicator in $D$ can only have
    a single score value, $D$ can be stored in a vector $d$ where $d_i$
    contains the data quality score for indicator $i$. The possible values of
    the data quality scores are defined as a linear order $1 \dots n$. In
    openLCA, the data quality entry $d$ of a process or exchange is stored as a
    string like `(3;2;4;n.a.;2)` which means the data quality score for the
    first indicator is `3`, for the second `2` etc. A specific value is `n.a.`
    which stands for _not applicable_. In calculations, these data quality
    entries can be aggregated in different ways. For example, the data quality
    entry of a flow $f$ with a contribution of `0.5 kg` and a data quality
    entry of `(3;2;4;n.a.;2)` in a process $p$ and a contribution of `1.5 kg`
    and a data quality entry of `(2;3;1;n.a.;5)` in a process $q$ could be
    aggregated to `(2;3;2;n.a.;4)` by applying an weighted average and
    rounding. Finally, custom labels like `A, B, C, ...` or `Very good, Good,
    Fair, ...` for the DQ scores can be assigned by the user. These labels are
    then displayed instead of `1, 2, 3 ...` in the user interface or result
    exports. However, internally the numeric values are used in the data model
    and calculations.

    Attributes
    ----------
    has_uncertainties: bool

    source: Ref

    indicators: list[DQIndicator]

    &#34;&#34;&#34;

    olca_type: str = &#39;DQSystem&#39;
    has_uncertainties: Optional[bool] = None
    source: Optional[Ref] = None
    indicators: Optional[list[DQIndicator]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(DQSystem, self).to_json()
        if self.has_uncertainties is not None:
            json[&#39;hasUncertainties&#39;] = self.has_uncertainties
        if self.source is not None:
            json[&#39;source&#39;] = self.source.to_json()
        if self.indicators is not None:
            json[&#39;indicators&#39;] = []
            for e in self.indicators:
                json[&#39;indicators&#39;].append(e.to_json())
        return json

    def read_json(self, json: dict):
        super(DQSystem, self).read_json(json)
        val = json.get(&#39;hasUncertainties&#39;)
        if val is not None:
            self.has_uncertainties = val
        val = json.get(&#39;source&#39;)
        if val is not None:
            self.source = Ref()
            self.source.read_json(val)
        val = json.get(&#39;indicators&#39;)
        if val is not None:
            self.indicators = []
            for d in val:
                e = DQIndicator()
                e.read_json(d)
                self.indicators.append(e)

    @staticmethod
    def from_json(json: dict):
        instance = DQSystem()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.CategorizedEntity" href="#olca.schema.CategorizedEntity">CategorizedEntity</a></li>
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.DQSystem.has_uncertainties"><code class="name">var <span class="ident">has_uncertainties</span> :Optional[bool]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.DQSystem.indicators"><code class="name">var <span class="ident">indicators</span> :Optional[list]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.DQSystem.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.DQSystem.source"><code class="name">var <span class="ident">source</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.DQSystem.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = DQSystem()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.DQSystem.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(DQSystem, self).read_json(json)
    val = json.get(&#39;hasUncertainties&#39;)
    if val is not None:
        self.has_uncertainties = val
    val = json.get(&#39;source&#39;)
    if val is not None:
        self.source = Ref()
        self.source.read_json(val)
    val = json.get(&#39;indicators&#39;)
    if val is not None:
        self.indicators = []
        for d in val:
            e = DQIndicator()
            e.read_json(d)
            self.indicators.append(e)</code></pre>
</details>
</dd>
<dt id="olca.schema.DQSystem.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(DQSystem, self).to_json()
    if self.has_uncertainties is not None:
        json[&#39;hasUncertainties&#39;] = self.has_uncertainties
    if self.source is not None:
        json[&#39;source&#39;] = self.source.to_json()
    if self.indicators is not None:
        json[&#39;indicators&#39;] = []
        for e in self.indicators:
            json[&#39;indicators&#39;].append(e.to_json())
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.Entity"><code class="flex name class">
<span>class <span class="ident">Entity</span></span>
<span>(</span><span>id:str='', olca_type:str='')</span>
</code></dt>
<dd>
<div class="desc"><p>The most generic type of the openLCA data model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Entity(object):
    &#34;&#34;&#34;
    The most generic type of the openLCA data model.
    &#34;&#34;&#34;

    id: str = &#39;&#39;
    olca_type: str = &#39;&#39;

    def _repr_html_(self):
        code = jsonlib.dumps(self.to_json(), indent=2, sort_keys=True)
        if len(code) &gt; 10000:
            code = code[0:10000] + &#39;...&#39;
        return f&#39;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{code}&lt;/code&gt;&lt;/pre&gt;&#39;
        
    def to_json(self) -&gt; dict:
        o_type = self.olca_type
        if o_type is None:
            o_type = type(self).__name__
        json = {&#39;@type&#39;: o_type}
        if self.id is not None:
            json[&#39;@id&#39;] = self.id
        return json

    def read_json(self, json: dict):
        self.id = json.get(&#39;@id&#39;)
        self.olca_type = json.get(&#39;@type&#39;)

    @staticmethod
    def from_json(json: dict):
        instance = Entity()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="olca.ipc.ContributionItem" href="ipc.html#olca.ipc.ContributionItem">ContributionItem</a></li>
<li><a title="olca.ipc.ProductResult" href="ipc.html#olca.ipc.ProductResult">ProductResult</a></li>
<li><a title="olca.schema.AllocationFactor" href="#olca.schema.AllocationFactor">AllocationFactor</a></li>
<li><a title="olca.schema.CalculationSetup" href="#olca.schema.CalculationSetup">CalculationSetup</a></li>
<li><a title="olca.schema.DQIndicator" href="#olca.schema.DQIndicator">DQIndicator</a></li>
<li><a title="olca.schema.DQScore" href="#olca.schema.DQScore">DQScore</a></li>
<li><a title="olca.schema.Exchange" href="#olca.schema.Exchange">Exchange</a></li>
<li><a title="olca.schema.ExchangeRef" href="#olca.schema.ExchangeRef">ExchangeRef</a></li>
<li><a title="olca.schema.FlowMapEntry" href="#olca.schema.FlowMapEntry">FlowMapEntry</a></li>
<li><a title="olca.schema.FlowMapRef" href="#olca.schema.FlowMapRef">FlowMapRef</a></li>
<li><a title="olca.schema.FlowPropertyFactor" href="#olca.schema.FlowPropertyFactor">FlowPropertyFactor</a></li>
<li><a title="olca.schema.FlowResult" href="#olca.schema.FlowResult">FlowResult</a></li>
<li><a title="olca.schema.ImpactFactor" href="#olca.schema.ImpactFactor">ImpactFactor</a></li>
<li><a title="olca.schema.ImpactResult" href="#olca.schema.ImpactResult">ImpactResult</a></li>
<li><a title="olca.schema.NwFactor" href="#olca.schema.NwFactor">NwFactor</a></li>
<li><a title="olca.schema.ParameterRedef" href="#olca.schema.ParameterRedef">ParameterRedef</a></li>
<li><a title="olca.schema.ParameterRedefSet" href="#olca.schema.ParameterRedefSet">ParameterRedefSet</a></li>
<li><a title="olca.schema.ProcessDocumentation" href="#olca.schema.ProcessDocumentation">ProcessDocumentation</a></li>
<li><a title="olca.schema.ProcessLink" href="#olca.schema.ProcessLink">ProcessLink</a></li>
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.SimpleResult" href="#olca.schema.SimpleResult">SimpleResult</a></li>
<li><a title="olca.schema.SocialAspect" href="#olca.schema.SocialAspect">SocialAspect</a></li>
<li><a title="olca.schema.Uncertainty" href="#olca.schema.Uncertainty">Uncertainty</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.Entity.id"><code class="name">var <span class="ident">id</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Entity.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.Entity.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = Entity()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.Entity.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    self.id = json.get(&#39;@id&#39;)
    self.olca_type = json.get(&#39;@type&#39;)</code></pre>
</details>
</dd>
<dt id="olca.schema.Entity.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    o_type = self.olca_type
    if o_type is None:
        o_type = type(self).__name__
    json = {&#39;@type&#39;: o_type}
    if self.id is not None:
        json[&#39;@id&#39;] = self.id
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.Exchange"><code class="flex name class">
<span>class <span class="ident">Exchange</span></span>
<span>(</span><span>id:str='', olca_type:str='Exchange', avoided_product:Optional[bool]=None, cost_formula:Optional[str]=None, cost_value:Optional[float]=None, currency:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, internal_id:Optional[int]=None, flow:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, flow_property:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, input:Optional[bool]=None, quantitative_reference:Optional[bool]=None, base_uncertainty:Optional[float]=None, default_provider:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, amount:Optional[float]=None, amount_formula:Optional[str]=None, unit:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, dq_entry:Optional[str]=None, uncertainty:Optional[<a title="olca.schema.Uncertainty" href="#olca.schema.Uncertainty">Uncertainty</a>]=None, description:Optional[str]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>An Exchange is an input or output of a [Flow] in a [Process]. The amount of
an exchange is given in a specific unit of a quantity ([FlowProperty]) of
the flow. The allowed units and flow properties that can be used for a flow
in an exchange are defined by the flow property information in that flow
(see also the [FlowPropertyFactor] type).</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>avoided_product</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates whether this exchange is an avoided product.</dd>
<dt><strong><code>cost_formula</code></strong> :&ensp;<code>str</code></dt>
<dd>A formula for calculating the costs of this exchange.</dd>
<dt><strong><code>cost_value</code></strong> :&ensp;<code>float</code></dt>
<dd>The costs of this exchange.</dd>
<dt><strong><code>currency</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The currency in which the costs of this exchange are given.</dd>
<dt><strong><code>internal_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The process internal ID of the exchange. This is used to identify
exchanges unambiguously within a process (e.g. when linking exchanges
in a product system where multiple exchanges with the same flow are
allowed). The value should be &gt;= 1.</dd>
<dt><strong><code>flow</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The reference to the flow of the exchange.</dd>
<dt><strong><code>flow_property</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The quantity in which the amount is given.</dd>
<dt><strong><code>input</code></strong> :&ensp;<code>bool</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>quantitative_reference</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates whether the exchange is the quantitative reference of the
process.</dd>
<dt><strong><code>base_uncertainty</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>default_provider</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>A default provider is a [Process] that is linked as the provider of a
product input or the waste treatment provider of a waste output. It is
just an optional default setting which can be also ignored when
building product systems in openLCA. The user is always free to link
processes in product systems ignoring these defaults (but the flows and
flow directions have to match of course).</dd>
<dt><strong><code>amount</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>amount_formula</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>dq_entry</code></strong> :&ensp;<code>str</code></dt>
<dd>A data quality entry like <code>(1;3;2;5;1)</code>. The entry is a vector of data
quality values that need to match the data quality scheme for flow
inputs and outputs that is assigned to the [Process]. In such a scheme
the data quality indicators have fixed positions and the respective
values in the <code>dqEntry</code> vector map to these positions.</dd>
<dt><strong><code>uncertainty</code></strong> :&ensp;<code><a title="olca.schema.Uncertainty" href="#olca.schema.Uncertainty">Uncertainty</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code></dt>
<dd>A general comment about the input or output.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Exchange(Entity):
    &#34;&#34;&#34;
    An Exchange is an input or output of a [Flow] in a [Process]. The amount of
    an exchange is given in a specific unit of a quantity ([FlowProperty]) of
    the flow. The allowed units and flow properties that can be used for a flow
    in an exchange are defined by the flow property information in that flow
    (see also the [FlowPropertyFactor] type).

    Attributes
    ----------
    avoided_product: bool
        Indicates whether this exchange is an avoided product.

    cost_formula: str
        A formula for calculating the costs of this exchange.

    cost_value: float
        The costs of this exchange.

    currency: Ref
        The currency in which the costs of this exchange are given.

    internal_id: int
        The process internal ID of the exchange. This is used to identify
        exchanges unambiguously within a process (e.g. when linking exchanges
        in a product system where multiple exchanges with the same flow are
        allowed). The value should be &gt;= 1.

    flow: Ref
        The reference to the flow of the exchange.

    flow_property: Ref
        The quantity in which the amount is given.

    input: bool

    quantitative_reference: bool
        Indicates whether the exchange is the quantitative reference of the
        process.

    base_uncertainty: float

    default_provider: Ref
        A default provider is a [Process] that is linked as the provider of a
        product input or the waste treatment provider of a waste output. It is
        just an optional default setting which can be also ignored when
        building product systems in openLCA. The user is always free to link
        processes in product systems ignoring these defaults (but the flows and
        flow directions have to match of course).

    amount: float

    amount_formula: str

    unit: Ref

    dq_entry: str
        A data quality entry like `(1;3;2;5;1)`. The entry is a vector of data
        quality values that need to match the data quality scheme for flow
        inputs and outputs that is assigned to the [Process]. In such a scheme
        the data quality indicators have fixed positions and the respective
        values in the `dqEntry` vector map to these positions.

    uncertainty: Uncertainty

    description: str
        A general comment about the input or output.

    &#34;&#34;&#34;

    olca_type: str = &#39;Exchange&#39;
    avoided_product: Optional[bool] = None
    cost_formula: Optional[str] = None
    cost_value: Optional[float] = None
    currency: Optional[Ref] = None
    internal_id: Optional[int] = None
    flow: Optional[Ref] = None
    flow_property: Optional[Ref] = None
    input: Optional[bool] = None
    quantitative_reference: Optional[bool] = None
    base_uncertainty: Optional[float] = None
    default_provider: Optional[Ref] = None
    amount: Optional[float] = None
    amount_formula: Optional[str] = None
    unit: Optional[Ref] = None
    dq_entry: Optional[str] = None
    uncertainty: Optional[Uncertainty] = None
    description: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Exchange, self).to_json()
        if self.avoided_product is not None:
            json[&#39;avoidedProduct&#39;] = self.avoided_product
        if self.cost_formula is not None:
            json[&#39;costFormula&#39;] = self.cost_formula
        if self.cost_value is not None:
            json[&#39;costValue&#39;] = self.cost_value
        if self.currency is not None:
            json[&#39;currency&#39;] = self.currency.to_json()
        if self.internal_id is not None:
            json[&#39;internalId&#39;] = self.internal_id
        if self.flow is not None:
            json[&#39;flow&#39;] = self.flow.to_json()
        if self.flow_property is not None:
            json[&#39;flowProperty&#39;] = self.flow_property.to_json()
        if self.input is not None:
            json[&#39;input&#39;] = self.input
        if self.quantitative_reference is not None:
            json[&#39;quantitativeReference&#39;] = self.quantitative_reference
        if self.base_uncertainty is not None:
            json[&#39;baseUncertainty&#39;] = self.base_uncertainty
        if self.default_provider is not None:
            json[&#39;defaultProvider&#39;] = self.default_provider.to_json()
        if self.amount is not None:
            json[&#39;amount&#39;] = self.amount
        if self.amount_formula is not None:
            json[&#39;amountFormula&#39;] = self.amount_formula
        if self.unit is not None:
            json[&#39;unit&#39;] = self.unit.to_json()
        if self.dq_entry is not None:
            json[&#39;dqEntry&#39;] = self.dq_entry
        if self.uncertainty is not None:
            json[&#39;uncertainty&#39;] = self.uncertainty.to_json()
        if self.description is not None:
            json[&#39;description&#39;] = self.description
        return json

    def read_json(self, json: dict):
        super(Exchange, self).read_json(json)
        val = json.get(&#39;avoidedProduct&#39;)
        if val is not None:
            self.avoided_product = val
        val = json.get(&#39;costFormula&#39;)
        if val is not None:
            self.cost_formula = val
        val = json.get(&#39;costValue&#39;)
        if val is not None:
            self.cost_value = val
        val = json.get(&#39;currency&#39;)
        if val is not None:
            self.currency = Ref()
            self.currency.read_json(val)
        val = json.get(&#39;internalId&#39;)
        if val is not None:
            self.internal_id = val
        val = json.get(&#39;flow&#39;)
        if val is not None:
            self.flow = Ref()
            self.flow.read_json(val)
        val = json.get(&#39;flowProperty&#39;)
        if val is not None:
            self.flow_property = Ref()
            self.flow_property.read_json(val)
        val = json.get(&#39;input&#39;)
        if val is not None:
            self.input = val
        val = json.get(&#39;quantitativeReference&#39;)
        if val is not None:
            self.quantitative_reference = val
        val = json.get(&#39;baseUncertainty&#39;)
        if val is not None:
            self.base_uncertainty = val
        val = json.get(&#39;defaultProvider&#39;)
        if val is not None:
            self.default_provider = Ref()
            self.default_provider.read_json(val)
        val = json.get(&#39;amount&#39;)
        if val is not None:
            self.amount = val
        val = json.get(&#39;amountFormula&#39;)
        if val is not None:
            self.amount_formula = val
        val = json.get(&#39;unit&#39;)
        if val is not None:
            self.unit = Ref()
            self.unit.read_json(val)
        val = json.get(&#39;dqEntry&#39;)
        if val is not None:
            self.dq_entry = val
        val = json.get(&#39;uncertainty&#39;)
        if val is not None:
            self.uncertainty = Uncertainty()
            self.uncertainty.read_json(val)
        val = json.get(&#39;description&#39;)
        if val is not None:
            self.description = val

    @staticmethod
    def from_json(json: dict):
        instance = Exchange()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.Exchange.amount"><code class="name">var <span class="ident">amount</span> :Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Exchange.amount_formula"><code class="name">var <span class="ident">amount_formula</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Exchange.avoided_product"><code class="name">var <span class="ident">avoided_product</span> :Optional[bool]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Exchange.base_uncertainty"><code class="name">var <span class="ident">base_uncertainty</span> :Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Exchange.cost_formula"><code class="name">var <span class="ident">cost_formula</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Exchange.cost_value"><code class="name">var <span class="ident">cost_value</span> :Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Exchange.currency"><code class="name">var <span class="ident">currency</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Exchange.default_provider"><code class="name">var <span class="ident">default_provider</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Exchange.description"><code class="name">var <span class="ident">description</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Exchange.dq_entry"><code class="name">var <span class="ident">dq_entry</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Exchange.flow"><code class="name">var <span class="ident">flow</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Exchange.flow_property"><code class="name">var <span class="ident">flow_property</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Exchange.input"><code class="name">var <span class="ident">input</span> :Optional[bool]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Exchange.internal_id"><code class="name">var <span class="ident">internal_id</span> :Optional[int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Exchange.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Exchange.quantitative_reference"><code class="name">var <span class="ident">quantitative_reference</span> :Optional[bool]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Exchange.uncertainty"><code class="name">var <span class="ident">uncertainty</span> :Optional[<a title="olca.schema.Uncertainty" href="#olca.schema.Uncertainty">Uncertainty</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Exchange.unit"><code class="name">var <span class="ident">unit</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.Exchange.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = Exchange()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.Exchange.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(Exchange, self).read_json(json)
    val = json.get(&#39;avoidedProduct&#39;)
    if val is not None:
        self.avoided_product = val
    val = json.get(&#39;costFormula&#39;)
    if val is not None:
        self.cost_formula = val
    val = json.get(&#39;costValue&#39;)
    if val is not None:
        self.cost_value = val
    val = json.get(&#39;currency&#39;)
    if val is not None:
        self.currency = Ref()
        self.currency.read_json(val)
    val = json.get(&#39;internalId&#39;)
    if val is not None:
        self.internal_id = val
    val = json.get(&#39;flow&#39;)
    if val is not None:
        self.flow = Ref()
        self.flow.read_json(val)
    val = json.get(&#39;flowProperty&#39;)
    if val is not None:
        self.flow_property = Ref()
        self.flow_property.read_json(val)
    val = json.get(&#39;input&#39;)
    if val is not None:
        self.input = val
    val = json.get(&#39;quantitativeReference&#39;)
    if val is not None:
        self.quantitative_reference = val
    val = json.get(&#39;baseUncertainty&#39;)
    if val is not None:
        self.base_uncertainty = val
    val = json.get(&#39;defaultProvider&#39;)
    if val is not None:
        self.default_provider = Ref()
        self.default_provider.read_json(val)
    val = json.get(&#39;amount&#39;)
    if val is not None:
        self.amount = val
    val = json.get(&#39;amountFormula&#39;)
    if val is not None:
        self.amount_formula = val
    val = json.get(&#39;unit&#39;)
    if val is not None:
        self.unit = Ref()
        self.unit.read_json(val)
    val = json.get(&#39;dqEntry&#39;)
    if val is not None:
        self.dq_entry = val
    val = json.get(&#39;uncertainty&#39;)
    if val is not None:
        self.uncertainty = Uncertainty()
        self.uncertainty.read_json(val)
    val = json.get(&#39;description&#39;)
    if val is not None:
        self.description = val</code></pre>
</details>
</dd>
<dt id="olca.schema.Exchange.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(Exchange, self).to_json()
    if self.avoided_product is not None:
        json[&#39;avoidedProduct&#39;] = self.avoided_product
    if self.cost_formula is not None:
        json[&#39;costFormula&#39;] = self.cost_formula
    if self.cost_value is not None:
        json[&#39;costValue&#39;] = self.cost_value
    if self.currency is not None:
        json[&#39;currency&#39;] = self.currency.to_json()
    if self.internal_id is not None:
        json[&#39;internalId&#39;] = self.internal_id
    if self.flow is not None:
        json[&#39;flow&#39;] = self.flow.to_json()
    if self.flow_property is not None:
        json[&#39;flowProperty&#39;] = self.flow_property.to_json()
    if self.input is not None:
        json[&#39;input&#39;] = self.input
    if self.quantitative_reference is not None:
        json[&#39;quantitativeReference&#39;] = self.quantitative_reference
    if self.base_uncertainty is not None:
        json[&#39;baseUncertainty&#39;] = self.base_uncertainty
    if self.default_provider is not None:
        json[&#39;defaultProvider&#39;] = self.default_provider.to_json()
    if self.amount is not None:
        json[&#39;amount&#39;] = self.amount
    if self.amount_formula is not None:
        json[&#39;amountFormula&#39;] = self.amount_formula
    if self.unit is not None:
        json[&#39;unit&#39;] = self.unit.to_json()
    if self.dq_entry is not None:
        json[&#39;dqEntry&#39;] = self.dq_entry
    if self.uncertainty is not None:
        json[&#39;uncertainty&#39;] = self.uncertainty.to_json()
    if self.description is not None:
        json[&#39;description&#39;] = self.description
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.ExchangeRef"><code class="flex name class">
<span>class <span class="ident">ExchangeRef</span></span>
<span>(</span><span>id:str='', olca_type:str='ExchangeRef', internal_id:Optional[int]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>An instance of this class describes a reference to an exchange in a
process. When we reference such an exchange we only need the information to
indentify that exchange unambiguously in a process.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>internal_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The internal ID of the exchange.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class ExchangeRef(Entity):
    &#34;&#34;&#34;
    An instance of this class describes a reference to an exchange in a
    process. When we reference such an exchange we only need the information to
    indentify that exchange unambiguously in a process.

    Attributes
    ----------
    internal_id: int
        The internal ID of the exchange.

    &#34;&#34;&#34;

    olca_type: str = &#39;ExchangeRef&#39;
    internal_id: Optional[int] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ExchangeRef, self).to_json()
        if self.internal_id is not None:
            json[&#39;internalId&#39;] = self.internal_id
        return json

    def read_json(self, json: dict):
        super(ExchangeRef, self).read_json(json)
        val = json.get(&#39;internalId&#39;)
        if val is not None:
            self.internal_id = val

    @staticmethod
    def from_json(json: dict):
        instance = ExchangeRef()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.ExchangeRef.internal_id"><code class="name">var <span class="ident">internal_id</span> :Optional[int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ExchangeRef.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.ExchangeRef.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = ExchangeRef()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.ExchangeRef.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(ExchangeRef, self).read_json(json)
    val = json.get(&#39;internalId&#39;)
    if val is not None:
        self.internal_id = val</code></pre>
</details>
</dd>
<dt id="olca.schema.ExchangeRef.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(ExchangeRef, self).to_json()
    if self.internal_id is not None:
        json[&#39;internalId&#39;] = self.internal_id
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.Flow"><code class="flex name class">
<span>class <span class="ident">Flow</span></span>
<span>(</span><span>id:str='', olca_type:str='Flow', name:Optional[str]=None, description:Optional[str]=None, version:Optional[str]=None, last_change:Optional[str]=None, category:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, tags:Optional[list[str]]=None, library:Optional[str]=None, flow_type:Optional[<a title="olca.schema.FlowType" href="#olca.schema.FlowType">FlowType</a>]=None, cas:Optional[str]=None, formula:Optional[str]=None, flow_properties:Optional[list[<a title="olca.schema.FlowPropertyFactor" href="#olca.schema.FlowPropertyFactor">FlowPropertyFactor</a>]]=None, location:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, synonyms:Optional[str]=None, infrastructure_flow:Optional[bool]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Everything that can be an input or output of a process (e.g. a substance, a
product, a waste, a service etc.)</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>flow_type</code></strong> :&ensp;<code><a title="olca.schema.FlowType" href="#olca.schema.FlowType">FlowType</a></code></dt>
<dd>The type of the flow. Note that this type is more a descriptor of how
the flow is handled in calculations.</dd>
<dt><strong><code>cas</code></strong> :&ensp;<code>str</code></dt>
<dd>A CAS number of the flow.</dd>
<dt><strong><code>formula</code></strong> :&ensp;<code>str</code></dt>
<dd>A chemical formula of the flow.</dd>
<dt><strong><code>flow_properties</code></strong> :&ensp;<code>list[<a title="olca.schema.FlowPropertyFactor" href="#olca.schema.FlowPropertyFactor">FlowPropertyFactor</a>]</code></dt>
<dd>The flow properties (quantities) in which amounts of the flow can be
expressed together with conversion factors between these flow flow
properties.</dd>
<dt><strong><code>location</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The location of the flow. Normally the location of a flow is defined by
the process location where the flow is an input or output. However,
some data formats define a location as a property of a flow.</dd>
<dt><strong><code>synonyms</code></strong> :&ensp;<code>str</code></dt>
<dd>A list of synonyms but packed into a single field. Best is to use
semicolons as separator as commas are sometimes used in names of
chemicals.</dd>
<dt><strong><code>infrastructure_flow</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates whether this flow describes an infrastructure product. This
field is part of the openLCA schema because of backward compatibility
with EcoSpold 1. It does not really have a meaning in openLCA and
should not be used anymore.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Flow(CategorizedEntity):
    &#34;&#34;&#34;
    Everything that can be an input or output of a process (e.g. a substance, a
    product, a waste, a service etc.)

    Attributes
    ----------
    flow_type: FlowType
        The type of the flow. Note that this type is more a descriptor of how
        the flow is handled in calculations.

    cas: str
        A CAS number of the flow.

    formula: str
        A chemical formula of the flow.

    flow_properties: list[FlowPropertyFactor]
        The flow properties (quantities) in which amounts of the flow can be
        expressed together with conversion factors between these flow flow
        properties.

    location: Ref
        The location of the flow. Normally the location of a flow is defined by
        the process location where the flow is an input or output. However,
        some data formats define a location as a property of a flow.

    synonyms: str
        A list of synonyms but packed into a single field. Best is to use
        semicolons as separator as commas are sometimes used in names of
        chemicals.

    infrastructure_flow: bool
        Indicates whether this flow describes an infrastructure product. This
        field is part of the openLCA schema because of backward compatibility
        with EcoSpold 1. It does not really have a meaning in openLCA and
        should not be used anymore.

    &#34;&#34;&#34;

    olca_type: str = &#39;Flow&#39;
    flow_type: Optional[FlowType] = None
    cas: Optional[str] = None
    formula: Optional[str] = None
    flow_properties: Optional[list[FlowPropertyFactor]] = None
    location: Optional[Ref] = None
    synonyms: Optional[str] = None
    infrastructure_flow: Optional[bool] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Flow, self).to_json()
        if self.flow_type is not None:
            json[&#39;flowType&#39;] = self.flow_type.value
        if self.cas is not None:
            json[&#39;cas&#39;] = self.cas
        if self.formula is not None:
            json[&#39;formula&#39;] = self.formula
        if self.flow_properties is not None:
            json[&#39;flowProperties&#39;] = []
            for e in self.flow_properties:
                json[&#39;flowProperties&#39;].append(e.to_json())
        if self.location is not None:
            json[&#39;location&#39;] = self.location.to_json()
        if self.synonyms is not None:
            json[&#39;synonyms&#39;] = self.synonyms
        if self.infrastructure_flow is not None:
            json[&#39;infrastructureFlow&#39;] = self.infrastructure_flow
        return json

    def read_json(self, json: dict):
        super(Flow, self).read_json(json)
        val = json.get(&#39;flowType&#39;)
        if val is not None:
            self.flow_type = FlowType(val)
        val = json.get(&#39;cas&#39;)
        if val is not None:
            self.cas = val
        val = json.get(&#39;formula&#39;)
        if val is not None:
            self.formula = val
        val = json.get(&#39;flowProperties&#39;)
        if val is not None:
            self.flow_properties = []
            for d in val:
                e = FlowPropertyFactor()
                e.read_json(d)
                self.flow_properties.append(e)
        val = json.get(&#39;location&#39;)
        if val is not None:
            self.location = Ref()
            self.location.read_json(val)
        val = json.get(&#39;synonyms&#39;)
        if val is not None:
            self.synonyms = val
        val = json.get(&#39;infrastructureFlow&#39;)
        if val is not None:
            self.infrastructure_flow = val

    @staticmethod
    def from_json(json: dict):
        instance = Flow()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.CategorizedEntity" href="#olca.schema.CategorizedEntity">CategorizedEntity</a></li>
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.Flow.cas"><code class="name">var <span class="ident">cas</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Flow.flow_properties"><code class="name">var <span class="ident">flow_properties</span> :Optional[list]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Flow.flow_type"><code class="name">var <span class="ident">flow_type</span> :Optional[<a title="olca.schema.FlowType" href="#olca.schema.FlowType">FlowType</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Flow.formula"><code class="name">var <span class="ident">formula</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Flow.infrastructure_flow"><code class="name">var <span class="ident">infrastructure_flow</span> :Optional[bool]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Flow.location"><code class="name">var <span class="ident">location</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Flow.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Flow.synonyms"><code class="name">var <span class="ident">synonyms</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.Flow.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = Flow()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.Flow.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(Flow, self).read_json(json)
    val = json.get(&#39;flowType&#39;)
    if val is not None:
        self.flow_type = FlowType(val)
    val = json.get(&#39;cas&#39;)
    if val is not None:
        self.cas = val
    val = json.get(&#39;formula&#39;)
    if val is not None:
        self.formula = val
    val = json.get(&#39;flowProperties&#39;)
    if val is not None:
        self.flow_properties = []
        for d in val:
            e = FlowPropertyFactor()
            e.read_json(d)
            self.flow_properties.append(e)
    val = json.get(&#39;location&#39;)
    if val is not None:
        self.location = Ref()
        self.location.read_json(val)
    val = json.get(&#39;synonyms&#39;)
    if val is not None:
        self.synonyms = val
    val = json.get(&#39;infrastructureFlow&#39;)
    if val is not None:
        self.infrastructure_flow = val</code></pre>
</details>
</dd>
<dt id="olca.schema.Flow.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(Flow, self).to_json()
    if self.flow_type is not None:
        json[&#39;flowType&#39;] = self.flow_type.value
    if self.cas is not None:
        json[&#39;cas&#39;] = self.cas
    if self.formula is not None:
        json[&#39;formula&#39;] = self.formula
    if self.flow_properties is not None:
        json[&#39;flowProperties&#39;] = []
        for e in self.flow_properties:
            json[&#39;flowProperties&#39;].append(e.to_json())
    if self.location is not None:
        json[&#39;location&#39;] = self.location.to_json()
    if self.synonyms is not None:
        json[&#39;synonyms&#39;] = self.synonyms
    if self.infrastructure_flow is not None:
        json[&#39;infrastructureFlow&#39;] = self.infrastructure_flow
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.FlowMap"><code class="flex name class">
<span>class <span class="ident">FlowMap</span></span>
<span>(</span><span>id:str='', olca_type:str='FlowMap', name:Optional[str]=None, description:Optional[str]=None, version:Optional[str]=None, last_change:Optional[str]=None, source:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, target:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, mappings:Optional[list[<a title="olca.schema.FlowMapEntry" href="#olca.schema.FlowMapEntry">FlowMapEntry</a>]]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A crosswalk of flows from a source flow list to a target flow list.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>source</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The reference (id, name, description) of the source flow list.</dd>
<dt><strong><code>target</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The reference (id, name, description) of the target flow list.</dd>
<dt><strong><code>mappings</code></strong> :&ensp;<code>list[<a title="olca.schema.FlowMapEntry" href="#olca.schema.FlowMapEntry">FlowMapEntry</a>]</code></dt>
<dd>A list of flow mappings from flows in a source flow list to flows in a
target flow list.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class FlowMap(RootEntity):
    &#34;&#34;&#34;
    A crosswalk of flows from a source flow list to a target flow list.

    Attributes
    ----------
    source: Ref
        The reference (id, name, description) of the source flow list.

    target: Ref
        The reference (id, name, description) of the target flow list.

    mappings: list[FlowMapEntry]
        A list of flow mappings from flows in a source flow list to flows in a
        target flow list.

    &#34;&#34;&#34;

    olca_type: str = &#39;FlowMap&#39;
    source: Optional[Ref] = None
    target: Optional[Ref] = None
    mappings: Optional[list[FlowMapEntry]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(FlowMap, self).to_json()
        if self.source is not None:
            json[&#39;source&#39;] = self.source.to_json()
        if self.target is not None:
            json[&#39;target&#39;] = self.target.to_json()
        if self.mappings is not None:
            json[&#39;mappings&#39;] = []
            for e in self.mappings:
                json[&#39;mappings&#39;].append(e.to_json())
        return json

    def read_json(self, json: dict):
        super(FlowMap, self).read_json(json)
        val = json.get(&#39;source&#39;)
        if val is not None:
            self.source = Ref()
            self.source.read_json(val)
        val = json.get(&#39;target&#39;)
        if val is not None:
            self.target = Ref()
            self.target.read_json(val)
        val = json.get(&#39;mappings&#39;)
        if val is not None:
            self.mappings = []
            for d in val:
                e = FlowMapEntry()
                e.read_json(d)
                self.mappings.append(e)

    @staticmethod
    def from_json(json: dict):
        instance = FlowMap()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.FlowMap.mappings"><code class="name">var <span class="ident">mappings</span> :Optional[list]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.FlowMap.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.FlowMap.source"><code class="name">var <span class="ident">source</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.FlowMap.target"><code class="name">var <span class="ident">target</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.FlowMap.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = FlowMap()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.FlowMap.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(FlowMap, self).read_json(json)
    val = json.get(&#39;source&#39;)
    if val is not None:
        self.source = Ref()
        self.source.read_json(val)
    val = json.get(&#39;target&#39;)
    if val is not None:
        self.target = Ref()
        self.target.read_json(val)
    val = json.get(&#39;mappings&#39;)
    if val is not None:
        self.mappings = []
        for d in val:
            e = FlowMapEntry()
            e.read_json(d)
            self.mappings.append(e)</code></pre>
</details>
</dd>
<dt id="olca.schema.FlowMap.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(FlowMap, self).to_json()
    if self.source is not None:
        json[&#39;source&#39;] = self.source.to_json()
    if self.target is not None:
        json[&#39;target&#39;] = self.target.to_json()
    if self.mappings is not None:
        json[&#39;mappings&#39;] = []
        for e in self.mappings:
            json[&#39;mappings&#39;].append(e.to_json())
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.FlowMapEntry"><code class="flex name class">
<span>class <span class="ident">FlowMapEntry</span></span>
<span>(</span><span>id:str='', olca_type:str='FlowMapEntry', from_:Optional[<a title="olca.schema.FlowMapRef" href="#olca.schema.FlowMapRef">FlowMapRef</a>]=None, to:Optional[<a title="olca.schema.FlowMapRef" href="#olca.schema.FlowMapRef">FlowMapRef</a>]=None, conversion_factor:Optional[float]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A mapping from a source flow to a target flow.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>from_</code></strong> :&ensp;<code><a title="olca.schema.FlowMapRef" href="#olca.schema.FlowMapRef">FlowMapRef</a></code></dt>
<dd>Describes the source flow of the mapping.</dd>
<dt><strong><code>to</code></strong> :&ensp;<code><a title="olca.schema.FlowMapRef" href="#olca.schema.FlowMapRef">FlowMapRef</a></code></dt>
<dd>Describes the target of the mapping.</dd>
<dt><strong><code>conversion_factor</code></strong> :&ensp;<code>float</code></dt>
<dd>The conversion factor to convert the amount of 1 unit of the source
flow into the corresponding quantity of the target flow.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class FlowMapEntry(Entity):
    &#34;&#34;&#34;
    A mapping from a source flow to a target flow.

    Attributes
    ----------
    from_: FlowMapRef
        Describes the source flow of the mapping.

    to: FlowMapRef
        Describes the target of the mapping.

    conversion_factor: float
        The conversion factor to convert the amount of 1 unit of the source
        flow into the corresponding quantity of the target flow.

    &#34;&#34;&#34;

    olca_type: str = &#39;FlowMapEntry&#39;
    from_: Optional[FlowMapRef] = None
    to: Optional[FlowMapRef] = None
    conversion_factor: Optional[float] = None

    def to_json(self) -&gt; dict:
        json: dict = super(FlowMapEntry, self).to_json()
        if self.from_ is not None:
            json[&#39;from&#39;] = self.from_.to_json()
        if self.to is not None:
            json[&#39;to&#39;] = self.to.to_json()
        if self.conversion_factor is not None:
            json[&#39;conversionFactor&#39;] = self.conversion_factor
        return json

    def read_json(self, json: dict):
        super(FlowMapEntry, self).read_json(json)
        val = json.get(&#39;from&#39;)
        if val is not None:
            self.from_ = FlowMapRef()
            self.from_.read_json(val)
        val = json.get(&#39;to&#39;)
        if val is not None:
            self.to = FlowMapRef()
            self.to.read_json(val)
        val = json.get(&#39;conversionFactor&#39;)
        if val is not None:
            self.conversion_factor = val

    @staticmethod
    def from_json(json: dict):
        instance = FlowMapEntry()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.FlowMapEntry.conversion_factor"><code class="name">var <span class="ident">conversion_factor</span> :Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.FlowMapEntry.from_"><code class="name">var <span class="ident">from_</span> :Optional[<a title="olca.schema.FlowMapRef" href="#olca.schema.FlowMapRef">FlowMapRef</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.FlowMapEntry.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.FlowMapEntry.to"><code class="name">var <span class="ident">to</span> :Optional[<a title="olca.schema.FlowMapRef" href="#olca.schema.FlowMapRef">FlowMapRef</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.FlowMapEntry.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = FlowMapEntry()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.FlowMapEntry.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(FlowMapEntry, self).read_json(json)
    val = json.get(&#39;from&#39;)
    if val is not None:
        self.from_ = FlowMapRef()
        self.from_.read_json(val)
    val = json.get(&#39;to&#39;)
    if val is not None:
        self.to = FlowMapRef()
        self.to.read_json(val)
    val = json.get(&#39;conversionFactor&#39;)
    if val is not None:
        self.conversion_factor = val</code></pre>
</details>
</dd>
<dt id="olca.schema.FlowMapEntry.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(FlowMapEntry, self).to_json()
    if self.from_ is not None:
        json[&#39;from&#39;] = self.from_.to_json()
    if self.to is not None:
        json[&#39;to&#39;] = self.to.to_json()
    if self.conversion_factor is not None:
        json[&#39;conversionFactor&#39;] = self.conversion_factor
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.FlowMapRef"><code class="flex name class">
<span>class <span class="ident">FlowMapRef</span></span>
<span>(</span><span>id:str='', olca_type:str='FlowMapRef', flow:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, flow_property:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, unit:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, provider:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Describes a source or target flow in a <code>FlowMappingEntry</code> of a <code><a title="olca.schema.FlowMap" href="#olca.schema.FlowMap">FlowMap</a></code>.
Such a flow reference can also optionally specify the unit and flow
property (quantity) for which the mapping is valid. If the unit or quantity
is not given, the mapping is based on the respective reference unit and
reference flow property of the flow.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>flow</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The reference to the flow data set.</dd>
<dt><strong><code>flow_property</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>An optional reference to a flow property of the flow for which the
mapping is valid.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>An optional reference to a unit of the flow for which the mapping is
valid</dd>
<dt><strong><code>provider</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>In case of a product or waste flow a flow mapping can contain a
provider which is the process that produces the product or a waste
treatment process that consumes the waste flow. This is useful when we
want to apply mappings of product and waste flows on databases and link
them in the corresponding processes and product systems.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class FlowMapRef(Entity):
    &#34;&#34;&#34;
    Describes a source or target flow in a `FlowMappingEntry` of a `FlowMap`.
    Such a flow reference can also optionally specify the unit and flow
    property (quantity) for which the mapping is valid. If the unit or quantity
    is not given, the mapping is based on the respective reference unit and
    reference flow property of the flow.

    Attributes
    ----------
    flow: Ref
        The reference to the flow data set.

    flow_property: Ref
        An optional reference to a flow property of the flow for which the
        mapping is valid.

    unit: Ref
        An optional reference to a unit of the flow for which the mapping is
        valid

    provider: Ref
        In case of a product or waste flow a flow mapping can contain a
        provider which is the process that produces the product or a waste
        treatment process that consumes the waste flow. This is useful when we
        want to apply mappings of product and waste flows on databases and link
        them in the corresponding processes and product systems.

    &#34;&#34;&#34;

    olca_type: str = &#39;FlowMapRef&#39;
    flow: Optional[Ref] = None
    flow_property: Optional[Ref] = None
    unit: Optional[Ref] = None
    provider: Optional[Ref] = None

    def to_json(self) -&gt; dict:
        json: dict = super(FlowMapRef, self).to_json()
        if self.flow is not None:
            json[&#39;flow&#39;] = self.flow.to_json()
        if self.flow_property is not None:
            json[&#39;flowProperty&#39;] = self.flow_property.to_json()
        if self.unit is not None:
            json[&#39;unit&#39;] = self.unit.to_json()
        if self.provider is not None:
            json[&#39;provider&#39;] = self.provider.to_json()
        return json

    def read_json(self, json: dict):
        super(FlowMapRef, self).read_json(json)
        val = json.get(&#39;flow&#39;)
        if val is not None:
            self.flow = Ref()
            self.flow.read_json(val)
        val = json.get(&#39;flowProperty&#39;)
        if val is not None:
            self.flow_property = Ref()
            self.flow_property.read_json(val)
        val = json.get(&#39;unit&#39;)
        if val is not None:
            self.unit = Ref()
            self.unit.read_json(val)
        val = json.get(&#39;provider&#39;)
        if val is not None:
            self.provider = Ref()
            self.provider.read_json(val)

    @staticmethod
    def from_json(json: dict):
        instance = FlowMapRef()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.FlowMapRef.flow"><code class="name">var <span class="ident">flow</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.FlowMapRef.flow_property"><code class="name">var <span class="ident">flow_property</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.FlowMapRef.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.FlowMapRef.provider"><code class="name">var <span class="ident">provider</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.FlowMapRef.unit"><code class="name">var <span class="ident">unit</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.FlowMapRef.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = FlowMapRef()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.FlowMapRef.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(FlowMapRef, self).read_json(json)
    val = json.get(&#39;flow&#39;)
    if val is not None:
        self.flow = Ref()
        self.flow.read_json(val)
    val = json.get(&#39;flowProperty&#39;)
    if val is not None:
        self.flow_property = Ref()
        self.flow_property.read_json(val)
    val = json.get(&#39;unit&#39;)
    if val is not None:
        self.unit = Ref()
        self.unit.read_json(val)
    val = json.get(&#39;provider&#39;)
    if val is not None:
        self.provider = Ref()
        self.provider.read_json(val)</code></pre>
</details>
</dd>
<dt id="olca.schema.FlowMapRef.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(FlowMapRef, self).to_json()
    if self.flow is not None:
        json[&#39;flow&#39;] = self.flow.to_json()
    if self.flow_property is not None:
        json[&#39;flowProperty&#39;] = self.flow_property.to_json()
    if self.unit is not None:
        json[&#39;unit&#39;] = self.unit.to_json()
    if self.provider is not None:
        json[&#39;provider&#39;] = self.provider.to_json()
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.FlowProperty"><code class="flex name class">
<span>class <span class="ident">FlowProperty</span></span>
<span>(</span><span>id:str='', olca_type:str='FlowProperty', name:Optional[str]=None, description:Optional[str]=None, version:Optional[str]=None, last_change:Optional[str]=None, category:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, tags:Optional[list[str]]=None, library:Optional[str]=None, flow_property_type:Optional[<a title="olca.schema.FlowPropertyType" href="#olca.schema.FlowPropertyType">FlowPropertyType</a>]=None, unit_group:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A flow property is a quantity that can be used to express amounts of a
flow.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>flow_property_type</code></strong> :&ensp;<code><a title="olca.schema.FlowPropertyType" href="#olca.schema.FlowPropertyType">FlowPropertyType</a></code></dt>
<dd>The type of the flow property</dd>
<dt><strong><code>unit_group</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The units of measure that can be used to express quantities of the flow
property.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class FlowProperty(CategorizedEntity):
    &#34;&#34;&#34;
    A flow property is a quantity that can be used to express amounts of a
    flow.

    Attributes
    ----------
    flow_property_type: FlowPropertyType
        The type of the flow property

    unit_group: Ref
        The units of measure that can be used to express quantities of the flow
        property.

    &#34;&#34;&#34;

    olca_type: str = &#39;FlowProperty&#39;
    flow_property_type: Optional[FlowPropertyType] = None
    unit_group: Optional[Ref] = None

    def to_json(self) -&gt; dict:
        json: dict = super(FlowProperty, self).to_json()
        if self.flow_property_type is not None:
            json[&#39;flowPropertyType&#39;] = self.flow_property_type.value
        if self.unit_group is not None:
            json[&#39;unitGroup&#39;] = self.unit_group.to_json()
        return json

    def read_json(self, json: dict):
        super(FlowProperty, self).read_json(json)
        val = json.get(&#39;flowPropertyType&#39;)
        if val is not None:
            self.flow_property_type = FlowPropertyType(val)
        val = json.get(&#39;unitGroup&#39;)
        if val is not None:
            self.unit_group = Ref()
            self.unit_group.read_json(val)

    @staticmethod
    def from_json(json: dict):
        instance = FlowProperty()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.CategorizedEntity" href="#olca.schema.CategorizedEntity">CategorizedEntity</a></li>
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.FlowProperty.flow_property_type"><code class="name">var <span class="ident">flow_property_type</span> :Optional[<a title="olca.schema.FlowPropertyType" href="#olca.schema.FlowPropertyType">FlowPropertyType</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.FlowProperty.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.FlowProperty.unit_group"><code class="name">var <span class="ident">unit_group</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.FlowProperty.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = FlowProperty()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.FlowProperty.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(FlowProperty, self).read_json(json)
    val = json.get(&#39;flowPropertyType&#39;)
    if val is not None:
        self.flow_property_type = FlowPropertyType(val)
    val = json.get(&#39;unitGroup&#39;)
    if val is not None:
        self.unit_group = Ref()
        self.unit_group.read_json(val)</code></pre>
</details>
</dd>
<dt id="olca.schema.FlowProperty.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(FlowProperty, self).to_json()
    if self.flow_property_type is not None:
        json[&#39;flowPropertyType&#39;] = self.flow_property_type.value
    if self.unit_group is not None:
        json[&#39;unitGroup&#39;] = self.unit_group.to_json()
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.FlowPropertyFactor"><code class="flex name class">
<span>class <span class="ident">FlowPropertyFactor</span></span>
<span>(</span><span>id:str='', olca_type:str='FlowPropertyFactor', flow_property:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, conversion_factor:Optional[float]=None, reference_flow_property:Optional[bool]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A FlowPropertyFactor is a conversion factor between <a
href="./FlowProperty.html">flow properties (quantities)</a> of a <a
href="./Flow.html">flow</a>. As an example the amount of the flow 'water'
in a process could be expressed in 'kg' mass or 'm3' volume. In this case
the flow water would have two flow property factors: one for the flow
property 'mass' and one for 'volume'. Each of these flow properties has a
reference to a <a href="./UnitGroup.html">unit group</a> which again has a
reference unit. In the example the flow property 'mass' could reference the
unit group 'units of mass' with 'kg' as reference unit and volume could
reference the unit group 'units of volume' with 'm3' as reference unit. The
flow property factor is now the conversion factor between these two
reference units where the factor of the reference flow property of the flow
is 1. If the reference flow property of 'water' in the example would be
'mass' the respective flow property factor would be 1 and the factor for
'volume' would be 0.001 (as 1 kg water is 0.001 m3). The amount of water in
a process can now be also given in liter, tons, grams etc. For this, the
unit conversion factor of the respective unit group can be used to convert
into the reference unit (which then can be used to convert to the reference
unit of another flow property). Another thing to note is that different
flow properties can refer to the same unit group (e.g. MJ upper calorific
value and MJ lower calorific value.)</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>flow_property</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The flow property (quantity) of the factor.</dd>
<dt><strong><code>conversion_factor</code></strong> :&ensp;<code>float</code></dt>
<dd>The value of the conversion factor.</dd>
<dt><strong><code>reference_flow_property</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates whether the flow property of the factor is the reference flow
property of the flow. The reference flow property must have a
conversion factor of 1.0 and there should be only one reference flow
property.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class FlowPropertyFactor(Entity):
    &#34;&#34;&#34;
    A FlowPropertyFactor is a conversion factor between &lt;a
    href=&#34;./FlowProperty.html&#34;&gt;flow properties (quantities)&lt;/a&gt; of a &lt;a
    href=&#34;./Flow.html&#34;&gt;flow&lt;/a&gt;. As an example the amount of the flow &#39;water&#39;
    in a process could be expressed in &#39;kg&#39; mass or &#39;m3&#39; volume. In this case
    the flow water would have two flow property factors: one for the flow
    property &#39;mass&#39; and one for &#39;volume&#39;. Each of these flow properties has a
    reference to a &lt;a href=&#34;./UnitGroup.html&#34;&gt;unit group&lt;/a&gt; which again has a
    reference unit. In the example the flow property &#39;mass&#39; could reference the
    unit group &#39;units of mass&#39; with &#39;kg&#39; as reference unit and volume could
    reference the unit group &#39;units of volume&#39; with &#39;m3&#39; as reference unit. The
    flow property factor is now the conversion factor between these two
    reference units where the factor of the reference flow property of the flow
    is 1. If the reference flow property of &#39;water&#39; in the example would be
    &#39;mass&#39; the respective flow property factor would be 1 and the factor for
    &#39;volume&#39; would be 0.001 (as 1 kg water is 0.001 m3). The amount of water in
    a process can now be also given in liter, tons, grams etc. For this, the
    unit conversion factor of the respective unit group can be used to convert
    into the reference unit (which then can be used to convert to the reference
    unit of another flow property). Another thing to note is that different
    flow properties can refer to the same unit group (e.g. MJ upper calorific
    value and MJ lower calorific value.)

    Attributes
    ----------
    flow_property: Ref
        The flow property (quantity) of the factor.

    conversion_factor: float
        The value of the conversion factor.

    reference_flow_property: bool
        Indicates whether the flow property of the factor is the reference flow
        property of the flow. The reference flow property must have a
        conversion factor of 1.0 and there should be only one reference flow
        property.

    &#34;&#34;&#34;

    olca_type: str = &#39;FlowPropertyFactor&#39;
    flow_property: Optional[Ref] = None
    conversion_factor: Optional[float] = None
    reference_flow_property: Optional[bool] = None

    def to_json(self) -&gt; dict:
        json: dict = super(FlowPropertyFactor, self).to_json()
        if self.flow_property is not None:
            json[&#39;flowProperty&#39;] = self.flow_property.to_json()
        if self.conversion_factor is not None:
            json[&#39;conversionFactor&#39;] = self.conversion_factor
        if self.reference_flow_property is not None:
            json[&#39;referenceFlowProperty&#39;] = self.reference_flow_property
        return json

    def read_json(self, json: dict):
        super(FlowPropertyFactor, self).read_json(json)
        val = json.get(&#39;flowProperty&#39;)
        if val is not None:
            self.flow_property = Ref()
            self.flow_property.read_json(val)
        val = json.get(&#39;conversionFactor&#39;)
        if val is not None:
            self.conversion_factor = val
        val = json.get(&#39;referenceFlowProperty&#39;)
        if val is not None:
            self.reference_flow_property = val

    @staticmethod
    def from_json(json: dict):
        instance = FlowPropertyFactor()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.FlowPropertyFactor.conversion_factor"><code class="name">var <span class="ident">conversion_factor</span> :Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.FlowPropertyFactor.flow_property"><code class="name">var <span class="ident">flow_property</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.FlowPropertyFactor.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.FlowPropertyFactor.reference_flow_property"><code class="name">var <span class="ident">reference_flow_property</span> :Optional[bool]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.FlowPropertyFactor.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = FlowPropertyFactor()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.FlowPropertyFactor.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(FlowPropertyFactor, self).read_json(json)
    val = json.get(&#39;flowProperty&#39;)
    if val is not None:
        self.flow_property = Ref()
        self.flow_property.read_json(val)
    val = json.get(&#39;conversionFactor&#39;)
    if val is not None:
        self.conversion_factor = val
    val = json.get(&#39;referenceFlowProperty&#39;)
    if val is not None:
        self.reference_flow_property = val</code></pre>
</details>
</dd>
<dt id="olca.schema.FlowPropertyFactor.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(FlowPropertyFactor, self).to_json()
    if self.flow_property is not None:
        json[&#39;flowProperty&#39;] = self.flow_property.to_json()
    if self.conversion_factor is not None:
        json[&#39;conversionFactor&#39;] = self.conversion_factor
    if self.reference_flow_property is not None:
        json[&#39;referenceFlowProperty&#39;] = self.reference_flow_property
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.FlowPropertyType"><code class="flex name class">
<span>class <span class="ident">FlowPropertyType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration of flow property types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FlowPropertyType(Enum):
    &#34;&#34;&#34;
    An enumeration of flow property types.
    &#34;&#34;&#34;

    ECONOMIC_QUANTITY = &#39;ECONOMIC_QUANTITY&#39;
    PHYSICAL_QUANTITY = &#39;PHYSICAL_QUANTITY&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.FlowPropertyType.ECONOMIC_QUANTITY"><code class="name">var <span class="ident">ECONOMIC_QUANTITY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.FlowPropertyType.PHYSICAL_QUANTITY"><code class="name">var <span class="ident">PHYSICAL_QUANTITY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="olca.schema.FlowResult"><code class="flex name class">
<span>class <span class="ident">FlowResult</span></span>
<span>(</span><span>id:str='', olca_type:str='FlowResult', flow:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, input:Optional[bool]=None, value:Optional[float]=None, location:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A result value for a flow; given in the reference unit of the flow.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>flow</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The flow reference.</dd>
<dt><strong><code>input</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates whether the flow is an input or not.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value of the flow amount.</dd>
<dt><strong><code>location</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The (reference to the) location of this flow result in case of a
regionalized result.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class FlowResult(Entity):
    &#34;&#34;&#34;
    A result value for a flow; given in the reference unit of the flow.

    Attributes
    ----------
    flow: Ref
        The flow reference.

    input: bool
        Indicates whether the flow is an input or not.

    value: float
        The value of the flow amount.

    location: Ref
        The (reference to the) location of this flow result in case of a
        regionalized result.

    &#34;&#34;&#34;

    olca_type: str = &#39;FlowResult&#39;
    flow: Optional[Ref] = None
    input: Optional[bool] = None
    value: Optional[float] = None
    location: Optional[Ref] = None

    def to_json(self) -&gt; dict:
        json: dict = super(FlowResult, self).to_json()
        if self.flow is not None:
            json[&#39;flow&#39;] = self.flow.to_json()
        if self.input is not None:
            json[&#39;input&#39;] = self.input
        if self.value is not None:
            json[&#39;value&#39;] = self.value
        if self.location is not None:
            json[&#39;location&#39;] = self.location.to_json()
        return json

    def read_json(self, json: dict):
        super(FlowResult, self).read_json(json)
        val = json.get(&#39;flow&#39;)
        if val is not None:
            self.flow = Ref()
            self.flow.read_json(val)
        val = json.get(&#39;input&#39;)
        if val is not None:
            self.input = val
        val = json.get(&#39;value&#39;)
        if val is not None:
            self.value = val
        val = json.get(&#39;location&#39;)
        if val is not None:
            self.location = Ref()
            self.location.read_json(val)

    @staticmethod
    def from_json(json: dict):
        instance = FlowResult()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.FlowResult.flow"><code class="name">var <span class="ident">flow</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.FlowResult.input"><code class="name">var <span class="ident">input</span> :Optional[bool]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.FlowResult.location"><code class="name">var <span class="ident">location</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.FlowResult.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.FlowResult.value"><code class="name">var <span class="ident">value</span> :Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.FlowResult.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = FlowResult()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.FlowResult.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(FlowResult, self).read_json(json)
    val = json.get(&#39;flow&#39;)
    if val is not None:
        self.flow = Ref()
        self.flow.read_json(val)
    val = json.get(&#39;input&#39;)
    if val is not None:
        self.input = val
    val = json.get(&#39;value&#39;)
    if val is not None:
        self.value = val
    val = json.get(&#39;location&#39;)
    if val is not None:
        self.location = Ref()
        self.location.read_json(val)</code></pre>
</details>
</dd>
<dt id="olca.schema.FlowResult.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(FlowResult, self).to_json()
    if self.flow is not None:
        json[&#39;flow&#39;] = self.flow.to_json()
    if self.input is not None:
        json[&#39;input&#39;] = self.input
    if self.value is not None:
        json[&#39;value&#39;] = self.value
    if self.location is not None:
        json[&#39;location&#39;] = self.location.to_json()
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.FlowType"><code class="flex name class">
<span>class <span class="ident">FlowType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>The basic flow types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FlowType(Enum):
    &#34;&#34;&#34;
    The basic flow types.
    &#34;&#34;&#34;

    ELEMENTARY_FLOW = &#39;ELEMENTARY_FLOW&#39;
    PRODUCT_FLOW = &#39;PRODUCT_FLOW&#39;
    WASTE_FLOW = &#39;WASTE_FLOW&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.FlowType.ELEMENTARY_FLOW"><code class="name">var <span class="ident">ELEMENTARY_FLOW</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.FlowType.PRODUCT_FLOW"><code class="name">var <span class="ident">PRODUCT_FLOW</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.FlowType.WASTE_FLOW"><code class="name">var <span class="ident">WASTE_FLOW</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="olca.schema.ImpactCategory"><code class="flex name class">
<span>class <span class="ident">ImpactCategory</span></span>
<span>(</span><span>id:str='', olca_type:str='ImpactCategory', name:Optional[str]=None, description:Optional[str]=None, version:Optional[str]=None, last_change:Optional[str]=None, category:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, tags:Optional[list[str]]=None, library:Optional[str]=None, reference_unit_name:Optional[str]=None, parameters:Optional[list[<a title="olca.schema.Parameter" href="#olca.schema.Parameter">Parameter</a>]]=None, impact_factors:Optional[list[<a title="olca.schema.ImpactFactor" href="#olca.schema.ImpactFactor">ImpactFactor</a>]]=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>reference_unit_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the reference unit of the LCIA category (e.g. kg CO2-eq.).</dd>
<dt><strong><code>parameters</code></strong> :&ensp;<code>list[<a title="olca.schema.Parameter" href="#olca.schema.Parameter">Parameter</a>]</code></dt>
<dd>A set of parameters which can be used in formulas of the
characterisation factors in this impact category.</dd>
<dt><strong><code>impact_factors</code></strong> :&ensp;<code>list[<a title="olca.schema.ImpactFactor" href="#olca.schema.ImpactFactor">ImpactFactor</a>]</code></dt>
<dd>The characterisation factors of the LCIA category.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class ImpactCategory(CategorizedEntity):
    &#34;&#34;&#34;


    Attributes
    ----------
    reference_unit_name: str
        The name of the reference unit of the LCIA category (e.g. kg CO2-eq.).

    parameters: list[Parameter]
        A set of parameters which can be used in formulas of the
        characterisation factors in this impact category.

    impact_factors: list[ImpactFactor]
        The characterisation factors of the LCIA category.

    &#34;&#34;&#34;

    olca_type: str = &#39;ImpactCategory&#39;
    reference_unit_name: Optional[str] = None
    parameters: Optional[list[Parameter]] = None
    impact_factors: Optional[list[ImpactFactor]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ImpactCategory, self).to_json()
        if self.reference_unit_name is not None:
            json[&#39;referenceUnitName&#39;] = self.reference_unit_name
        if self.parameters is not None:
            json[&#39;parameters&#39;] = []
            for e in self.parameters:
                json[&#39;parameters&#39;].append(e.to_json())
        if self.impact_factors is not None:
            json[&#39;impactFactors&#39;] = []
            for e in self.impact_factors:
                json[&#39;impactFactors&#39;].append(e.to_json())
        return json

    def read_json(self, json: dict):
        super(ImpactCategory, self).read_json(json)
        val = json.get(&#39;referenceUnitName&#39;)
        if val is not None:
            self.reference_unit_name = val
        val = json.get(&#39;parameters&#39;)
        if val is not None:
            self.parameters = []
            for d in val:
                e = Parameter()
                e.read_json(d)
                self.parameters.append(e)
        val = json.get(&#39;impactFactors&#39;)
        if val is not None:
            self.impact_factors = []
            for d in val:
                e = ImpactFactor()
                e.read_json(d)
                self.impact_factors.append(e)

    @staticmethod
    def from_json(json: dict):
        instance = ImpactCategory()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.CategorizedEntity" href="#olca.schema.CategorizedEntity">CategorizedEntity</a></li>
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.ImpactCategory.impact_factors"><code class="name">var <span class="ident">impact_factors</span> :Optional[list]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ImpactCategory.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ImpactCategory.parameters"><code class="name">var <span class="ident">parameters</span> :Optional[list]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ImpactCategory.reference_unit_name"><code class="name">var <span class="ident">reference_unit_name</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.ImpactCategory.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = ImpactCategory()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.ImpactCategory.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(ImpactCategory, self).read_json(json)
    val = json.get(&#39;referenceUnitName&#39;)
    if val is not None:
        self.reference_unit_name = val
    val = json.get(&#39;parameters&#39;)
    if val is not None:
        self.parameters = []
        for d in val:
            e = Parameter()
            e.read_json(d)
            self.parameters.append(e)
    val = json.get(&#39;impactFactors&#39;)
    if val is not None:
        self.impact_factors = []
        for d in val:
            e = ImpactFactor()
            e.read_json(d)
            self.impact_factors.append(e)</code></pre>
</details>
</dd>
<dt id="olca.schema.ImpactCategory.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(ImpactCategory, self).to_json()
    if self.reference_unit_name is not None:
        json[&#39;referenceUnitName&#39;] = self.reference_unit_name
    if self.parameters is not None:
        json[&#39;parameters&#39;] = []
        for e in self.parameters:
            json[&#39;parameters&#39;].append(e.to_json())
    if self.impact_factors is not None:
        json[&#39;impactFactors&#39;] = []
        for e in self.impact_factors:
            json[&#39;impactFactors&#39;].append(e.to_json())
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.ImpactFactor"><code class="flex name class">
<span>class <span class="ident">ImpactFactor</span></span>
<span>(</span><span>id:str='', olca_type:str='ImpactFactor', flow:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, location:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, flow_property:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, unit:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, value:Optional[float]=None, formula:Optional[str]=None, uncertainty:Optional[<a title="olca.schema.Uncertainty" href="#olca.schema.Uncertainty">Uncertainty</a>]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A single characterisation factor of a LCIA category for a flow.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>flow</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The [Flow] of the impact assessment factor.</dd>
<dt><strong><code>location</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>In case of a regionalized impact category, this field can contain the
location for which this factor is valid.</dd>
<dt><strong><code>flow_property</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The quantity of the flow to which the LCIA factor is related (e.g.
Mass).</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The flow unit to which the LCIA factor is related (e.g. kg).</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value of the impact assessment factor.</dd>
<dt><strong><code>formula</code></strong> :&ensp;<code>str</code></dt>
<dd>A mathematical formula for calculating the value of the LCIA factor.</dd>
<dt><strong><code>uncertainty</code></strong> :&ensp;<code><a title="olca.schema.Uncertainty" href="#olca.schema.Uncertainty">Uncertainty</a></code></dt>
<dd>The uncertainty distribution of the factors' value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class ImpactFactor(Entity):
    &#34;&#34;&#34;
    A single characterisation factor of a LCIA category for a flow.

    Attributes
    ----------
    flow: Ref
        The [Flow] of the impact assessment factor.

    location: Ref
        In case of a regionalized impact category, this field can contain the
        location for which this factor is valid.

    flow_property: Ref
        The quantity of the flow to which the LCIA factor is related (e.g.
        Mass).

    unit: Ref
        The flow unit to which the LCIA factor is related (e.g. kg).

    value: float
        The value of the impact assessment factor.

    formula: str
        A mathematical formula for calculating the value of the LCIA factor.

    uncertainty: Uncertainty
        The uncertainty distribution of the factors&#39; value.

    &#34;&#34;&#34;

    olca_type: str = &#39;ImpactFactor&#39;
    flow: Optional[Ref] = None
    location: Optional[Ref] = None
    flow_property: Optional[Ref] = None
    unit: Optional[Ref] = None
    value: Optional[float] = None
    formula: Optional[str] = None
    uncertainty: Optional[Uncertainty] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ImpactFactor, self).to_json()
        if self.flow is not None:
            json[&#39;flow&#39;] = self.flow.to_json()
        if self.location is not None:
            json[&#39;location&#39;] = self.location.to_json()
        if self.flow_property is not None:
            json[&#39;flowProperty&#39;] = self.flow_property.to_json()
        if self.unit is not None:
            json[&#39;unit&#39;] = self.unit.to_json()
        if self.value is not None:
            json[&#39;value&#39;] = self.value
        if self.formula is not None:
            json[&#39;formula&#39;] = self.formula
        if self.uncertainty is not None:
            json[&#39;uncertainty&#39;] = self.uncertainty.to_json()
        return json

    def read_json(self, json: dict):
        super(ImpactFactor, self).read_json(json)
        val = json.get(&#39;flow&#39;)
        if val is not None:
            self.flow = Ref()
            self.flow.read_json(val)
        val = json.get(&#39;location&#39;)
        if val is not None:
            self.location = Ref()
            self.location.read_json(val)
        val = json.get(&#39;flowProperty&#39;)
        if val is not None:
            self.flow_property = Ref()
            self.flow_property.read_json(val)
        val = json.get(&#39;unit&#39;)
        if val is not None:
            self.unit = Ref()
            self.unit.read_json(val)
        val = json.get(&#39;value&#39;)
        if val is not None:
            self.value = val
        val = json.get(&#39;formula&#39;)
        if val is not None:
            self.formula = val
        val = json.get(&#39;uncertainty&#39;)
        if val is not None:
            self.uncertainty = Uncertainty()
            self.uncertainty.read_json(val)

    @staticmethod
    def from_json(json: dict):
        instance = ImpactFactor()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.ImpactFactor.flow"><code class="name">var <span class="ident">flow</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ImpactFactor.flow_property"><code class="name">var <span class="ident">flow_property</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ImpactFactor.formula"><code class="name">var <span class="ident">formula</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ImpactFactor.location"><code class="name">var <span class="ident">location</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ImpactFactor.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ImpactFactor.uncertainty"><code class="name">var <span class="ident">uncertainty</span> :Optional[<a title="olca.schema.Uncertainty" href="#olca.schema.Uncertainty">Uncertainty</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ImpactFactor.unit"><code class="name">var <span class="ident">unit</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ImpactFactor.value"><code class="name">var <span class="ident">value</span> :Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.ImpactFactor.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = ImpactFactor()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.ImpactFactor.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(ImpactFactor, self).read_json(json)
    val = json.get(&#39;flow&#39;)
    if val is not None:
        self.flow = Ref()
        self.flow.read_json(val)
    val = json.get(&#39;location&#39;)
    if val is not None:
        self.location = Ref()
        self.location.read_json(val)
    val = json.get(&#39;flowProperty&#39;)
    if val is not None:
        self.flow_property = Ref()
        self.flow_property.read_json(val)
    val = json.get(&#39;unit&#39;)
    if val is not None:
        self.unit = Ref()
        self.unit.read_json(val)
    val = json.get(&#39;value&#39;)
    if val is not None:
        self.value = val
    val = json.get(&#39;formula&#39;)
    if val is not None:
        self.formula = val
    val = json.get(&#39;uncertainty&#39;)
    if val is not None:
        self.uncertainty = Uncertainty()
        self.uncertainty.read_json(val)</code></pre>
</details>
</dd>
<dt id="olca.schema.ImpactFactor.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(ImpactFactor, self).to_json()
    if self.flow is not None:
        json[&#39;flow&#39;] = self.flow.to_json()
    if self.location is not None:
        json[&#39;location&#39;] = self.location.to_json()
    if self.flow_property is not None:
        json[&#39;flowProperty&#39;] = self.flow_property.to_json()
    if self.unit is not None:
        json[&#39;unit&#39;] = self.unit.to_json()
    if self.value is not None:
        json[&#39;value&#39;] = self.value
    if self.formula is not None:
        json[&#39;formula&#39;] = self.formula
    if self.uncertainty is not None:
        json[&#39;uncertainty&#39;] = self.uncertainty.to_json()
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.ImpactMethod"><code class="flex name class">
<span>class <span class="ident">ImpactMethod</span></span>
<span>(</span><span>id:str='', olca_type:str='ImpactMethod', name:Optional[str]=None, description:Optional[str]=None, version:Optional[str]=None, last_change:Optional[str]=None, category:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, tags:Optional[list[str]]=None, library:Optional[str]=None, impact_categories:Optional[list[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]]=None, nw_sets:Optional[list[<a title="olca.schema.NwSet" href="#olca.schema.NwSet">NwSet</a>]]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>An impact assessment method.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>impact_categories</code></strong> :&ensp;<code>list[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>The impact categories of the method.</dd>
<dt><strong><code>nw_sets</code></strong> :&ensp;<code>list[<a title="olca.schema.NwSet" href="#olca.schema.NwSet">NwSet</a>]</code></dt>
<dd>The normalization and weighting sets of the method.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class ImpactMethod(CategorizedEntity):
    &#34;&#34;&#34;
    An impact assessment method.

    Attributes
    ----------
    impact_categories: list[Ref]
        The impact categories of the method.

    nw_sets: list[NwSet]
        The normalization and weighting sets of the method.

    &#34;&#34;&#34;

    olca_type: str = &#39;ImpactMethod&#39;
    impact_categories: Optional[list[Ref]] = None
    nw_sets: Optional[list[NwSet]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ImpactMethod, self).to_json()
        if self.impact_categories is not None:
            json[&#39;impactCategories&#39;] = []
            for e in self.impact_categories:
                json[&#39;impactCategories&#39;].append(e.to_json())
        if self.nw_sets is not None:
            json[&#39;nwSets&#39;] = []
            for e in self.nw_sets:
                json[&#39;nwSets&#39;].append(e.to_json())
        return json

    def read_json(self, json: dict):
        super(ImpactMethod, self).read_json(json)
        val = json.get(&#39;impactCategories&#39;)
        if val is not None:
            self.impact_categories = []
            for d in val:
                e = Ref()
                e.read_json(d)
                self.impact_categories.append(e)
        val = json.get(&#39;nwSets&#39;)
        if val is not None:
            self.nw_sets = []
            for d in val:
                e = NwSet()
                e.read_json(d)
                self.nw_sets.append(e)

    @staticmethod
    def from_json(json: dict):
        instance = ImpactMethod()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.CategorizedEntity" href="#olca.schema.CategorizedEntity">CategorizedEntity</a></li>
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.ImpactMethod.impact_categories"><code class="name">var <span class="ident">impact_categories</span> :Optional[list]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ImpactMethod.nw_sets"><code class="name">var <span class="ident">nw_sets</span> :Optional[list]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ImpactMethod.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.ImpactMethod.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = ImpactMethod()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.ImpactMethod.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(ImpactMethod, self).read_json(json)
    val = json.get(&#39;impactCategories&#39;)
    if val is not None:
        self.impact_categories = []
        for d in val:
            e = Ref()
            e.read_json(d)
            self.impact_categories.append(e)
    val = json.get(&#39;nwSets&#39;)
    if val is not None:
        self.nw_sets = []
        for d in val:
            e = NwSet()
            e.read_json(d)
            self.nw_sets.append(e)</code></pre>
</details>
</dd>
<dt id="olca.schema.ImpactMethod.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(ImpactMethod, self).to_json()
    if self.impact_categories is not None:
        json[&#39;impactCategories&#39;] = []
        for e in self.impact_categories:
            json[&#39;impactCategories&#39;].append(e.to_json())
    if self.nw_sets is not None:
        json[&#39;nwSets&#39;] = []
        for e in self.nw_sets:
            json[&#39;nwSets&#39;].append(e.to_json())
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.ImpactResult"><code class="flex name class">
<span>class <span class="ident">ImpactResult</span></span>
<span>(</span><span>id:str='', olca_type:str='ImpactResult', impact_category:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, value:Optional[float]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A result value for an impact assessment category.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>impact_category</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The reference to the impact assessment category.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value of the flow amount.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class ImpactResult(Entity):
    &#34;&#34;&#34;
    A result value for an impact assessment category.

    Attributes
    ----------
    impact_category: Ref
        The reference to the impact assessment category.

    value: float
        The value of the flow amount.

    &#34;&#34;&#34;

    olca_type: str = &#39;ImpactResult&#39;
    impact_category: Optional[Ref] = None
    value: Optional[float] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ImpactResult, self).to_json()
        if self.impact_category is not None:
            json[&#39;impactCategory&#39;] = self.impact_category.to_json()
        if self.value is not None:
            json[&#39;value&#39;] = self.value
        return json

    def read_json(self, json: dict):
        super(ImpactResult, self).read_json(json)
        val = json.get(&#39;impactCategory&#39;)
        if val is not None:
            self.impact_category = Ref()
            self.impact_category.read_json(val)
        val = json.get(&#39;value&#39;)
        if val is not None:
            self.value = val

    @staticmethod
    def from_json(json: dict):
        instance = ImpactResult()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.ImpactResult.impact_category"><code class="name">var <span class="ident">impact_category</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ImpactResult.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ImpactResult.value"><code class="name">var <span class="ident">value</span> :Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.ImpactResult.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = ImpactResult()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.ImpactResult.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(ImpactResult, self).read_json(json)
    val = json.get(&#39;impactCategory&#39;)
    if val is not None:
        self.impact_category = Ref()
        self.impact_category.read_json(val)
    val = json.get(&#39;value&#39;)
    if val is not None:
        self.value = val</code></pre>
</details>
</dd>
<dt id="olca.schema.ImpactResult.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(ImpactResult, self).to_json()
    if self.impact_category is not None:
        json[&#39;impactCategory&#39;] = self.impact_category.to_json()
    if self.value is not None:
        json[&#39;value&#39;] = self.value
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.Location"><code class="flex name class">
<span>class <span class="ident">Location</span></span>
<span>(</span><span>id:str='', olca_type:str='Location', name:Optional[str]=None, description:Optional[str]=None, version:Optional[str]=None, last_change:Optional[str]=None, category:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, tags:Optional[list[str]]=None, library:Optional[str]=None, code:Optional[str]=None, latitude:Optional[float]=None, longitude:Optional[float]=None, geometry:Optional[dict]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A location like a country, state, city, etc.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>code</code></strong> :&ensp;<code>str</code></dt>
<dd>The code of the location (e.g. an ISO 2-letter country code).</dd>
<dt><strong><code>latitude</code></strong> :&ensp;<code>float</code></dt>
<dd>The average latitude of the location.</dd>
<dt><strong><code>longitude</code></strong> :&ensp;<code>float</code></dt>
<dd>The average longitude of the location.</dd>
<dt><strong><code>geometry</code></strong> :&ensp;<code>dict</code></dt>
<dd>A GeoJSON object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Location(CategorizedEntity):
    &#34;&#34;&#34;
    A location like a country, state, city, etc.

    Attributes
    ----------
    code: str
        The code of the location (e.g. an ISO 2-letter country code).

    latitude: float
        The average latitude of the location.

    longitude: float
        The average longitude of the location.

    geometry: dict
        A GeoJSON object.

    &#34;&#34;&#34;

    olca_type: str = &#39;Location&#39;
    code: Optional[str] = None
    latitude: Optional[float] = None
    longitude: Optional[float] = None
    geometry: Optional[dict] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Location, self).to_json()
        if self.code is not None:
            json[&#39;code&#39;] = self.code
        if self.latitude is not None:
            json[&#39;latitude&#39;] = self.latitude
        if self.longitude is not None:
            json[&#39;longitude&#39;] = self.longitude
        if self.geometry is not None:
            json[&#39;geometry&#39;] = self.geometry
        return json

    def read_json(self, json: dict):
        super(Location, self).read_json(json)
        val = json.get(&#39;code&#39;)
        if val is not None:
            self.code = val
        val = json.get(&#39;latitude&#39;)
        if val is not None:
            self.latitude = val
        val = json.get(&#39;longitude&#39;)
        if val is not None:
            self.longitude = val
        val = json.get(&#39;geometry&#39;)
        if val is not None:
            self.geometry = val

    @staticmethod
    def from_json(json: dict):
        instance = Location()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.CategorizedEntity" href="#olca.schema.CategorizedEntity">CategorizedEntity</a></li>
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.Location.code"><code class="name">var <span class="ident">code</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Location.geometry"><code class="name">var <span class="ident">geometry</span> :Optional[dict]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Location.latitude"><code class="name">var <span class="ident">latitude</span> :Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Location.longitude"><code class="name">var <span class="ident">longitude</span> :Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Location.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.Location.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = Location()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.Location.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(Location, self).read_json(json)
    val = json.get(&#39;code&#39;)
    if val is not None:
        self.code = val
    val = json.get(&#39;latitude&#39;)
    if val is not None:
        self.latitude = val
    val = json.get(&#39;longitude&#39;)
    if val is not None:
        self.longitude = val
    val = json.get(&#39;geometry&#39;)
    if val is not None:
        self.geometry = val</code></pre>
</details>
</dd>
<dt id="olca.schema.Location.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(Location, self).to_json()
    if self.code is not None:
        json[&#39;code&#39;] = self.code
    if self.latitude is not None:
        json[&#39;latitude&#39;] = self.latitude
    if self.longitude is not None:
        json[&#39;longitude&#39;] = self.longitude
    if self.geometry is not None:
        json[&#39;geometry&#39;] = self.geometry
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.ModelType"><code class="flex name class">
<span>class <span class="ident">ModelType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration of the root entity types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ModelType(Enum):
    &#34;&#34;&#34;
    An enumeration of the root entity types.
    &#34;&#34;&#34;

    ACTOR = &#39;ACTOR&#39;
    CATEGORY = &#39;CATEGORY&#39;
    CURRENCY = &#39;CURRENCY&#39;
    DQ_SYSTEM = &#39;DQ_SYSTEM&#39;
    FLOW = &#39;FLOW&#39;
    FLOW_PROPERTY = &#39;FLOW_PROPERTY&#39;
    IMPACT_CATEGORY = &#39;IMPACT_CATEGORY&#39;
    IMPACT_METHOD = &#39;IMPACT_METHOD&#39;
    LOCATION = &#39;LOCATION&#39;
    NW_SET = &#39;NW_SET&#39;
    PARAMETER = &#39;PARAMETER&#39;
    PROCESS = &#39;PROCESS&#39;
    PRODUCT_SYSTEM = &#39;PRODUCT_SYSTEM&#39;
    PROJECT = &#39;PROJECT&#39;
    SOCIAL_INDICATOR = &#39;SOCIAL_INDICATOR&#39;
    SOURCE = &#39;SOURCE&#39;
    UNIT = &#39;UNIT&#39;
    UNIT_GROUP = &#39;UNIT_GROUP&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.ModelType.ACTOR"><code class="name">var <span class="ident">ACTOR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ModelType.CATEGORY"><code class="name">var <span class="ident">CATEGORY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ModelType.CURRENCY"><code class="name">var <span class="ident">CURRENCY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ModelType.DQ_SYSTEM"><code class="name">var <span class="ident">DQ_SYSTEM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ModelType.FLOW"><code class="name">var <span class="ident">FLOW</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ModelType.FLOW_PROPERTY"><code class="name">var <span class="ident">FLOW_PROPERTY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ModelType.IMPACT_CATEGORY"><code class="name">var <span class="ident">IMPACT_CATEGORY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ModelType.IMPACT_METHOD"><code class="name">var <span class="ident">IMPACT_METHOD</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ModelType.LOCATION"><code class="name">var <span class="ident">LOCATION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ModelType.NW_SET"><code class="name">var <span class="ident">NW_SET</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ModelType.PARAMETER"><code class="name">var <span class="ident">PARAMETER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ModelType.PROCESS"><code class="name">var <span class="ident">PROCESS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ModelType.PRODUCT_SYSTEM"><code class="name">var <span class="ident">PRODUCT_SYSTEM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ModelType.PROJECT"><code class="name">var <span class="ident">PROJECT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ModelType.SOCIAL_INDICATOR"><code class="name">var <span class="ident">SOCIAL_INDICATOR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ModelType.SOURCE"><code class="name">var <span class="ident">SOURCE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ModelType.UNIT"><code class="name">var <span class="ident">UNIT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ModelType.UNIT_GROUP"><code class="name">var <span class="ident">UNIT_GROUP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="olca.schema.NwFactor"><code class="flex name class">
<span>class <span class="ident">NwFactor</span></span>
<span>(</span><span>id:str='', olca_type:str='NwFactor', impact_category:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, normalisation_factor:Optional[float]=None, weighting_factor:Optional[float]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A normalization and weighting factor of a [NwSet] related to an impact
category. Depending on the purpose of the [NwSet] (normalization,
weighting, or both) the normalization and weighting factor can be present
or not.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>impact_category</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>normalisation_factor</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>weighting_factor</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class NwFactor(Entity):
    &#34;&#34;&#34;
    A normalization and weighting factor of a [NwSet] related to an impact
    category. Depending on the purpose of the [NwSet] (normalization,
    weighting, or both) the normalization and weighting factor can be present
    or not.

    Attributes
    ----------
    impact_category: Ref

    normalisation_factor: float

    weighting_factor: float

    &#34;&#34;&#34;

    olca_type: str = &#39;NwFactor&#39;
    impact_category: Optional[Ref] = None
    normalisation_factor: Optional[float] = None
    weighting_factor: Optional[float] = None

    def to_json(self) -&gt; dict:
        json: dict = super(NwFactor, self).to_json()
        if self.impact_category is not None:
            json[&#39;impactCategory&#39;] = self.impact_category.to_json()
        if self.normalisation_factor is not None:
            json[&#39;normalisationFactor&#39;] = self.normalisation_factor
        if self.weighting_factor is not None:
            json[&#39;weightingFactor&#39;] = self.weighting_factor
        return json

    def read_json(self, json: dict):
        super(NwFactor, self).read_json(json)
        val = json.get(&#39;impactCategory&#39;)
        if val is not None:
            self.impact_category = Ref()
            self.impact_category.read_json(val)
        val = json.get(&#39;normalisationFactor&#39;)
        if val is not None:
            self.normalisation_factor = val
        val = json.get(&#39;weightingFactor&#39;)
        if val is not None:
            self.weighting_factor = val

    @staticmethod
    def from_json(json: dict):
        instance = NwFactor()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.NwFactor.impact_category"><code class="name">var <span class="ident">impact_category</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.NwFactor.normalisation_factor"><code class="name">var <span class="ident">normalisation_factor</span> :Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.NwFactor.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.NwFactor.weighting_factor"><code class="name">var <span class="ident">weighting_factor</span> :Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.NwFactor.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = NwFactor()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.NwFactor.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(NwFactor, self).read_json(json)
    val = json.get(&#39;impactCategory&#39;)
    if val is not None:
        self.impact_category = Ref()
        self.impact_category.read_json(val)
    val = json.get(&#39;normalisationFactor&#39;)
    if val is not None:
        self.normalisation_factor = val
    val = json.get(&#39;weightingFactor&#39;)
    if val is not None:
        self.weighting_factor = val</code></pre>
</details>
</dd>
<dt id="olca.schema.NwFactor.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(NwFactor, self).to_json()
    if self.impact_category is not None:
        json[&#39;impactCategory&#39;] = self.impact_category.to_json()
    if self.normalisation_factor is not None:
        json[&#39;normalisationFactor&#39;] = self.normalisation_factor
    if self.weighting_factor is not None:
        json[&#39;weightingFactor&#39;] = self.weighting_factor
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.NwSet"><code class="flex name class">
<span>class <span class="ident">NwSet</span></span>
<span>(</span><span>id:str='', olca_type:str='NwSet', name:Optional[str]=None, description:Optional[str]=None, version:Optional[str]=None, last_change:Optional[str]=None, weighted_score_unit:Optional[str]=None, factors:Optional[list[<a title="olca.schema.NwFactor" href="#olca.schema.NwFactor">NwFactor</a>]]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A normalization and weighting set.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>weighted_score_unit</code></strong> :&ensp;<code>str</code></dt>
<dd>This is the optional unit of the (normalized and) weighted score when
this normalization and weighting set was applied on a LCIA result.</dd>
<dt><strong><code>factors</code></strong> :&ensp;<code>list[<a title="olca.schema.NwFactor" href="#olca.schema.NwFactor">NwFactor</a>]</code></dt>
<dd>The list of normalization and weighting factors of this set.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class NwSet(RootEntity):
    &#34;&#34;&#34;
    A normalization and weighting set.

    Attributes
    ----------
    weighted_score_unit: str
        This is the optional unit of the (normalized and) weighted score when
        this normalization and weighting set was applied on a LCIA result.

    factors: list[NwFactor]
        The list of normalization and weighting factors of this set.

    &#34;&#34;&#34;

    olca_type: str = &#39;NwSet&#39;
    weighted_score_unit: Optional[str] = None
    factors: Optional[list[NwFactor]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(NwSet, self).to_json()
        if self.weighted_score_unit is not None:
            json[&#39;weightedScoreUnit&#39;] = self.weighted_score_unit
        if self.factors is not None:
            json[&#39;factors&#39;] = []
            for e in self.factors:
                json[&#39;factors&#39;].append(e.to_json())
        return json

    def read_json(self, json: dict):
        super(NwSet, self).read_json(json)
        val = json.get(&#39;weightedScoreUnit&#39;)
        if val is not None:
            self.weighted_score_unit = val
        val = json.get(&#39;factors&#39;)
        if val is not None:
            self.factors = []
            for d in val:
                e = NwFactor()
                e.read_json(d)
                self.factors.append(e)

    @staticmethod
    def from_json(json: dict):
        instance = NwSet()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.NwSet.factors"><code class="name">var <span class="ident">factors</span> :Optional[list]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.NwSet.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.NwSet.weighted_score_unit"><code class="name">var <span class="ident">weighted_score_unit</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.NwSet.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = NwSet()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.NwSet.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(NwSet, self).read_json(json)
    val = json.get(&#39;weightedScoreUnit&#39;)
    if val is not None:
        self.weighted_score_unit = val
    val = json.get(&#39;factors&#39;)
    if val is not None:
        self.factors = []
        for d in val:
            e = NwFactor()
            e.read_json(d)
            self.factors.append(e)</code></pre>
</details>
</dd>
<dt id="olca.schema.NwSet.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(NwSet, self).to_json()
    if self.weighted_score_unit is not None:
        json[&#39;weightedScoreUnit&#39;] = self.weighted_score_unit
    if self.factors is not None:
        json[&#39;factors&#39;] = []
        for e in self.factors:
            json[&#39;factors&#39;].append(e.to_json())
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.Parameter"><code class="flex name class">
<span>class <span class="ident">Parameter</span></span>
<span>(</span><span>id:str='', olca_type:str='Parameter', name:Optional[str]=None, description:Optional[str]=None, version:Optional[str]=None, last_change:Optional[str]=None, category:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, tags:Optional[list[str]]=None, library:Optional[str]=None, parameter_scope:Optional[<a title="olca.schema.ParameterScope" href="#olca.schema.ParameterScope">ParameterScope</a>]=None, input_parameter:Optional[bool]=None, value:Optional[float]=None, formula:Optional[str]=None, uncertainty:Optional[<a title="olca.schema.Uncertainty" href="#olca.schema.Uncertainty">Uncertainty</a>]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>In openLCA, parameters can be defined in different scopes: global, process,
or LCIA method. The parameter name can be used in formulas and, thus, need
to conform to a specific syntax. Within a scope the parameter name should
be unique (otherwise the evaluation is not deterministic). There are two
types of parameters in openLCA: input parameters and dependent parameters.
An input parameter can have an optional uncertainty distribution but not a
formula. A dependent parameter can (should) have a formula (where also
other parameters can be used) but no uncertainty distribution.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>parameter_scope</code></strong> :&ensp;<code><a title="olca.schema.ParameterScope" href="#olca.schema.ParameterScope">ParameterScope</a></code></dt>
<dd>The scope where the parameter is valid.</dd>
<dt><strong><code>input_parameter</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates whether the parameter is an input parameter (true) or a
dependent/calculated parameter (false). A parameter can have a formula
if it is not an input parameter.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The parameter value.</dd>
<dt><strong><code>formula</code></strong> :&ensp;<code>str</code></dt>
<dd>A mathematical expression to calculate the parameter value.</dd>
<dt><strong><code>uncertainty</code></strong> :&ensp;<code><a title="olca.schema.Uncertainty" href="#olca.schema.Uncertainty">Uncertainty</a></code></dt>
<dd>An uncertainty distribution of the parameter value. This is only valid
for input parameters.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Parameter(CategorizedEntity):
    &#34;&#34;&#34;
    In openLCA, parameters can be defined in different scopes: global, process,
    or LCIA method. The parameter name can be used in formulas and, thus, need
    to conform to a specific syntax. Within a scope the parameter name should
    be unique (otherwise the evaluation is not deterministic). There are two
    types of parameters in openLCA: input parameters and dependent parameters.
    An input parameter can have an optional uncertainty distribution but not a
    formula. A dependent parameter can (should) have a formula (where also
    other parameters can be used) but no uncertainty distribution.

    Attributes
    ----------
    parameter_scope: ParameterScope
        The scope where the parameter is valid.

    input_parameter: bool
        Indicates whether the parameter is an input parameter (true) or a
        dependent/calculated parameter (false). A parameter can have a formula
        if it is not an input parameter.

    value: float
        The parameter value.

    formula: str
        A mathematical expression to calculate the parameter value.

    uncertainty: Uncertainty
        An uncertainty distribution of the parameter value. This is only valid
        for input parameters.

    &#34;&#34;&#34;

    olca_type: str = &#39;Parameter&#39;
    parameter_scope: Optional[ParameterScope] = None
    input_parameter: Optional[bool] = None
    value: Optional[float] = None
    formula: Optional[str] = None
    uncertainty: Optional[Uncertainty] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Parameter, self).to_json()
        if self.parameter_scope is not None:
            json[&#39;parameterScope&#39;] = self.parameter_scope.value
        if self.input_parameter is not None:
            json[&#39;inputParameter&#39;] = self.input_parameter
        if self.value is not None:
            json[&#39;value&#39;] = self.value
        if self.formula is not None:
            json[&#39;formula&#39;] = self.formula
        if self.uncertainty is not None:
            json[&#39;uncertainty&#39;] = self.uncertainty.to_json()
        return json

    def read_json(self, json: dict):
        super(Parameter, self).read_json(json)
        val = json.get(&#39;parameterScope&#39;)
        if val is not None:
            self.parameter_scope = ParameterScope(val)
        val = json.get(&#39;inputParameter&#39;)
        if val is not None:
            self.input_parameter = val
        val = json.get(&#39;value&#39;)
        if val is not None:
            self.value = val
        val = json.get(&#39;formula&#39;)
        if val is not None:
            self.formula = val
        val = json.get(&#39;uncertainty&#39;)
        if val is not None:
            self.uncertainty = Uncertainty()
            self.uncertainty.read_json(val)

    @staticmethod
    def from_json(json: dict):
        instance = Parameter()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.CategorizedEntity" href="#olca.schema.CategorizedEntity">CategorizedEntity</a></li>
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.Parameter.formula"><code class="name">var <span class="ident">formula</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Parameter.input_parameter"><code class="name">var <span class="ident">input_parameter</span> :Optional[bool]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Parameter.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Parameter.parameter_scope"><code class="name">var <span class="ident">parameter_scope</span> :Optional[<a title="olca.schema.ParameterScope" href="#olca.schema.ParameterScope">ParameterScope</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Parameter.uncertainty"><code class="name">var <span class="ident">uncertainty</span> :Optional[<a title="olca.schema.Uncertainty" href="#olca.schema.Uncertainty">Uncertainty</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Parameter.value"><code class="name">var <span class="ident">value</span> :Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.Parameter.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = Parameter()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.Parameter.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(Parameter, self).read_json(json)
    val = json.get(&#39;parameterScope&#39;)
    if val is not None:
        self.parameter_scope = ParameterScope(val)
    val = json.get(&#39;inputParameter&#39;)
    if val is not None:
        self.input_parameter = val
    val = json.get(&#39;value&#39;)
    if val is not None:
        self.value = val
    val = json.get(&#39;formula&#39;)
    if val is not None:
        self.formula = val
    val = json.get(&#39;uncertainty&#39;)
    if val is not None:
        self.uncertainty = Uncertainty()
        self.uncertainty.read_json(val)</code></pre>
</details>
</dd>
<dt id="olca.schema.Parameter.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(Parameter, self).to_json()
    if self.parameter_scope is not None:
        json[&#39;parameterScope&#39;] = self.parameter_scope.value
    if self.input_parameter is not None:
        json[&#39;inputParameter&#39;] = self.input_parameter
    if self.value is not None:
        json[&#39;value&#39;] = self.value
    if self.formula is not None:
        json[&#39;formula&#39;] = self.formula
    if self.uncertainty is not None:
        json[&#39;uncertainty&#39;] = self.uncertainty.to_json()
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.ParameterRedef"><code class="flex name class">
<span>class <span class="ident">ParameterRedef</span></span>
<span>(</span><span>id:str='', olca_type:str='ParameterRedef', context:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, description:Optional[str]=None, name:Optional[str]=None, uncertainty:Optional[<a title="olca.schema.Uncertainty" href="#olca.schema.Uncertainty">Uncertainty</a>]=None, value:Optional[float]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A redefinition of a parameter in a product system.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>context</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The context of the paramater (a process or LCIA method). If no context
is provided it is assumed that this is a redefinition of a global
parameter.</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code></dt>
<dd>A description of this parameter redefinition.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the redefined parameter. Note that parameter names are used
in formulas so they need to follow specific syntax rules. A
redefinition replaces a bound parameter in a specific context and thus
has to exactly match the respective name.</dd>
<dt><strong><code>uncertainty</code></strong> :&ensp;<code><a title="olca.schema.Uncertainty" href="#olca.schema.Uncertainty">Uncertainty</a></code></dt>
<dd>An uncertainty distribution for the redefined parameter value.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value of the redefined parameter.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class ParameterRedef(Entity):
    &#34;&#34;&#34;
    A redefinition of a parameter in a product system.

    Attributes
    ----------
    context: Ref
        The context of the paramater (a process or LCIA method). If no context
        is provided it is assumed that this is a redefinition of a global
        parameter.

    description: str
        A description of this parameter redefinition.

    name: str
        The name of the redefined parameter. Note that parameter names are used
        in formulas so they need to follow specific syntax rules. A
        redefinition replaces a bound parameter in a specific context and thus
        has to exactly match the respective name.

    uncertainty: Uncertainty
        An uncertainty distribution for the redefined parameter value.

    value: float
        The value of the redefined parameter.

    &#34;&#34;&#34;

    olca_type: str = &#39;ParameterRedef&#39;
    context: Optional[Ref] = None
    description: Optional[str] = None
    name: Optional[str] = None
    uncertainty: Optional[Uncertainty] = None
    value: Optional[float] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ParameterRedef, self).to_json()
        if self.context is not None:
            json[&#39;context&#39;] = self.context.to_json()
        if self.description is not None:
            json[&#39;description&#39;] = self.description
        if self.name is not None:
            json[&#39;name&#39;] = self.name
        if self.uncertainty is not None:
            json[&#39;uncertainty&#39;] = self.uncertainty.to_json()
        if self.value is not None:
            json[&#39;value&#39;] = self.value
        return json

    def read_json(self, json: dict):
        super(ParameterRedef, self).read_json(json)
        val = json.get(&#39;context&#39;)
        if val is not None:
            self.context = Ref()
            self.context.read_json(val)
        val = json.get(&#39;description&#39;)
        if val is not None:
            self.description = val
        val = json.get(&#39;name&#39;)
        if val is not None:
            self.name = val
        val = json.get(&#39;uncertainty&#39;)
        if val is not None:
            self.uncertainty = Uncertainty()
            self.uncertainty.read_json(val)
        val = json.get(&#39;value&#39;)
        if val is not None:
            self.value = val

    @staticmethod
    def from_json(json: dict):
        instance = ParameterRedef()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.ParameterRedef.context"><code class="name">var <span class="ident">context</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ParameterRedef.description"><code class="name">var <span class="ident">description</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ParameterRedef.name"><code class="name">var <span class="ident">name</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ParameterRedef.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ParameterRedef.uncertainty"><code class="name">var <span class="ident">uncertainty</span> :Optional[<a title="olca.schema.Uncertainty" href="#olca.schema.Uncertainty">Uncertainty</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ParameterRedef.value"><code class="name">var <span class="ident">value</span> :Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.ParameterRedef.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = ParameterRedef()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.ParameterRedef.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(ParameterRedef, self).read_json(json)
    val = json.get(&#39;context&#39;)
    if val is not None:
        self.context = Ref()
        self.context.read_json(val)
    val = json.get(&#39;description&#39;)
    if val is not None:
        self.description = val
    val = json.get(&#39;name&#39;)
    if val is not None:
        self.name = val
    val = json.get(&#39;uncertainty&#39;)
    if val is not None:
        self.uncertainty = Uncertainty()
        self.uncertainty.read_json(val)
    val = json.get(&#39;value&#39;)
    if val is not None:
        self.value = val</code></pre>
</details>
</dd>
<dt id="olca.schema.ParameterRedef.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(ParameterRedef, self).to_json()
    if self.context is not None:
        json[&#39;context&#39;] = self.context.to_json()
    if self.description is not None:
        json[&#39;description&#39;] = self.description
    if self.name is not None:
        json[&#39;name&#39;] = self.name
    if self.uncertainty is not None:
        json[&#39;uncertainty&#39;] = self.uncertainty.to_json()
    if self.value is not None:
        json[&#39;value&#39;] = self.value
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.ParameterRedefSet"><code class="flex name class">
<span>class <span class="ident">ParameterRedefSet</span></span>
<span>(</span><span>id:str='', olca_type:str='ParameterRedefSet', name:Optional[str]=None, description:Optional[str]=None, is_baseline:Optional[bool]=None, parameters:Optional[list[<a title="olca.schema.ParameterRedef" href="#olca.schema.ParameterRedef">ParameterRedef</a>]]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>An instance of this class is just a set of parameter redefinitions attached
to a product system. It can have a name and a description. One of the
parameter sets can be defined as the baseline of the product system. In the
calculation the baseline set is then taken by default.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the parameter set.</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code></dt>
<dd>A description of the parameter set.</dd>
<dt><strong><code>is_baseline</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates if this set of parameter redefinitions is the baseline for a
product system.</dd>
<dt><strong><code>parameters</code></strong> :&ensp;<code>list[<a title="olca.schema.ParameterRedef" href="#olca.schema.ParameterRedef">ParameterRedef</a>]</code></dt>
<dd>The parameter redefinitions of this redefinition set.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class ParameterRedefSet(Entity):
    &#34;&#34;&#34;
    An instance of this class is just a set of parameter redefinitions attached
    to a product system. It can have a name and a description. One of the
    parameter sets can be defined as the baseline of the product system. In the
    calculation the baseline set is then taken by default.

    Attributes
    ----------
    name: str
        The name of the parameter set.

    description: str
        A description of the parameter set.

    is_baseline: bool
        Indicates if this set of parameter redefinitions is the baseline for a
        product system.

    parameters: list[ParameterRedef]
        The parameter redefinitions of this redefinition set.

    &#34;&#34;&#34;

    olca_type: str = &#39;ParameterRedefSet&#39;
    name: Optional[str] = None
    description: Optional[str] = None
    is_baseline: Optional[bool] = None
    parameters: Optional[list[ParameterRedef]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ParameterRedefSet, self).to_json()
        if self.name is not None:
            json[&#39;name&#39;] = self.name
        if self.description is not None:
            json[&#39;description&#39;] = self.description
        if self.is_baseline is not None:
            json[&#39;isBaseline&#39;] = self.is_baseline
        if self.parameters is not None:
            json[&#39;parameters&#39;] = []
            for e in self.parameters:
                json[&#39;parameters&#39;].append(e.to_json())
        return json

    def read_json(self, json: dict):
        super(ParameterRedefSet, self).read_json(json)
        val = json.get(&#39;name&#39;)
        if val is not None:
            self.name = val
        val = json.get(&#39;description&#39;)
        if val is not None:
            self.description = val
        val = json.get(&#39;isBaseline&#39;)
        if val is not None:
            self.is_baseline = val
        val = json.get(&#39;parameters&#39;)
        if val is not None:
            self.parameters = []
            for d in val:
                e = ParameterRedef()
                e.read_json(d)
                self.parameters.append(e)

    @staticmethod
    def from_json(json: dict):
        instance = ParameterRedefSet()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.ParameterRedefSet.description"><code class="name">var <span class="ident">description</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ParameterRedefSet.is_baseline"><code class="name">var <span class="ident">is_baseline</span> :Optional[bool]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ParameterRedefSet.name"><code class="name">var <span class="ident">name</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ParameterRedefSet.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ParameterRedefSet.parameters"><code class="name">var <span class="ident">parameters</span> :Optional[list]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.ParameterRedefSet.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = ParameterRedefSet()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.ParameterRedefSet.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(ParameterRedefSet, self).read_json(json)
    val = json.get(&#39;name&#39;)
    if val is not None:
        self.name = val
    val = json.get(&#39;description&#39;)
    if val is not None:
        self.description = val
    val = json.get(&#39;isBaseline&#39;)
    if val is not None:
        self.is_baseline = val
    val = json.get(&#39;parameters&#39;)
    if val is not None:
        self.parameters = []
        for d in val:
            e = ParameterRedef()
            e.read_json(d)
            self.parameters.append(e)</code></pre>
</details>
</dd>
<dt id="olca.schema.ParameterRedefSet.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(ParameterRedefSet, self).to_json()
    if self.name is not None:
        json[&#39;name&#39;] = self.name
    if self.description is not None:
        json[&#39;description&#39;] = self.description
    if self.is_baseline is not None:
        json[&#39;isBaseline&#39;] = self.is_baseline
    if self.parameters is not None:
        json[&#39;parameters&#39;] = []
        for e in self.parameters:
            json[&#39;parameters&#39;].append(e.to_json())
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.ParameterScope"><code class="flex name class">
<span>class <span class="ident">ParameterScope</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>The possible scopes of parameters. Parameters can be defined globally, in
processes, or impact categories. They can be redefined in calculation
setups on the project and product system level, but the initial definition
is always only global, in a process, or an LCIA category.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParameterScope(Enum):
    &#34;&#34;&#34;
    The possible scopes of parameters. Parameters can be defined globally, in
    processes, or impact categories. They can be redefined in calculation
    setups on the project and product system level, but the initial definition
    is always only global, in a process, or an LCIA category.
    &#34;&#34;&#34;

    PROCESS_SCOPE = &#39;PROCESS_SCOPE&#39;
    &#34;&#34;&#34;
    Indicates that the evaluation scope of a parameter is the process where it
    is defined.
    &#34;&#34;&#34;

    IMPACT_SCOPE = &#39;IMPACT_SCOPE&#39;
    &#34;&#34;&#34;
    Indicates that the evaluation scope of a parameter is the impact category
    where it is defined.
    &#34;&#34;&#34;

    GLOBAL_SCOPE = &#39;GLOBAL_SCOPE&#39;
    &#34;&#34;&#34;
    Indicates that the evaluation scope of a parameter is the global scope.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.ParameterScope.GLOBAL_SCOPE"><code class="name">var <span class="ident">GLOBAL_SCOPE</span></code></dt>
<dd>
<div class="desc"><p>Indicates that the evaluation scope of a parameter is the global scope.</p></div>
</dd>
<dt id="olca.schema.ParameterScope.IMPACT_SCOPE"><code class="name">var <span class="ident">IMPACT_SCOPE</span></code></dt>
<dd>
<div class="desc"><p>Indicates that the evaluation scope of a parameter is the impact category
where it is defined.</p></div>
</dd>
<dt id="olca.schema.ParameterScope.PROCESS_SCOPE"><code class="name">var <span class="ident">PROCESS_SCOPE</span></code></dt>
<dd>
<div class="desc"><p>Indicates that the evaluation scope of a parameter is the process where it
is defined.</p></div>
</dd>
</dl>
</dd>
<dt id="olca.schema.Process"><code class="flex name class">
<span>class <span class="ident">Process</span></span>
<span>(</span><span>id:str='', olca_type:str='Process', name:Optional[str]=None, description:Optional[str]=None, version:Optional[str]=None, last_change:Optional[str]=None, category:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, tags:Optional[list[str]]=None, library:Optional[str]=None, allocation_factors:Optional[list[<a title="olca.schema.AllocationFactor" href="#olca.schema.AllocationFactor">AllocationFactor</a>]]=None, default_allocation_method:Optional[<a title="olca.schema.AllocationType" href="#olca.schema.AllocationType">AllocationType</a>]=None, exchanges:Optional[list[<a title="olca.schema.Exchange" href="#olca.schema.Exchange">Exchange</a>]]=None, last_internal_id:Optional[int]=None, location:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, parameters:Optional[list[<a title="olca.schema.Parameter" href="#olca.schema.Parameter">Parameter</a>]]=None, process_documentation:Optional[<a title="olca.schema.ProcessDocumentation" href="#olca.schema.ProcessDocumentation">ProcessDocumentation</a>]=None, process_type:Optional[<a title="olca.schema.ProcessType" href="#olca.schema.ProcessType">ProcessType</a>]=None, dq_system:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, exchange_dq_system:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, social_dq_system:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, dq_entry:Optional[str]=None, infrastructure_process:Optional[bool]=None, social_aspects:Optional[list[<a title="olca.schema.SocialAspect" href="#olca.schema.SocialAspect">SocialAspect</a>]]=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>allocation_factors</code></strong> :&ensp;<code>list[<a title="olca.schema.AllocationFactor" href="#olca.schema.AllocationFactor">AllocationFactor</a>]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>default_allocation_method</code></strong> :&ensp;<code><a title="olca.schema.AllocationType" href="#olca.schema.AllocationType">AllocationType</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>exchanges</code></strong> :&ensp;<code>list[<a title="olca.schema.Exchange" href="#olca.schema.Exchange">Exchange</a>]</code></dt>
<dd>The inputs and outputs of the process.</dd>
<dt><strong><code>last_internal_id</code></strong> :&ensp;<code>int</code></dt>
<dd>This field holds the last internal ID that was used in an exchange
(which may have been deleted, so it can be larger than the largest
internal ID of the exchanges of the process.) The internal ID of an
exchange is used to identify exchanges within a process (for updates,
data exchanges (see process links), etc.). When you add an exchange to
a process, you should increment this field in the process and set the
resulting value as the internal ID of that exchange. The sequence of
internal IDs should start with <code>1</code>.</dd>
<dt><strong><code>location</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The location of the process.</dd>
<dt><strong><code>parameters</code></strong> :&ensp;<code>list[<a title="olca.schema.Parameter" href="#olca.schema.Parameter">Parameter</a>]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>process_documentation</code></strong> :&ensp;<code><a title="olca.schema.ProcessDocumentation" href="#olca.schema.ProcessDocumentation">ProcessDocumentation</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>process_type</code></strong> :&ensp;<code><a title="olca.schema.ProcessType" href="#olca.schema.ProcessType">ProcessType</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>dq_system</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>A reference to a data quality system ([DQSystem]) with which the
overall quality of the process can be assessed.</dd>
<dt><strong><code>exchange_dq_system</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>A reference to a data quality system ([DQSystem]) with which the
quality of individual inputs and outputs ([Exchange]s) of the process
can be assessed.</dd>
<dt><strong><code>social_dq_system</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>A reference to a data quality system ([DQSystem]) with which the
quality of individual social aspects of the process can be assessed.</dd>
<dt><strong><code>dq_entry</code></strong> :&ensp;<code>str</code></dt>
<dd>A data quality entry like <code>(1;3;2;5;1)</code>. The entry is a vector of data
quality values that need to match the overall data quality system of
the process (the system that is stored in the <code>dqSystem</code> property). In
such a system the data quality indicators have fixed positions and the
respective values in the <code>dqEntry</code> vector map to these positions.</dd>
<dt><strong><code>infrastructure_process</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates whether this process describes an infrastructure process.
This field is part of the openLCA schema because of backward
compatibility with EcoSpold 1. It does not really have a meaning in
openLCA and should not be used anymore.</dd>
<dt><strong><code>social_aspects</code></strong> :&ensp;<code>list[<a title="olca.schema.SocialAspect" href="#olca.schema.SocialAspect">SocialAspect</a>]</code></dt>
<dd>A set of social aspects related to this process.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Process(CategorizedEntity):
    &#34;&#34;&#34;


    Attributes
    ----------
    allocation_factors: list[AllocationFactor]

    default_allocation_method: AllocationType

    exchanges: list[Exchange]
        The inputs and outputs of the process.

    last_internal_id: int
        This field holds the last internal ID that was used in an exchange
        (which may have been deleted, so it can be larger than the largest
        internal ID of the exchanges of the process.) The internal ID of an
        exchange is used to identify exchanges within a process (for updates,
        data exchanges (see process links), etc.). When you add an exchange to
        a process, you should increment this field in the process and set the
        resulting value as the internal ID of that exchange. The sequence of
        internal IDs should start with `1`.

    location: Ref
        The location of the process.

    parameters: list[Parameter]

    process_documentation: ProcessDocumentation

    process_type: ProcessType

    dq_system: Ref
        A reference to a data quality system ([DQSystem]) with which the
        overall quality of the process can be assessed.

    exchange_dq_system: Ref
        A reference to a data quality system ([DQSystem]) with which the
        quality of individual inputs and outputs ([Exchange]s) of the process
        can be assessed.

    social_dq_system: Ref
        A reference to a data quality system ([DQSystem]) with which the
        quality of individual social aspects of the process can be assessed.

    dq_entry: str
        A data quality entry like `(1;3;2;5;1)`. The entry is a vector of data
        quality values that need to match the overall data quality system of
        the process (the system that is stored in the `dqSystem` property). In
        such a system the data quality indicators have fixed positions and the
        respective values in the `dqEntry` vector map to these positions.

    infrastructure_process: bool
        Indicates whether this process describes an infrastructure process.
        This field is part of the openLCA schema because of backward
        compatibility with EcoSpold 1. It does not really have a meaning in
        openLCA and should not be used anymore.

    social_aspects: list[SocialAspect]
        A set of social aspects related to this process.

    &#34;&#34;&#34;

    olca_type: str = &#39;Process&#39;
    allocation_factors: Optional[list[AllocationFactor]] = None
    default_allocation_method: Optional[AllocationType] = None
    exchanges: Optional[list[Exchange]] = None
    last_internal_id: Optional[int] = None
    location: Optional[Ref] = None
    parameters: Optional[list[Parameter]] = None
    process_documentation: Optional[ProcessDocumentation] = None
    process_type: Optional[ProcessType] = None
    dq_system: Optional[Ref] = None
    exchange_dq_system: Optional[Ref] = None
    social_dq_system: Optional[Ref] = None
    dq_entry: Optional[str] = None
    infrastructure_process: Optional[bool] = None
    social_aspects: Optional[list[SocialAspect]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Process, self).to_json()
        if self.allocation_factors is not None:
            json[&#39;allocationFactors&#39;] = []
            for e in self.allocation_factors:
                json[&#39;allocationFactors&#39;].append(e.to_json())
        if self.default_allocation_method is not None:
            json[&#39;defaultAllocationMethod&#39;] = self.default_allocation_method.value
        if self.exchanges is not None:
            json[&#39;exchanges&#39;] = []
            for e in self.exchanges:
                json[&#39;exchanges&#39;].append(e.to_json())
        if self.last_internal_id is not None:
            json[&#39;lastInternalId&#39;] = self.last_internal_id
        if self.location is not None:
            json[&#39;location&#39;] = self.location.to_json()
        if self.parameters is not None:
            json[&#39;parameters&#39;] = []
            for e in self.parameters:
                json[&#39;parameters&#39;].append(e.to_json())
        if self.process_documentation is not None:
            json[&#39;processDocumentation&#39;] = self.process_documentation.to_json()
        if self.process_type is not None:
            json[&#39;processType&#39;] = self.process_type.value
        if self.dq_system is not None:
            json[&#39;dqSystem&#39;] = self.dq_system.to_json()
        if self.exchange_dq_system is not None:
            json[&#39;exchangeDqSystem&#39;] = self.exchange_dq_system.to_json()
        if self.social_dq_system is not None:
            json[&#39;socialDqSystem&#39;] = self.social_dq_system.to_json()
        if self.dq_entry is not None:
            json[&#39;dqEntry&#39;] = self.dq_entry
        if self.infrastructure_process is not None:
            json[&#39;infrastructureProcess&#39;] = self.infrastructure_process
        if self.social_aspects is not None:
            json[&#39;socialAspects&#39;] = []
            for e in self.social_aspects:
                json[&#39;socialAspects&#39;].append(e.to_json())
        return json

    def read_json(self, json: dict):
        super(Process, self).read_json(json)
        val = json.get(&#39;allocationFactors&#39;)
        if val is not None:
            self.allocation_factors = []
            for d in val:
                e = AllocationFactor()
                e.read_json(d)
                self.allocation_factors.append(e)
        val = json.get(&#39;defaultAllocationMethod&#39;)
        if val is not None:
            self.default_allocation_method = AllocationType(val)
        val = json.get(&#39;exchanges&#39;)
        if val is not None:
            self.exchanges = []
            for d in val:
                e = Exchange()
                e.read_json(d)
                self.exchanges.append(e)
        val = json.get(&#39;lastInternalId&#39;)
        if val is not None:
            self.last_internal_id = val
        val = json.get(&#39;location&#39;)
        if val is not None:
            self.location = Ref()
            self.location.read_json(val)
        val = json.get(&#39;parameters&#39;)
        if val is not None:
            self.parameters = []
            for d in val:
                e = Parameter()
                e.read_json(d)
                self.parameters.append(e)
        val = json.get(&#39;processDocumentation&#39;)
        if val is not None:
            self.process_documentation = ProcessDocumentation()
            self.process_documentation.read_json(val)
        val = json.get(&#39;processType&#39;)
        if val is not None:
            self.process_type = ProcessType(val)
        val = json.get(&#39;dqSystem&#39;)
        if val is not None:
            self.dq_system = Ref()
            self.dq_system.read_json(val)
        val = json.get(&#39;exchangeDqSystem&#39;)
        if val is not None:
            self.exchange_dq_system = Ref()
            self.exchange_dq_system.read_json(val)
        val = json.get(&#39;socialDqSystem&#39;)
        if val is not None:
            self.social_dq_system = Ref()
            self.social_dq_system.read_json(val)
        val = json.get(&#39;dqEntry&#39;)
        if val is not None:
            self.dq_entry = val
        val = json.get(&#39;infrastructureProcess&#39;)
        if val is not None:
            self.infrastructure_process = val
        val = json.get(&#39;socialAspects&#39;)
        if val is not None:
            self.social_aspects = []
            for d in val:
                e = SocialAspect()
                e.read_json(d)
                self.social_aspects.append(e)

    @staticmethod
    def from_json(json: dict):
        instance = Process()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.CategorizedEntity" href="#olca.schema.CategorizedEntity">CategorizedEntity</a></li>
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.Process.allocation_factors"><code class="name">var <span class="ident">allocation_factors</span> :Optional[list]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Process.default_allocation_method"><code class="name">var <span class="ident">default_allocation_method</span> :Optional[<a title="olca.schema.AllocationType" href="#olca.schema.AllocationType">AllocationType</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Process.dq_entry"><code class="name">var <span class="ident">dq_entry</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Process.dq_system"><code class="name">var <span class="ident">dq_system</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Process.exchange_dq_system"><code class="name">var <span class="ident">exchange_dq_system</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Process.exchanges"><code class="name">var <span class="ident">exchanges</span> :Optional[list]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Process.infrastructure_process"><code class="name">var <span class="ident">infrastructure_process</span> :Optional[bool]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Process.last_internal_id"><code class="name">var <span class="ident">last_internal_id</span> :Optional[int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Process.location"><code class="name">var <span class="ident">location</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Process.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Process.parameters"><code class="name">var <span class="ident">parameters</span> :Optional[list]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Process.process_documentation"><code class="name">var <span class="ident">process_documentation</span> :Optional[<a title="olca.schema.ProcessDocumentation" href="#olca.schema.ProcessDocumentation">ProcessDocumentation</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Process.process_type"><code class="name">var <span class="ident">process_type</span> :Optional[<a title="olca.schema.ProcessType" href="#olca.schema.ProcessType">ProcessType</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Process.social_aspects"><code class="name">var <span class="ident">social_aspects</span> :Optional[list]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Process.social_dq_system"><code class="name">var <span class="ident">social_dq_system</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.Process.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = Process()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.Process.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(Process, self).read_json(json)
    val = json.get(&#39;allocationFactors&#39;)
    if val is not None:
        self.allocation_factors = []
        for d in val:
            e = AllocationFactor()
            e.read_json(d)
            self.allocation_factors.append(e)
    val = json.get(&#39;defaultAllocationMethod&#39;)
    if val is not None:
        self.default_allocation_method = AllocationType(val)
    val = json.get(&#39;exchanges&#39;)
    if val is not None:
        self.exchanges = []
        for d in val:
            e = Exchange()
            e.read_json(d)
            self.exchanges.append(e)
    val = json.get(&#39;lastInternalId&#39;)
    if val is not None:
        self.last_internal_id = val
    val = json.get(&#39;location&#39;)
    if val is not None:
        self.location = Ref()
        self.location.read_json(val)
    val = json.get(&#39;parameters&#39;)
    if val is not None:
        self.parameters = []
        for d in val:
            e = Parameter()
            e.read_json(d)
            self.parameters.append(e)
    val = json.get(&#39;processDocumentation&#39;)
    if val is not None:
        self.process_documentation = ProcessDocumentation()
        self.process_documentation.read_json(val)
    val = json.get(&#39;processType&#39;)
    if val is not None:
        self.process_type = ProcessType(val)
    val = json.get(&#39;dqSystem&#39;)
    if val is not None:
        self.dq_system = Ref()
        self.dq_system.read_json(val)
    val = json.get(&#39;exchangeDqSystem&#39;)
    if val is not None:
        self.exchange_dq_system = Ref()
        self.exchange_dq_system.read_json(val)
    val = json.get(&#39;socialDqSystem&#39;)
    if val is not None:
        self.social_dq_system = Ref()
        self.social_dq_system.read_json(val)
    val = json.get(&#39;dqEntry&#39;)
    if val is not None:
        self.dq_entry = val
    val = json.get(&#39;infrastructureProcess&#39;)
    if val is not None:
        self.infrastructure_process = val
    val = json.get(&#39;socialAspects&#39;)
    if val is not None:
        self.social_aspects = []
        for d in val:
            e = SocialAspect()
            e.read_json(d)
            self.social_aspects.append(e)</code></pre>
</details>
</dd>
<dt id="olca.schema.Process.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(Process, self).to_json()
    if self.allocation_factors is not None:
        json[&#39;allocationFactors&#39;] = []
        for e in self.allocation_factors:
            json[&#39;allocationFactors&#39;].append(e.to_json())
    if self.default_allocation_method is not None:
        json[&#39;defaultAllocationMethod&#39;] = self.default_allocation_method.value
    if self.exchanges is not None:
        json[&#39;exchanges&#39;] = []
        for e in self.exchanges:
            json[&#39;exchanges&#39;].append(e.to_json())
    if self.last_internal_id is not None:
        json[&#39;lastInternalId&#39;] = self.last_internal_id
    if self.location is not None:
        json[&#39;location&#39;] = self.location.to_json()
    if self.parameters is not None:
        json[&#39;parameters&#39;] = []
        for e in self.parameters:
            json[&#39;parameters&#39;].append(e.to_json())
    if self.process_documentation is not None:
        json[&#39;processDocumentation&#39;] = self.process_documentation.to_json()
    if self.process_type is not None:
        json[&#39;processType&#39;] = self.process_type.value
    if self.dq_system is not None:
        json[&#39;dqSystem&#39;] = self.dq_system.to_json()
    if self.exchange_dq_system is not None:
        json[&#39;exchangeDqSystem&#39;] = self.exchange_dq_system.to_json()
    if self.social_dq_system is not None:
        json[&#39;socialDqSystem&#39;] = self.social_dq_system.to_json()
    if self.dq_entry is not None:
        json[&#39;dqEntry&#39;] = self.dq_entry
    if self.infrastructure_process is not None:
        json[&#39;infrastructureProcess&#39;] = self.infrastructure_process
    if self.social_aspects is not None:
        json[&#39;socialAspects&#39;] = []
        for e in self.social_aspects:
            json[&#39;socialAspects&#39;].append(e.to_json())
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.ProcessDocumentation"><code class="flex name class">
<span>class <span class="ident">ProcessDocumentation</span></span>
<span>(</span><span>id:str='', olca_type:str='ProcessDocumentation', time_description:Optional[str]=None, valid_until:Optional[str]=None, valid_from:Optional[str]=None, technology_description:Optional[str]=None, data_collection_description:Optional[str]=None, completeness_description:Optional[str]=None, data_selection_description:Optional[str]=None, review_details:Optional[str]=None, data_treatment_description:Optional[str]=None, inventory_method_description:Optional[str]=None, modeling_constants_description:Optional[str]=None, reviewer:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, sampling_description:Optional[str]=None, sources:Optional[list[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]]=None, restrictions_description:Optional[str]=None, copyright:Optional[bool]=None, creation_date:Optional[str]=None, data_documentor:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, data_generator:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, data_set_owner:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, intended_application:Optional[str]=None, project_description:Optional[str]=None, publication:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, geography_description:Optional[str]=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>time_description</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>valid_until</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>valid_from</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>technology_description</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>data_collection_description</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>completeness_description</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>data_selection_description</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>review_details</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>data_treatment_description</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>inventory_method_description</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>modeling_constants_description</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>reviewer</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>sampling_description</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>sources</code></strong> :&ensp;<code>list[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>restrictions_description</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>copyright</code></strong> :&ensp;<code>bool</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>creation_date</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>data_documentor</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>data_generator</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>data_set_owner</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>intended_application</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>project_description</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>publication</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>geography_description</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class ProcessDocumentation(Entity):
    &#34;&#34;&#34;


    Attributes
    ----------
    time_description: str

    valid_until: str

    valid_from: str

    technology_description: str

    data_collection_description: str

    completeness_description: str

    data_selection_description: str

    review_details: str

    data_treatment_description: str

    inventory_method_description: str

    modeling_constants_description: str

    reviewer: Ref

    sampling_description: str

    sources: list[Ref]

    restrictions_description: str

    copyright: bool

    creation_date: str

    data_documentor: Ref

    data_generator: Ref

    data_set_owner: Ref

    intended_application: str

    project_description: str

    publication: Ref

    geography_description: str

    &#34;&#34;&#34;

    olca_type: str = &#39;ProcessDocumentation&#39;
    time_description: Optional[str] = None
    valid_until: Optional[str] = None
    valid_from: Optional[str] = None
    technology_description: Optional[str] = None
    data_collection_description: Optional[str] = None
    completeness_description: Optional[str] = None
    data_selection_description: Optional[str] = None
    review_details: Optional[str] = None
    data_treatment_description: Optional[str] = None
    inventory_method_description: Optional[str] = None
    modeling_constants_description: Optional[str] = None
    reviewer: Optional[Ref] = None
    sampling_description: Optional[str] = None
    sources: Optional[list[Ref]] = None
    restrictions_description: Optional[str] = None
    copyright: Optional[bool] = None
    creation_date: Optional[str] = None
    data_documentor: Optional[Ref] = None
    data_generator: Optional[Ref] = None
    data_set_owner: Optional[Ref] = None
    intended_application: Optional[str] = None
    project_description: Optional[str] = None
    publication: Optional[Ref] = None
    geography_description: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ProcessDocumentation, self).to_json()
        if self.time_description is not None:
            json[&#39;timeDescription&#39;] = self.time_description
        if self.valid_until is not None:
            json[&#39;validUntil&#39;] = self.valid_until
        if self.valid_from is not None:
            json[&#39;validFrom&#39;] = self.valid_from
        if self.technology_description is not None:
            json[&#39;technologyDescription&#39;] = self.technology_description
        if self.data_collection_description is not None:
            json[&#39;dataCollectionDescription&#39;] = self.data_collection_description
        if self.completeness_description is not None:
            json[&#39;completenessDescription&#39;] = self.completeness_description
        if self.data_selection_description is not None:
            json[&#39;dataSelectionDescription&#39;] = self.data_selection_description
        if self.review_details is not None:
            json[&#39;reviewDetails&#39;] = self.review_details
        if self.data_treatment_description is not None:
            json[&#39;dataTreatmentDescription&#39;] = self.data_treatment_description
        if self.inventory_method_description is not None:
            json[&#39;inventoryMethodDescription&#39;] = self.inventory_method_description
        if self.modeling_constants_description is not None:
            json[&#39;modelingConstantsDescription&#39;] = self.modeling_constants_description
        if self.reviewer is not None:
            json[&#39;reviewer&#39;] = self.reviewer.to_json()
        if self.sampling_description is not None:
            json[&#39;samplingDescription&#39;] = self.sampling_description
        if self.sources is not None:
            json[&#39;sources&#39;] = []
            for e in self.sources:
                json[&#39;sources&#39;].append(e.to_json())
        if self.restrictions_description is not None:
            json[&#39;restrictionsDescription&#39;] = self.restrictions_description
        if self.copyright is not None:
            json[&#39;copyright&#39;] = self.copyright
        if self.creation_date is not None:
            json[&#39;creationDate&#39;] = self.creation_date
        if self.data_documentor is not None:
            json[&#39;dataDocumentor&#39;] = self.data_documentor.to_json()
        if self.data_generator is not None:
            json[&#39;dataGenerator&#39;] = self.data_generator.to_json()
        if self.data_set_owner is not None:
            json[&#39;dataSetOwner&#39;] = self.data_set_owner.to_json()
        if self.intended_application is not None:
            json[&#39;intendedApplication&#39;] = self.intended_application
        if self.project_description is not None:
            json[&#39;projectDescription&#39;] = self.project_description
        if self.publication is not None:
            json[&#39;publication&#39;] = self.publication.to_json()
        if self.geography_description is not None:
            json[&#39;geographyDescription&#39;] = self.geography_description
        return json

    def read_json(self, json: dict):
        super(ProcessDocumentation, self).read_json(json)
        val = json.get(&#39;timeDescription&#39;)
        if val is not None:
            self.time_description = val
        val = json.get(&#39;validUntil&#39;)
        if val is not None:
            self.valid_until = val
        val = json.get(&#39;validFrom&#39;)
        if val is not None:
            self.valid_from = val
        val = json.get(&#39;technologyDescription&#39;)
        if val is not None:
            self.technology_description = val
        val = json.get(&#39;dataCollectionDescription&#39;)
        if val is not None:
            self.data_collection_description = val
        val = json.get(&#39;completenessDescription&#39;)
        if val is not None:
            self.completeness_description = val
        val = json.get(&#39;dataSelectionDescription&#39;)
        if val is not None:
            self.data_selection_description = val
        val = json.get(&#39;reviewDetails&#39;)
        if val is not None:
            self.review_details = val
        val = json.get(&#39;dataTreatmentDescription&#39;)
        if val is not None:
            self.data_treatment_description = val
        val = json.get(&#39;inventoryMethodDescription&#39;)
        if val is not None:
            self.inventory_method_description = val
        val = json.get(&#39;modelingConstantsDescription&#39;)
        if val is not None:
            self.modeling_constants_description = val
        val = json.get(&#39;reviewer&#39;)
        if val is not None:
            self.reviewer = Ref()
            self.reviewer.read_json(val)
        val = json.get(&#39;samplingDescription&#39;)
        if val is not None:
            self.sampling_description = val
        val = json.get(&#39;sources&#39;)
        if val is not None:
            self.sources = []
            for d in val:
                e = Ref()
                e.read_json(d)
                self.sources.append(e)
        val = json.get(&#39;restrictionsDescription&#39;)
        if val is not None:
            self.restrictions_description = val
        val = json.get(&#39;copyright&#39;)
        if val is not None:
            self.copyright = val
        val = json.get(&#39;creationDate&#39;)
        if val is not None:
            self.creation_date = val
        val = json.get(&#39;dataDocumentor&#39;)
        if val is not None:
            self.data_documentor = Ref()
            self.data_documentor.read_json(val)
        val = json.get(&#39;dataGenerator&#39;)
        if val is not None:
            self.data_generator = Ref()
            self.data_generator.read_json(val)
        val = json.get(&#39;dataSetOwner&#39;)
        if val is not None:
            self.data_set_owner = Ref()
            self.data_set_owner.read_json(val)
        val = json.get(&#39;intendedApplication&#39;)
        if val is not None:
            self.intended_application = val
        val = json.get(&#39;projectDescription&#39;)
        if val is not None:
            self.project_description = val
        val = json.get(&#39;publication&#39;)
        if val is not None:
            self.publication = Ref()
            self.publication.read_json(val)
        val = json.get(&#39;geographyDescription&#39;)
        if val is not None:
            self.geography_description = val

    @staticmethod
    def from_json(json: dict):
        instance = ProcessDocumentation()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.ProcessDocumentation.completeness_description"><code class="name">var <span class="ident">completeness_description</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProcessDocumentation.copyright"><code class="name">var <span class="ident">copyright</span> :Optional[bool]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProcessDocumentation.creation_date"><code class="name">var <span class="ident">creation_date</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProcessDocumentation.data_collection_description"><code class="name">var <span class="ident">data_collection_description</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProcessDocumentation.data_documentor"><code class="name">var <span class="ident">data_documentor</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProcessDocumentation.data_generator"><code class="name">var <span class="ident">data_generator</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProcessDocumentation.data_selection_description"><code class="name">var <span class="ident">data_selection_description</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProcessDocumentation.data_set_owner"><code class="name">var <span class="ident">data_set_owner</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProcessDocumentation.data_treatment_description"><code class="name">var <span class="ident">data_treatment_description</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProcessDocumentation.geography_description"><code class="name">var <span class="ident">geography_description</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProcessDocumentation.intended_application"><code class="name">var <span class="ident">intended_application</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProcessDocumentation.inventory_method_description"><code class="name">var <span class="ident">inventory_method_description</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProcessDocumentation.modeling_constants_description"><code class="name">var <span class="ident">modeling_constants_description</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProcessDocumentation.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProcessDocumentation.project_description"><code class="name">var <span class="ident">project_description</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProcessDocumentation.publication"><code class="name">var <span class="ident">publication</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProcessDocumentation.restrictions_description"><code class="name">var <span class="ident">restrictions_description</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProcessDocumentation.review_details"><code class="name">var <span class="ident">review_details</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProcessDocumentation.reviewer"><code class="name">var <span class="ident">reviewer</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProcessDocumentation.sampling_description"><code class="name">var <span class="ident">sampling_description</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProcessDocumentation.sources"><code class="name">var <span class="ident">sources</span> :Optional[list]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProcessDocumentation.technology_description"><code class="name">var <span class="ident">technology_description</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProcessDocumentation.time_description"><code class="name">var <span class="ident">time_description</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProcessDocumentation.valid_from"><code class="name">var <span class="ident">valid_from</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProcessDocumentation.valid_until"><code class="name">var <span class="ident">valid_until</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.ProcessDocumentation.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = ProcessDocumentation()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.ProcessDocumentation.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(ProcessDocumentation, self).read_json(json)
    val = json.get(&#39;timeDescription&#39;)
    if val is not None:
        self.time_description = val
    val = json.get(&#39;validUntil&#39;)
    if val is not None:
        self.valid_until = val
    val = json.get(&#39;validFrom&#39;)
    if val is not None:
        self.valid_from = val
    val = json.get(&#39;technologyDescription&#39;)
    if val is not None:
        self.technology_description = val
    val = json.get(&#39;dataCollectionDescription&#39;)
    if val is not None:
        self.data_collection_description = val
    val = json.get(&#39;completenessDescription&#39;)
    if val is not None:
        self.completeness_description = val
    val = json.get(&#39;dataSelectionDescription&#39;)
    if val is not None:
        self.data_selection_description = val
    val = json.get(&#39;reviewDetails&#39;)
    if val is not None:
        self.review_details = val
    val = json.get(&#39;dataTreatmentDescription&#39;)
    if val is not None:
        self.data_treatment_description = val
    val = json.get(&#39;inventoryMethodDescription&#39;)
    if val is not None:
        self.inventory_method_description = val
    val = json.get(&#39;modelingConstantsDescription&#39;)
    if val is not None:
        self.modeling_constants_description = val
    val = json.get(&#39;reviewer&#39;)
    if val is not None:
        self.reviewer = Ref()
        self.reviewer.read_json(val)
    val = json.get(&#39;samplingDescription&#39;)
    if val is not None:
        self.sampling_description = val
    val = json.get(&#39;sources&#39;)
    if val is not None:
        self.sources = []
        for d in val:
            e = Ref()
            e.read_json(d)
            self.sources.append(e)
    val = json.get(&#39;restrictionsDescription&#39;)
    if val is not None:
        self.restrictions_description = val
    val = json.get(&#39;copyright&#39;)
    if val is not None:
        self.copyright = val
    val = json.get(&#39;creationDate&#39;)
    if val is not None:
        self.creation_date = val
    val = json.get(&#39;dataDocumentor&#39;)
    if val is not None:
        self.data_documentor = Ref()
        self.data_documentor.read_json(val)
    val = json.get(&#39;dataGenerator&#39;)
    if val is not None:
        self.data_generator = Ref()
        self.data_generator.read_json(val)
    val = json.get(&#39;dataSetOwner&#39;)
    if val is not None:
        self.data_set_owner = Ref()
        self.data_set_owner.read_json(val)
    val = json.get(&#39;intendedApplication&#39;)
    if val is not None:
        self.intended_application = val
    val = json.get(&#39;projectDescription&#39;)
    if val is not None:
        self.project_description = val
    val = json.get(&#39;publication&#39;)
    if val is not None:
        self.publication = Ref()
        self.publication.read_json(val)
    val = json.get(&#39;geographyDescription&#39;)
    if val is not None:
        self.geography_description = val</code></pre>
</details>
</dd>
<dt id="olca.schema.ProcessDocumentation.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(ProcessDocumentation, self).to_json()
    if self.time_description is not None:
        json[&#39;timeDescription&#39;] = self.time_description
    if self.valid_until is not None:
        json[&#39;validUntil&#39;] = self.valid_until
    if self.valid_from is not None:
        json[&#39;validFrom&#39;] = self.valid_from
    if self.technology_description is not None:
        json[&#39;technologyDescription&#39;] = self.technology_description
    if self.data_collection_description is not None:
        json[&#39;dataCollectionDescription&#39;] = self.data_collection_description
    if self.completeness_description is not None:
        json[&#39;completenessDescription&#39;] = self.completeness_description
    if self.data_selection_description is not None:
        json[&#39;dataSelectionDescription&#39;] = self.data_selection_description
    if self.review_details is not None:
        json[&#39;reviewDetails&#39;] = self.review_details
    if self.data_treatment_description is not None:
        json[&#39;dataTreatmentDescription&#39;] = self.data_treatment_description
    if self.inventory_method_description is not None:
        json[&#39;inventoryMethodDescription&#39;] = self.inventory_method_description
    if self.modeling_constants_description is not None:
        json[&#39;modelingConstantsDescription&#39;] = self.modeling_constants_description
    if self.reviewer is not None:
        json[&#39;reviewer&#39;] = self.reviewer.to_json()
    if self.sampling_description is not None:
        json[&#39;samplingDescription&#39;] = self.sampling_description
    if self.sources is not None:
        json[&#39;sources&#39;] = []
        for e in self.sources:
            json[&#39;sources&#39;].append(e.to_json())
    if self.restrictions_description is not None:
        json[&#39;restrictionsDescription&#39;] = self.restrictions_description
    if self.copyright is not None:
        json[&#39;copyright&#39;] = self.copyright
    if self.creation_date is not None:
        json[&#39;creationDate&#39;] = self.creation_date
    if self.data_documentor is not None:
        json[&#39;dataDocumentor&#39;] = self.data_documentor.to_json()
    if self.data_generator is not None:
        json[&#39;dataGenerator&#39;] = self.data_generator.to_json()
    if self.data_set_owner is not None:
        json[&#39;dataSetOwner&#39;] = self.data_set_owner.to_json()
    if self.intended_application is not None:
        json[&#39;intendedApplication&#39;] = self.intended_application
    if self.project_description is not None:
        json[&#39;projectDescription&#39;] = self.project_description
    if self.publication is not None:
        json[&#39;publication&#39;] = self.publication.to_json()
    if self.geography_description is not None:
        json[&#39;geographyDescription&#39;] = self.geography_description
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.ProcessLink"><code class="flex name class">
<span>class <span class="ident">ProcessLink</span></span>
<span>(</span><span>id:str='', olca_type:str='ProcessLink', provider:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, flow:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, process:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, exchange:Optional[<a title="olca.schema.ExchangeRef" href="#olca.schema.ExchangeRef">ExchangeRef</a>]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A process link is a connection between two processes in a product system.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>provider</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The descriptor of the process or product system that provides a product
or a waste treatment.</dd>
<dt><strong><code>flow</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The descriptor of the flow that is exchanged between the two processes.</dd>
<dt><strong><code>process</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The descriptor of the process that is linked to the provider.</dd>
<dt><strong><code>exchange</code></strong> :&ensp;<code><a title="olca.schema.ExchangeRef" href="#olca.schema.ExchangeRef">ExchangeRef</a></code></dt>
<dd>The exchange of the linked process (this is useful if the linked
process has multiple exchanges with the same flow that are linked to
different provides, e.g. in an electricity mix).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class ProcessLink(Entity):
    &#34;&#34;&#34;
    A process link is a connection between two processes in a product system.

    Attributes
    ----------
    provider: Ref
        The descriptor of the process or product system that provides a product
        or a waste treatment.

    flow: Ref
        The descriptor of the flow that is exchanged between the two processes.

    process: Ref
        The descriptor of the process that is linked to the provider.

    exchange: ExchangeRef
        The exchange of the linked process (this is useful if the linked
        process has multiple exchanges with the same flow that are linked to
        different provides, e.g. in an electricity mix).

    &#34;&#34;&#34;

    olca_type: str = &#39;ProcessLink&#39;
    provider: Optional[Ref] = None
    flow: Optional[Ref] = None
    process: Optional[Ref] = None
    exchange: Optional[ExchangeRef] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ProcessLink, self).to_json()
        if self.provider is not None:
            json[&#39;provider&#39;] = self.provider.to_json()
        if self.flow is not None:
            json[&#39;flow&#39;] = self.flow.to_json()
        if self.process is not None:
            json[&#39;process&#39;] = self.process.to_json()
        if self.exchange is not None:
            json[&#39;exchange&#39;] = self.exchange.to_json()
        return json

    def read_json(self, json: dict):
        super(ProcessLink, self).read_json(json)
        val = json.get(&#39;provider&#39;)
        if val is not None:
            self.provider = Ref()
            self.provider.read_json(val)
        val = json.get(&#39;flow&#39;)
        if val is not None:
            self.flow = Ref()
            self.flow.read_json(val)
        val = json.get(&#39;process&#39;)
        if val is not None:
            self.process = Ref()
            self.process.read_json(val)
        val = json.get(&#39;exchange&#39;)
        if val is not None:
            self.exchange = ExchangeRef()
            self.exchange.read_json(val)

    @staticmethod
    def from_json(json: dict):
        instance = ProcessLink()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.ProcessLink.exchange"><code class="name">var <span class="ident">exchange</span> :Optional[<a title="olca.schema.ExchangeRef" href="#olca.schema.ExchangeRef">ExchangeRef</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProcessLink.flow"><code class="name">var <span class="ident">flow</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProcessLink.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProcessLink.process"><code class="name">var <span class="ident">process</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProcessLink.provider"><code class="name">var <span class="ident">provider</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.ProcessLink.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = ProcessLink()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.ProcessLink.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(ProcessLink, self).read_json(json)
    val = json.get(&#39;provider&#39;)
    if val is not None:
        self.provider = Ref()
        self.provider.read_json(val)
    val = json.get(&#39;flow&#39;)
    if val is not None:
        self.flow = Ref()
        self.flow.read_json(val)
    val = json.get(&#39;process&#39;)
    if val is not None:
        self.process = Ref()
        self.process.read_json(val)
    val = json.get(&#39;exchange&#39;)
    if val is not None:
        self.exchange = ExchangeRef()
        self.exchange.read_json(val)</code></pre>
</details>
</dd>
<dt id="olca.schema.ProcessLink.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(ProcessLink, self).to_json()
    if self.provider is not None:
        json[&#39;provider&#39;] = self.provider.to_json()
    if self.flow is not None:
        json[&#39;flow&#39;] = self.flow.to_json()
    if self.process is not None:
        json[&#39;process&#39;] = self.process.to_json()
    if self.exchange is not None:
        json[&#39;exchange&#39;] = self.exchange.to_json()
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.ProcessType"><code class="flex name class">
<span>class <span class="ident">ProcessType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProcessType(Enum):
    LCI_RESULT = &#39;LCI_RESULT&#39;
    UNIT_PROCESS = &#39;UNIT_PROCESS&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.ProcessType.LCI_RESULT"><code class="name">var <span class="ident">LCI_RESULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProcessType.UNIT_PROCESS"><code class="name">var <span class="ident">UNIT_PROCESS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="olca.schema.ProductSystem"><code class="flex name class">
<span>class <span class="ident">ProductSystem</span></span>
<span>(</span><span>id:str='', olca_type:str='ProductSystem', name:Optional[str]=None, description:Optional[str]=None, version:Optional[str]=None, last_change:Optional[str]=None, category:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, tags:Optional[list[str]]=None, library:Optional[str]=None, processes:Optional[list[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]]=None, reference_process:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, reference_exchange:Optional[<a title="olca.schema.ExchangeRef" href="#olca.schema.ExchangeRef">ExchangeRef</a>]=None, target_amount:Optional[float]=None, target_unit:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, target_flow_property:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, process_links:Optional[list[<a title="olca.schema.ProcessLink" href="#olca.schema.ProcessLink">ProcessLink</a>]]=None, parameter_sets:Optional[list[<a title="olca.schema.ParameterRedefSet" href="#olca.schema.ParameterRedefSet">ParameterRedefSet</a>]]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A product system describes the supply chain of a product (the functional
unit) &hellip;</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>processes</code></strong> :&ensp;<code>list[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>The descriptors of all processes and sub-systems that are contained in
the product system.</dd>
<dt><strong><code>reference_process</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The descriptor of the process that provides the flow of the functional
unit of the product system.</dd>
<dt><strong><code>reference_exchange</code></strong> :&ensp;<code><a title="olca.schema.ExchangeRef" href="#olca.schema.ExchangeRef">ExchangeRef</a></code></dt>
<dd>The exchange of the reference processes (typically the product output)
that provides the flow of the functional unit of the product system.</dd>
<dt><strong><code>target_amount</code></strong> :&ensp;<code>float</code></dt>
<dd>The flow amount of the functional unit of the product system.</dd>
<dt><strong><code>target_unit</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The unit in which the flow amount of the functional unit is given.</dd>
<dt><strong><code>target_flow_property</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The flow property in which the flow amount of the functional unit is
given.</dd>
<dt><strong><code>process_links</code></strong> :&ensp;<code>list[<a title="olca.schema.ProcessLink" href="#olca.schema.ProcessLink">ProcessLink</a>]</code></dt>
<dd>The process links of the product system.</dd>
<dt><strong><code>parameter_sets</code></strong> :&ensp;<code>list[<a title="olca.schema.ParameterRedefSet" href="#olca.schema.ParameterRedefSet">ParameterRedefSet</a>]</code></dt>
<dd>A list of possible sets of parameter redefinitions for this product
system.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class ProductSystem(CategorizedEntity):
    &#34;&#34;&#34;
    A product system describes the supply chain of a product (the functional
    unit) ...

    Attributes
    ----------
    processes: list[Ref]
        The descriptors of all processes and sub-systems that are contained in
        the product system.

    reference_process: Ref
        The descriptor of the process that provides the flow of the functional
        unit of the product system.

    reference_exchange: ExchangeRef
        The exchange of the reference processes (typically the product output)
        that provides the flow of the functional unit of the product system.

    target_amount: float
        The flow amount of the functional unit of the product system.

    target_unit: Ref
        The unit in which the flow amount of the functional unit is given.

    target_flow_property: Ref
        The flow property in which the flow amount of the functional unit is
        given.

    process_links: list[ProcessLink]
        The process links of the product system.

    parameter_sets: list[ParameterRedefSet]
        A list of possible sets of parameter redefinitions for this product
        system.

    &#34;&#34;&#34;

    olca_type: str = &#39;ProductSystem&#39;
    processes: Optional[list[Ref]] = None
    reference_process: Optional[Ref] = None
    reference_exchange: Optional[ExchangeRef] = None
    target_amount: Optional[float] = None
    target_unit: Optional[Ref] = None
    target_flow_property: Optional[Ref] = None
    process_links: Optional[list[ProcessLink]] = None
    parameter_sets: Optional[list[ParameterRedefSet]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(ProductSystem, self).to_json()
        if self.processes is not None:
            json[&#39;processes&#39;] = []
            for e in self.processes:
                json[&#39;processes&#39;].append(e.to_json())
        if self.reference_process is not None:
            json[&#39;referenceProcess&#39;] = self.reference_process.to_json()
        if self.reference_exchange is not None:
            json[&#39;referenceExchange&#39;] = self.reference_exchange.to_json()
        if self.target_amount is not None:
            json[&#39;targetAmount&#39;] = self.target_amount
        if self.target_unit is not None:
            json[&#39;targetUnit&#39;] = self.target_unit.to_json()
        if self.target_flow_property is not None:
            json[&#39;targetFlowProperty&#39;] = self.target_flow_property.to_json()
        if self.process_links is not None:
            json[&#39;processLinks&#39;] = []
            for e in self.process_links:
                json[&#39;processLinks&#39;].append(e.to_json())
        if self.parameter_sets is not None:
            json[&#39;parameterSets&#39;] = []
            for e in self.parameter_sets:
                json[&#39;parameterSets&#39;].append(e.to_json())
        return json

    def read_json(self, json: dict):
        super(ProductSystem, self).read_json(json)
        val = json.get(&#39;processes&#39;)
        if val is not None:
            self.processes = []
            for d in val:
                e = Ref()
                e.read_json(d)
                self.processes.append(e)
        val = json.get(&#39;referenceProcess&#39;)
        if val is not None:
            self.reference_process = Ref()
            self.reference_process.read_json(val)
        val = json.get(&#39;referenceExchange&#39;)
        if val is not None:
            self.reference_exchange = ExchangeRef()
            self.reference_exchange.read_json(val)
        val = json.get(&#39;targetAmount&#39;)
        if val is not None:
            self.target_amount = val
        val = json.get(&#39;targetUnit&#39;)
        if val is not None:
            self.target_unit = Ref()
            self.target_unit.read_json(val)
        val = json.get(&#39;targetFlowProperty&#39;)
        if val is not None:
            self.target_flow_property = Ref()
            self.target_flow_property.read_json(val)
        val = json.get(&#39;processLinks&#39;)
        if val is not None:
            self.process_links = []
            for d in val:
                e = ProcessLink()
                e.read_json(d)
                self.process_links.append(e)
        val = json.get(&#39;parameterSets&#39;)
        if val is not None:
            self.parameter_sets = []
            for d in val:
                e = ParameterRedefSet()
                e.read_json(d)
                self.parameter_sets.append(e)

    @staticmethod
    def from_json(json: dict):
        instance = ProductSystem()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.CategorizedEntity" href="#olca.schema.CategorizedEntity">CategorizedEntity</a></li>
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.ProductSystem.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProductSystem.parameter_sets"><code class="name">var <span class="ident">parameter_sets</span> :Optional[list]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProductSystem.process_links"><code class="name">var <span class="ident">process_links</span> :Optional[list]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProductSystem.processes"><code class="name">var <span class="ident">processes</span> :Optional[list]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProductSystem.reference_exchange"><code class="name">var <span class="ident">reference_exchange</span> :Optional[<a title="olca.schema.ExchangeRef" href="#olca.schema.ExchangeRef">ExchangeRef</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProductSystem.reference_process"><code class="name">var <span class="ident">reference_process</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProductSystem.target_amount"><code class="name">var <span class="ident">target_amount</span> :Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProductSystem.target_flow_property"><code class="name">var <span class="ident">target_flow_property</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.ProductSystem.target_unit"><code class="name">var <span class="ident">target_unit</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.ProductSystem.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = ProductSystem()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.ProductSystem.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(ProductSystem, self).read_json(json)
    val = json.get(&#39;processes&#39;)
    if val is not None:
        self.processes = []
        for d in val:
            e = Ref()
            e.read_json(d)
            self.processes.append(e)
    val = json.get(&#39;referenceProcess&#39;)
    if val is not None:
        self.reference_process = Ref()
        self.reference_process.read_json(val)
    val = json.get(&#39;referenceExchange&#39;)
    if val is not None:
        self.reference_exchange = ExchangeRef()
        self.reference_exchange.read_json(val)
    val = json.get(&#39;targetAmount&#39;)
    if val is not None:
        self.target_amount = val
    val = json.get(&#39;targetUnit&#39;)
    if val is not None:
        self.target_unit = Ref()
        self.target_unit.read_json(val)
    val = json.get(&#39;targetFlowProperty&#39;)
    if val is not None:
        self.target_flow_property = Ref()
        self.target_flow_property.read_json(val)
    val = json.get(&#39;processLinks&#39;)
    if val is not None:
        self.process_links = []
        for d in val:
            e = ProcessLink()
            e.read_json(d)
            self.process_links.append(e)
    val = json.get(&#39;parameterSets&#39;)
    if val is not None:
        self.parameter_sets = []
        for d in val:
            e = ParameterRedefSet()
            e.read_json(d)
            self.parameter_sets.append(e)</code></pre>
</details>
</dd>
<dt id="olca.schema.ProductSystem.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(ProductSystem, self).to_json()
    if self.processes is not None:
        json[&#39;processes&#39;] = []
        for e in self.processes:
            json[&#39;processes&#39;].append(e.to_json())
    if self.reference_process is not None:
        json[&#39;referenceProcess&#39;] = self.reference_process.to_json()
    if self.reference_exchange is not None:
        json[&#39;referenceExchange&#39;] = self.reference_exchange.to_json()
    if self.target_amount is not None:
        json[&#39;targetAmount&#39;] = self.target_amount
    if self.target_unit is not None:
        json[&#39;targetUnit&#39;] = self.target_unit.to_json()
    if self.target_flow_property is not None:
        json[&#39;targetFlowProperty&#39;] = self.target_flow_property.to_json()
    if self.process_links is not None:
        json[&#39;processLinks&#39;] = []
        for e in self.process_links:
            json[&#39;processLinks&#39;].append(e.to_json())
    if self.parameter_sets is not None:
        json[&#39;parameterSets&#39;] = []
        for e in self.parameter_sets:
            json[&#39;parameterSets&#39;].append(e.to_json())
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.Project"><code class="flex name class">
<span>class <span class="ident">Project</span></span>
<span>(</span><span>id:str='', olca_type:str='Project', name:Optional[str]=None, description:Optional[str]=None, version:Optional[str]=None, last_change:Optional[str]=None, category:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, tags:Optional[list[str]]=None, library:Optional[str]=None, impact_method:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, nw_set:Optional[<a title="olca.schema.NwSet" href="#olca.schema.NwSet">NwSet</a>]=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>impact_method</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>nw_set</code></strong> :&ensp;<code><a title="olca.schema.NwSet" href="#olca.schema.NwSet">NwSet</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Project(CategorizedEntity):
    &#34;&#34;&#34;


    Attributes
    ----------
    impact_method: Ref

    nw_set: NwSet

    &#34;&#34;&#34;

    olca_type: str = &#39;Project&#39;
    impact_method: Optional[Ref] = None
    nw_set: Optional[NwSet] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Project, self).to_json()
        if self.impact_method is not None:
            json[&#39;impactMethod&#39;] = self.impact_method.to_json()
        if self.nw_set is not None:
            json[&#39;nwSet&#39;] = self.nw_set.to_json()
        return json

    def read_json(self, json: dict):
        super(Project, self).read_json(json)
        val = json.get(&#39;impactMethod&#39;)
        if val is not None:
            self.impact_method = Ref()
            self.impact_method.read_json(val)
        val = json.get(&#39;nwSet&#39;)
        if val is not None:
            self.nw_set = NwSet()
            self.nw_set.read_json(val)

    @staticmethod
    def from_json(json: dict):
        instance = Project()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.CategorizedEntity" href="#olca.schema.CategorizedEntity">CategorizedEntity</a></li>
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.Project.impact_method"><code class="name">var <span class="ident">impact_method</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Project.nw_set"><code class="name">var <span class="ident">nw_set</span> :Optional[<a title="olca.schema.NwSet" href="#olca.schema.NwSet">NwSet</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Project.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.Project.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = Project()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.Project.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(Project, self).read_json(json)
    val = json.get(&#39;impactMethod&#39;)
    if val is not None:
        self.impact_method = Ref()
        self.impact_method.read_json(val)
    val = json.get(&#39;nwSet&#39;)
    if val is not None:
        self.nw_set = NwSet()
        self.nw_set.read_json(val)</code></pre>
</details>
</dd>
<dt id="olca.schema.Project.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(Project, self).to_json()
    if self.impact_method is not None:
        json[&#39;impactMethod&#39;] = self.impact_method.to_json()
    if self.nw_set is not None:
        json[&#39;nwSet&#39;] = self.nw_set.to_json()
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.Ref"><code class="flex name class">
<span>class <span class="ident">Ref</span></span>
<span>(</span><span>id:str='', olca_type:str='Ref', name:Optional[str]=None, description:Optional[str]=None, version:Optional[str]=None, last_change:Optional[str]=None, category_path:Optional[list[str]]=None, library:Optional[str]=None, ref_unit:Optional[str]=None, location:Optional[str]=None, flow_type:Optional[<a title="olca.schema.FlowType" href="#olca.schema.FlowType">FlowType</a>]=None, process_type:Optional[<a title="olca.schema.ProcessType" href="#olca.schema.ProcessType">ProcessType</a>]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A Ref is a reference to a [RootEntity]. When serializing an entity (e.g. a
[Process]) that references another standalone entity (e.g. a [Flow] in an
[Exchange]) we do not want to write the complete referenced entity into the
serialized JSON object but just a reference. However, the reference
contains some meta-data like name, category path etc. that are useful to
display.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>category_path</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>The full path of the category of the referenced entity from top to
bottom, e.g. <code>"Elementary flows", "Emissions to air", "unspecified"</code>.</dd>
<dt><strong><code>library</code></strong> :&ensp;<code>str</code></dt>
<dd>If the entity that is described by this reference is part of a library,
this field contains the identifier of that library. The identifier is
typically just the combination of the library name and version.</dd>
<dt><strong><code>ref_unit</code></strong> :&ensp;<code>str</code></dt>
<dd>This field is only valid for references of flows or impact categories
and contains the name (symbol) of the reference unit of that respective
flow or impact category.</dd>
<dt><strong><code>location</code></strong> :&ensp;<code>str</code></dt>
<dd>This field is only valid for references of processes or flows and
contains the location name or code of that respective process or flow.</dd>
<dt><strong><code>flow_type</code></strong> :&ensp;<code><a title="olca.schema.FlowType" href="#olca.schema.FlowType">FlowType</a></code></dt>
<dd>In case of a reference to a flow, this field can contain the type of
flow that is referenced.</dd>
<dt><strong><code>process_type</code></strong> :&ensp;<code><a title="olca.schema.ProcessType" href="#olca.schema.ProcessType">ProcessType</a></code></dt>
<dd>In case of a reference to a process, this fiel can contain the type of
process that is referenced.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Ref(RootEntity):
    &#34;&#34;&#34;
    A Ref is a reference to a [RootEntity]. When serializing an entity (e.g. a
    [Process]) that references another standalone entity (e.g. a [Flow] in an
    [Exchange]) we do not want to write the complete referenced entity into the
    serialized JSON object but just a reference. However, the reference
    contains some meta-data like name, category path etc. that are useful to
    display.

    Attributes
    ----------
    category_path: list[str]
        The full path of the category of the referenced entity from top to
        bottom, e.g. `&#34;Elementary flows&#34;, &#34;Emissions to air&#34;, &#34;unspecified&#34;`.

    library: str
        If the entity that is described by this reference is part of a library,
        this field contains the identifier of that library. The identifier is
        typically just the combination of the library name and version.

    ref_unit: str
        This field is only valid for references of flows or impact categories
        and contains the name (symbol) of the reference unit of that respective
        flow or impact category.

    location: str
        This field is only valid for references of processes or flows and
        contains the location name or code of that respective process or flow.

    flow_type: FlowType
        In case of a reference to a flow, this field can contain the type of
        flow that is referenced.

    process_type: ProcessType
        In case of a reference to a process, this fiel can contain the type of
        process that is referenced.

    &#34;&#34;&#34;

    olca_type: str = &#39;Ref&#39;
    category_path: Optional[list[str]] = None
    library: Optional[str] = None
    ref_unit: Optional[str] = None
    location: Optional[str] = None
    flow_type: Optional[FlowType] = None
    process_type: Optional[ProcessType] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Ref, self).to_json()
        if self.category_path is not None:
            json[&#39;categoryPath&#39;] = []
            for e in self.category_path:
                json[&#39;categoryPath&#39;].append(e)
        if self.library is not None:
            json[&#39;library&#39;] = self.library
        if self.ref_unit is not None:
            json[&#39;refUnit&#39;] = self.ref_unit
        if self.location is not None:
            json[&#39;location&#39;] = self.location
        if self.flow_type is not None:
            json[&#39;flowType&#39;] = self.flow_type.value
        if self.process_type is not None:
            json[&#39;processType&#39;] = self.process_type.value
        return json

    def read_json(self, json: dict):
        super(Ref, self).read_json(json)
        val = json.get(&#39;categoryPath&#39;)
        if val is not None:
            self.category_path = []
            for d in val:
                e = d
                self.category_path.append(e)
        val = json.get(&#39;library&#39;)
        if val is not None:
            self.library = val
        val = json.get(&#39;refUnit&#39;)
        if val is not None:
            self.ref_unit = val
        val = json.get(&#39;location&#39;)
        if val is not None:
            self.location = val
        val = json.get(&#39;flowType&#39;)
        if val is not None:
            self.flow_type = FlowType(val)
        val = json.get(&#39;processType&#39;)
        if val is not None:
            self.process_type = ProcessType(val)

    @staticmethod
    def from_json(json: dict):
        instance = Ref()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.Ref.category_path"><code class="name">var <span class="ident">category_path</span> :Optional[list]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Ref.flow_type"><code class="name">var <span class="ident">flow_type</span> :Optional[<a title="olca.schema.FlowType" href="#olca.schema.FlowType">FlowType</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Ref.library"><code class="name">var <span class="ident">library</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Ref.location"><code class="name">var <span class="ident">location</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Ref.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Ref.process_type"><code class="name">var <span class="ident">process_type</span> :Optional[<a title="olca.schema.ProcessType" href="#olca.schema.ProcessType">ProcessType</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Ref.ref_unit"><code class="name">var <span class="ident">ref_unit</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.Ref.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = Ref()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.Ref.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(Ref, self).read_json(json)
    val = json.get(&#39;categoryPath&#39;)
    if val is not None:
        self.category_path = []
        for d in val:
            e = d
            self.category_path.append(e)
    val = json.get(&#39;library&#39;)
    if val is not None:
        self.library = val
    val = json.get(&#39;refUnit&#39;)
    if val is not None:
        self.ref_unit = val
    val = json.get(&#39;location&#39;)
    if val is not None:
        self.location = val
    val = json.get(&#39;flowType&#39;)
    if val is not None:
        self.flow_type = FlowType(val)
    val = json.get(&#39;processType&#39;)
    if val is not None:
        self.process_type = ProcessType(val)</code></pre>
</details>
</dd>
<dt id="olca.schema.Ref.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(Ref, self).to_json()
    if self.category_path is not None:
        json[&#39;categoryPath&#39;] = []
        for e in self.category_path:
            json[&#39;categoryPath&#39;].append(e)
    if self.library is not None:
        json[&#39;library&#39;] = self.library
    if self.ref_unit is not None:
        json[&#39;refUnit&#39;] = self.ref_unit
    if self.location is not None:
        json[&#39;location&#39;] = self.location
    if self.flow_type is not None:
        json[&#39;flowType&#39;] = self.flow_type.value
    if self.process_type is not None:
        json[&#39;processType&#39;] = self.process_type.value
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.RiskLevel"><code class="flex name class">
<span>class <span class="ident">RiskLevel</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RiskLevel(Enum):
    &#34;&#34;&#34;

    &#34;&#34;&#34;

    NO_OPPORTUNITY = &#39;NO_OPPORTUNITY&#39;
    HIGH_OPPORTUNITY = &#39;HIGH_OPPORTUNITY&#39;
    MEDIUM_OPPORTUNITY = &#39;MEDIUM_OPPORTUNITY&#39;
    LOW_OPPORTUNITY = &#39;LOW_OPPORTUNITY&#39;
    NO_RISK = &#39;NO_RISK&#39;
    VERY_LOW_RISK = &#39;VERY_LOW_RISK&#39;
    LOW_RISK = &#39;LOW_RISK&#39;
    MEDIUM_RISK = &#39;MEDIUM_RISK&#39;
    HIGH_RISK = &#39;HIGH_RISK&#39;
    VERY_HIGH_RISK = &#39;VERY_HIGH_RISK&#39;
    NO_DATA = &#39;NO_DATA&#39;
    NOT_APPLICABLE = &#39;NOT_APPLICABLE&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.RiskLevel.HIGH_OPPORTUNITY"><code class="name">var <span class="ident">HIGH_OPPORTUNITY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.RiskLevel.HIGH_RISK"><code class="name">var <span class="ident">HIGH_RISK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.RiskLevel.LOW_OPPORTUNITY"><code class="name">var <span class="ident">LOW_OPPORTUNITY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.RiskLevel.LOW_RISK"><code class="name">var <span class="ident">LOW_RISK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.RiskLevel.MEDIUM_OPPORTUNITY"><code class="name">var <span class="ident">MEDIUM_OPPORTUNITY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.RiskLevel.MEDIUM_RISK"><code class="name">var <span class="ident">MEDIUM_RISK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.RiskLevel.NOT_APPLICABLE"><code class="name">var <span class="ident">NOT_APPLICABLE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.RiskLevel.NO_DATA"><code class="name">var <span class="ident">NO_DATA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.RiskLevel.NO_OPPORTUNITY"><code class="name">var <span class="ident">NO_OPPORTUNITY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.RiskLevel.NO_RISK"><code class="name">var <span class="ident">NO_RISK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.RiskLevel.VERY_HIGH_RISK"><code class="name">var <span class="ident">VERY_HIGH_RISK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.RiskLevel.VERY_LOW_RISK"><code class="name">var <span class="ident">VERY_LOW_RISK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="olca.schema.RootEntity"><code class="flex name class">
<span>class <span class="ident">RootEntity</span></span>
<span>(</span><span>id:str='', olca_type:str='', name:Optional[str]=None, description:Optional[str]=None, version:Optional[str]=None, last_change:Optional[str]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A standalone item in a database like a location, unit group, flow, or
process. A root entity can be unambiguously identified by its id (the
JSON-LD @id field), version, and lastChange fields.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the entity.</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code></dt>
<dd>The description of the entity.</dd>
<dt><strong><code>version</code></strong> :&ensp;<code>str</code></dt>
<dd>A version number in MAJOR.MINOR.PATCH format where the MINOR and PATCH
fields are optional and the fields may have leading zeros (so 01.00.00
is the same as 1.0.0 or 1).</dd>
<dt><strong><code>last_change</code></strong> :&ensp;<code>str</code></dt>
<dd>The timestamp when the entity was changed the last time.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class RootEntity(Entity):
    &#34;&#34;&#34;
    A standalone item in a database like a location, unit group, flow, or
    process. A root entity can be unambiguously identified by its id (the
    JSON-LD @id field), version, and lastChange fields.

    Attributes
    ----------
    name: str
        The name of the entity.

    description: str
        The description of the entity.

    version: str
        A version number in MAJOR.MINOR.PATCH format where the MINOR and PATCH
        fields are optional and the fields may have leading zeros (so 01.00.00
        is the same as 1.0.0 or 1).

    last_change: str
        The timestamp when the entity was changed the last time.

    &#34;&#34;&#34;

    name: Optional[str] = None
    description: Optional[str] = None
    version: Optional[str] = None
    last_change: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(RootEntity, self).to_json()
        if self.name is not None:
            json[&#39;name&#39;] = self.name
        if self.description is not None:
            json[&#39;description&#39;] = self.description
        if self.version is not None:
            json[&#39;version&#39;] = self.version
        if self.last_change is not None:
            json[&#39;lastChange&#39;] = self.last_change
        return json

    def read_json(self, json: dict):
        super(RootEntity, self).read_json(json)
        val = json.get(&#39;name&#39;)
        if val is not None:
            self.name = val
        val = json.get(&#39;description&#39;)
        if val is not None:
            self.description = val
        val = json.get(&#39;version&#39;)
        if val is not None:
            self.version = val
        val = json.get(&#39;lastChange&#39;)
        if val is not None:
            self.last_change = val

    @staticmethod
    def from_json(json: dict):
        instance = RootEntity()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="olca.schema.CategorizedEntity" href="#olca.schema.CategorizedEntity">CategorizedEntity</a></li>
<li><a title="olca.schema.FlowMap" href="#olca.schema.FlowMap">FlowMap</a></li>
<li><a title="olca.schema.NwSet" href="#olca.schema.NwSet">NwSet</a></li>
<li><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></li>
<li><a title="olca.schema.Unit" href="#olca.schema.Unit">Unit</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.RootEntity.description"><code class="name">var <span class="ident">description</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.RootEntity.last_change"><code class="name">var <span class="ident">last_change</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.RootEntity.name"><code class="name">var <span class="ident">name</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.RootEntity.version"><code class="name">var <span class="ident">version</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.RootEntity.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = RootEntity()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.RootEntity.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(RootEntity, self).read_json(json)
    val = json.get(&#39;name&#39;)
    if val is not None:
        self.name = val
    val = json.get(&#39;description&#39;)
    if val is not None:
        self.description = val
    val = json.get(&#39;version&#39;)
    if val is not None:
        self.version = val
    val = json.get(&#39;lastChange&#39;)
    if val is not None:
        self.last_change = val</code></pre>
</details>
</dd>
<dt id="olca.schema.RootEntity.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(RootEntity, self).to_json()
    if self.name is not None:
        json[&#39;name&#39;] = self.name
    if self.description is not None:
        json[&#39;description&#39;] = self.description
    if self.version is not None:
        json[&#39;version&#39;] = self.version
    if self.last_change is not None:
        json[&#39;lastChange&#39;] = self.last_change
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.SimpleResult"><code class="flex name class">
<span>class <span class="ident">SimpleResult</span></span>
<span>(</span><span>id:str='', olca_type:str='SimpleResult', flow_results:Optional[list[<a title="olca.schema.FlowResult" href="#olca.schema.FlowResult">FlowResult</a>]]=None, impact_results:Optional[list[<a title="olca.schema.ImpactResult" href="#olca.schema.ImpactResult">ImpactResult</a>]]=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>flow_results</code></strong> :&ensp;<code>list[<a title="olca.schema.FlowResult" href="#olca.schema.FlowResult">FlowResult</a>]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>impact_results</code></strong> :&ensp;<code>list[<a title="olca.schema.ImpactResult" href="#olca.schema.ImpactResult">ImpactResult</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class SimpleResult(Entity):
    &#34;&#34;&#34;


    Attributes
    ----------
    flow_results: list[FlowResult]

    impact_results: list[ImpactResult]

    &#34;&#34;&#34;

    olca_type: str = &#39;SimpleResult&#39;
    flow_results: Optional[list[FlowResult]] = None
    impact_results: Optional[list[ImpactResult]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(SimpleResult, self).to_json()
        if self.flow_results is not None:
            json[&#39;flowResults&#39;] = []
            for e in self.flow_results:
                json[&#39;flowResults&#39;].append(e.to_json())
        if self.impact_results is not None:
            json[&#39;impactResults&#39;] = []
            for e in self.impact_results:
                json[&#39;impactResults&#39;].append(e.to_json())
        return json

    def read_json(self, json: dict):
        super(SimpleResult, self).read_json(json)
        val = json.get(&#39;flowResults&#39;)
        if val is not None:
            self.flow_results = []
            for d in val:
                e = FlowResult()
                e.read_json(d)
                self.flow_results.append(e)
        val = json.get(&#39;impactResults&#39;)
        if val is not None:
            self.impact_results = []
            for d in val:
                e = ImpactResult()
                e.read_json(d)
                self.impact_results.append(e)

    @staticmethod
    def from_json(json: dict):
        instance = SimpleResult()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.SimpleResult.flow_results"><code class="name">var <span class="ident">flow_results</span> :Optional[list]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.SimpleResult.impact_results"><code class="name">var <span class="ident">impact_results</span> :Optional[list]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.SimpleResult.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.SimpleResult.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = SimpleResult()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.SimpleResult.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(SimpleResult, self).read_json(json)
    val = json.get(&#39;flowResults&#39;)
    if val is not None:
        self.flow_results = []
        for d in val:
            e = FlowResult()
            e.read_json(d)
            self.flow_results.append(e)
    val = json.get(&#39;impactResults&#39;)
    if val is not None:
        self.impact_results = []
        for d in val:
            e = ImpactResult()
            e.read_json(d)
            self.impact_results.append(e)</code></pre>
</details>
</dd>
<dt id="olca.schema.SimpleResult.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(SimpleResult, self).to_json()
    if self.flow_results is not None:
        json[&#39;flowResults&#39;] = []
        for e in self.flow_results:
            json[&#39;flowResults&#39;].append(e.to_json())
    if self.impact_results is not None:
        json[&#39;impactResults&#39;] = []
        for e in self.impact_results:
            json[&#39;impactResults&#39;].append(e.to_json())
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.SocialAspect"><code class="flex name class">
<span>class <span class="ident">SocialAspect</span></span>
<span>(</span><span>id:str='', olca_type:str='SocialAspect', activity_value:Optional[float]=None, comment:Optional[str]=None, quality:Optional[str]=None, raw_amount:Optional[str]=None, risk_level:Optional[<a title="olca.schema.RiskLevel" href="#olca.schema.RiskLevel">RiskLevel</a>]=None, social_indicator:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, source:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>An instance of this class describes a social aspect related to a social
indicator in a process.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>activity_value</code></strong> :&ensp;<code>float</code></dt>
<dd>The value of the activity variable of the related indicator.</dd>
<dt><strong><code>comment</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>quality</code></strong> :&ensp;<code>str</code></dt>
<dd>A data quality entry, e.g. <code>(3,1,2,4,1)</code>.</dd>
<dt><strong><code>raw_amount</code></strong> :&ensp;<code>str</code></dt>
<dd>The raw amount of the indicator's unit of measurement (not required to
be numeric currently)</dd>
<dt><strong><code>risk_level</code></strong> :&ensp;<code><a title="olca.schema.RiskLevel" href="#olca.schema.RiskLevel">RiskLevel</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>social_indicator</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>source</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class SocialAspect(Entity):
    &#34;&#34;&#34;
    An instance of this class describes a social aspect related to a social
    indicator in a process.

    Attributes
    ----------
    activity_value: float
        The value of the activity variable of the related indicator.

    comment: str

    quality: str
        A data quality entry, e.g. `(3,1,2,4,1)`.

    raw_amount: str
        The raw amount of the indicator&#39;s unit of measurement (not required to
        be numeric currently)

    risk_level: RiskLevel

    social_indicator: Ref

    source: Ref

    &#34;&#34;&#34;

    olca_type: str = &#39;SocialAspect&#39;
    activity_value: Optional[float] = None
    comment: Optional[str] = None
    quality: Optional[str] = None
    raw_amount: Optional[str] = None
    risk_level: Optional[RiskLevel] = None
    social_indicator: Optional[Ref] = None
    source: Optional[Ref] = None

    def to_json(self) -&gt; dict:
        json: dict = super(SocialAspect, self).to_json()
        if self.activity_value is not None:
            json[&#39;activityValue&#39;] = self.activity_value
        if self.comment is not None:
            json[&#39;comment&#39;] = self.comment
        if self.quality is not None:
            json[&#39;quality&#39;] = self.quality
        if self.raw_amount is not None:
            json[&#39;rawAmount&#39;] = self.raw_amount
        if self.risk_level is not None:
            json[&#39;riskLevel&#39;] = self.risk_level.value
        if self.social_indicator is not None:
            json[&#39;socialIndicator&#39;] = self.social_indicator.to_json()
        if self.source is not None:
            json[&#39;source&#39;] = self.source.to_json()
        return json

    def read_json(self, json: dict):
        super(SocialAspect, self).read_json(json)
        val = json.get(&#39;activityValue&#39;)
        if val is not None:
            self.activity_value = val
        val = json.get(&#39;comment&#39;)
        if val is not None:
            self.comment = val
        val = json.get(&#39;quality&#39;)
        if val is not None:
            self.quality = val
        val = json.get(&#39;rawAmount&#39;)
        if val is not None:
            self.raw_amount = val
        val = json.get(&#39;riskLevel&#39;)
        if val is not None:
            self.risk_level = RiskLevel(val)
        val = json.get(&#39;socialIndicator&#39;)
        if val is not None:
            self.social_indicator = Ref()
            self.social_indicator.read_json(val)
        val = json.get(&#39;source&#39;)
        if val is not None:
            self.source = Ref()
            self.source.read_json(val)

    @staticmethod
    def from_json(json: dict):
        instance = SocialAspect()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.SocialAspect.activity_value"><code class="name">var <span class="ident">activity_value</span> :Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.SocialAspect.comment"><code class="name">var <span class="ident">comment</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.SocialAspect.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.SocialAspect.quality"><code class="name">var <span class="ident">quality</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.SocialAspect.raw_amount"><code class="name">var <span class="ident">raw_amount</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.SocialAspect.risk_level"><code class="name">var <span class="ident">risk_level</span> :Optional[<a title="olca.schema.RiskLevel" href="#olca.schema.RiskLevel">RiskLevel</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.SocialAspect.social_indicator"><code class="name">var <span class="ident">social_indicator</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.SocialAspect.source"><code class="name">var <span class="ident">source</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.SocialAspect.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = SocialAspect()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.SocialAspect.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(SocialAspect, self).read_json(json)
    val = json.get(&#39;activityValue&#39;)
    if val is not None:
        self.activity_value = val
    val = json.get(&#39;comment&#39;)
    if val is not None:
        self.comment = val
    val = json.get(&#39;quality&#39;)
    if val is not None:
        self.quality = val
    val = json.get(&#39;rawAmount&#39;)
    if val is not None:
        self.raw_amount = val
    val = json.get(&#39;riskLevel&#39;)
    if val is not None:
        self.risk_level = RiskLevel(val)
    val = json.get(&#39;socialIndicator&#39;)
    if val is not None:
        self.social_indicator = Ref()
        self.social_indicator.read_json(val)
    val = json.get(&#39;source&#39;)
    if val is not None:
        self.source = Ref()
        self.source.read_json(val)</code></pre>
</details>
</dd>
<dt id="olca.schema.SocialAspect.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(SocialAspect, self).to_json()
    if self.activity_value is not None:
        json[&#39;activityValue&#39;] = self.activity_value
    if self.comment is not None:
        json[&#39;comment&#39;] = self.comment
    if self.quality is not None:
        json[&#39;quality&#39;] = self.quality
    if self.raw_amount is not None:
        json[&#39;rawAmount&#39;] = self.raw_amount
    if self.risk_level is not None:
        json[&#39;riskLevel&#39;] = self.risk_level.value
    if self.social_indicator is not None:
        json[&#39;socialIndicator&#39;] = self.social_indicator.to_json()
    if self.source is not None:
        json[&#39;source&#39;] = self.source.to_json()
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.SocialIndicator"><code class="flex name class">
<span>class <span class="ident">SocialIndicator</span></span>
<span>(</span><span>id:str='', olca_type:str='SocialIndicator', name:Optional[str]=None, description:Optional[str]=None, version:Optional[str]=None, last_change:Optional[str]=None, category:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, tags:Optional[list[str]]=None, library:Optional[str]=None, activity_variable:Optional[str]=None, activity_quantity:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, activity_unit:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, unit_of_measurement:Optional[str]=None, evaluation_scheme:Optional[str]=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>activity_variable</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the activity variable of the indicator.</dd>
<dt><strong><code>activity_quantity</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The quantity of the activity variable.</dd>
<dt><strong><code>activity_unit</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>The unit of the activity variable.</dd>
<dt><strong><code>unit_of_measurement</code></strong> :&ensp;<code>str</code></dt>
<dd>The unit in which the indicator is measured.</dd>
<dt><strong><code>evaluation_scheme</code></strong> :&ensp;<code>str</code></dt>
<dd>Documentation of the evaluation scheme of the indicator.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class SocialIndicator(CategorizedEntity):
    &#34;&#34;&#34;


    Attributes
    ----------
    activity_variable: str
        The name of the activity variable of the indicator.

    activity_quantity: Ref
        The quantity of the activity variable.

    activity_unit: Ref
        The unit of the activity variable.

    unit_of_measurement: str
        The unit in which the indicator is measured.

    evaluation_scheme: str
        Documentation of the evaluation scheme of the indicator.

    &#34;&#34;&#34;

    olca_type: str = &#39;SocialIndicator&#39;
    activity_variable: Optional[str] = None
    activity_quantity: Optional[Ref] = None
    activity_unit: Optional[Ref] = None
    unit_of_measurement: Optional[str] = None
    evaluation_scheme: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(SocialIndicator, self).to_json()
        if self.activity_variable is not None:
            json[&#39;activityVariable&#39;] = self.activity_variable
        if self.activity_quantity is not None:
            json[&#39;activityQuantity&#39;] = self.activity_quantity.to_json()
        if self.activity_unit is not None:
            json[&#39;activityUnit&#39;] = self.activity_unit.to_json()
        if self.unit_of_measurement is not None:
            json[&#39;unitOfMeasurement&#39;] = self.unit_of_measurement
        if self.evaluation_scheme is not None:
            json[&#39;evaluationScheme&#39;] = self.evaluation_scheme
        return json

    def read_json(self, json: dict):
        super(SocialIndicator, self).read_json(json)
        val = json.get(&#39;activityVariable&#39;)
        if val is not None:
            self.activity_variable = val
        val = json.get(&#39;activityQuantity&#39;)
        if val is not None:
            self.activity_quantity = Ref()
            self.activity_quantity.read_json(val)
        val = json.get(&#39;activityUnit&#39;)
        if val is not None:
            self.activity_unit = Ref()
            self.activity_unit.read_json(val)
        val = json.get(&#39;unitOfMeasurement&#39;)
        if val is not None:
            self.unit_of_measurement = val
        val = json.get(&#39;evaluationScheme&#39;)
        if val is not None:
            self.evaluation_scheme = val

    @staticmethod
    def from_json(json: dict):
        instance = SocialIndicator()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.CategorizedEntity" href="#olca.schema.CategorizedEntity">CategorizedEntity</a></li>
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.SocialIndicator.activity_quantity"><code class="name">var <span class="ident">activity_quantity</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.SocialIndicator.activity_unit"><code class="name">var <span class="ident">activity_unit</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.SocialIndicator.activity_variable"><code class="name">var <span class="ident">activity_variable</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.SocialIndicator.evaluation_scheme"><code class="name">var <span class="ident">evaluation_scheme</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.SocialIndicator.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.SocialIndicator.unit_of_measurement"><code class="name">var <span class="ident">unit_of_measurement</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.SocialIndicator.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = SocialIndicator()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.SocialIndicator.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(SocialIndicator, self).read_json(json)
    val = json.get(&#39;activityVariable&#39;)
    if val is not None:
        self.activity_variable = val
    val = json.get(&#39;activityQuantity&#39;)
    if val is not None:
        self.activity_quantity = Ref()
        self.activity_quantity.read_json(val)
    val = json.get(&#39;activityUnit&#39;)
    if val is not None:
        self.activity_unit = Ref()
        self.activity_unit.read_json(val)
    val = json.get(&#39;unitOfMeasurement&#39;)
    if val is not None:
        self.unit_of_measurement = val
    val = json.get(&#39;evaluationScheme&#39;)
    if val is not None:
        self.evaluation_scheme = val</code></pre>
</details>
</dd>
<dt id="olca.schema.SocialIndicator.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(SocialIndicator, self).to_json()
    if self.activity_variable is not None:
        json[&#39;activityVariable&#39;] = self.activity_variable
    if self.activity_quantity is not None:
        json[&#39;activityQuantity&#39;] = self.activity_quantity.to_json()
    if self.activity_unit is not None:
        json[&#39;activityUnit&#39;] = self.activity_unit.to_json()
    if self.unit_of_measurement is not None:
        json[&#39;unitOfMeasurement&#39;] = self.unit_of_measurement
    if self.evaluation_scheme is not None:
        json[&#39;evaluationScheme&#39;] = self.evaluation_scheme
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.Source"><code class="flex name class">
<span>class <span class="ident">Source</span></span>
<span>(</span><span>id:str='', olca_type:str='Source', name:Optional[str]=None, description:Optional[str]=None, version:Optional[str]=None, last_change:Optional[str]=None, category:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, tags:Optional[list[str]]=None, library:Optional[str]=None, url:Optional[str]=None, text_reference:Optional[str]=None, year:Optional[int]=None, external_file:Optional[str]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A source is a literature reference.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>A URL that points to the source.</dd>
<dt><strong><code>text_reference</code></strong> :&ensp;<code>str</code></dt>
<dd>The full text reference of the source.</dd>
<dt><strong><code>year</code></strong> :&ensp;<code>int</code></dt>
<dd>The publication year of the source.</dd>
<dt><strong><code>external_file</code></strong> :&ensp;<code>str</code></dt>
<dd>A direct link (relative or absolute URL) to the source file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Source(CategorizedEntity):
    &#34;&#34;&#34;
    A source is a literature reference.

    Attributes
    ----------
    url: str
        A URL that points to the source.

    text_reference: str
        The full text reference of the source.

    year: int
        The publication year of the source.

    external_file: str
        A direct link (relative or absolute URL) to the source file.

    &#34;&#34;&#34;

    olca_type: str = &#39;Source&#39;
    url: Optional[str] = None
    text_reference: Optional[str] = None
    year: Optional[int] = None
    external_file: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Source, self).to_json()
        if self.url is not None:
            json[&#39;url&#39;] = self.url
        if self.text_reference is not None:
            json[&#39;textReference&#39;] = self.text_reference
        if self.year is not None:
            json[&#39;year&#39;] = self.year
        if self.external_file is not None:
            json[&#39;externalFile&#39;] = self.external_file
        return json

    def read_json(self, json: dict):
        super(Source, self).read_json(json)
        val = json.get(&#39;url&#39;)
        if val is not None:
            self.url = val
        val = json.get(&#39;textReference&#39;)
        if val is not None:
            self.text_reference = val
        val = json.get(&#39;year&#39;)
        if val is not None:
            self.year = val
        val = json.get(&#39;externalFile&#39;)
        if val is not None:
            self.external_file = val

    @staticmethod
    def from_json(json: dict):
        instance = Source()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.CategorizedEntity" href="#olca.schema.CategorizedEntity">CategorizedEntity</a></li>
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.Source.external_file"><code class="name">var <span class="ident">external_file</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Source.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Source.text_reference"><code class="name">var <span class="ident">text_reference</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Source.url"><code class="name">var <span class="ident">url</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Source.year"><code class="name">var <span class="ident">year</span> :Optional[int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.Source.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = Source()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.Source.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(Source, self).read_json(json)
    val = json.get(&#39;url&#39;)
    if val is not None:
        self.url = val
    val = json.get(&#39;textReference&#39;)
    if val is not None:
        self.text_reference = val
    val = json.get(&#39;year&#39;)
    if val is not None:
        self.year = val
    val = json.get(&#39;externalFile&#39;)
    if val is not None:
        self.external_file = val</code></pre>
</details>
</dd>
<dt id="olca.schema.Source.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(Source, self).to_json()
    if self.url is not None:
        json[&#39;url&#39;] = self.url
    if self.text_reference is not None:
        json[&#39;textReference&#39;] = self.text_reference
    if self.year is not None:
        json[&#39;year&#39;] = self.year
    if self.external_file is not None:
        json[&#39;externalFile&#39;] = self.external_file
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.Uncertainty"><code class="flex name class">
<span>class <span class="ident">Uncertainty</span></span>
<span>(</span><span>id:str='', olca_type:str='Uncertainty', distribution_type:Optional[<a title="olca.schema.UncertaintyType" href="#olca.schema.UncertaintyType">UncertaintyType</a>]=None, mean:Optional[float]=None, mean_formula:Optional[str]=None, geom_mean:Optional[float]=None, geom_mean_formula:Optional[str]=None, minimum:Optional[float]=None, minimum_formula:Optional[str]=None, sd:Optional[float]=None, sd_formula:Optional[str]=None, geom_sd:Optional[float]=None, geom_sd_formula:Optional[str]=None, mode:Optional[float]=None, mode_formula:Optional[str]=None, maximum:Optional[float]=None, maximum_formula:Optional[str]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the parameter values of an uncertainty distribution. Depending on
the uncertainty distribution type different parameters could be used.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>distribution_type</code></strong> :&ensp;<code><a title="olca.schema.UncertaintyType" href="#olca.schema.UncertaintyType">UncertaintyType</a></code></dt>
<dd>The uncertainty distribution type</dd>
<dt><strong><code>mean</code></strong> :&ensp;<code>float</code></dt>
<dd>The arithmetic mean (used for normal distributions).</dd>
<dt><strong><code>mean_formula</code></strong> :&ensp;<code>str</code></dt>
<dd>A mathematical formula for the arithmetic mean.</dd>
<dt><strong><code>geom_mean</code></strong> :&ensp;<code>float</code></dt>
<dd>The geometric mean value (used for log-normal distributions).</dd>
<dt><strong><code>geom_mean_formula</code></strong> :&ensp;<code>str</code></dt>
<dd>A mathematical formula for the geometric mean.</dd>
<dt><strong><code>minimum</code></strong> :&ensp;<code>float</code></dt>
<dd>The minimum value (used for uniform and triangle distributions).</dd>
<dt><strong><code>minimum_formula</code></strong> :&ensp;<code>str</code></dt>
<dd>A mathematical formula for the minimum value.</dd>
<dt><strong><code>sd</code></strong> :&ensp;<code>float</code></dt>
<dd>The arithmetic standard deviation (used for normal distributions).</dd>
<dt><strong><code>sd_formula</code></strong> :&ensp;<code>str</code></dt>
<dd>A mathematical formula for the arithmetic standard deviation.</dd>
<dt><strong><code>geom_sd</code></strong> :&ensp;<code>float</code></dt>
<dd>The geometric standard deviation (used for log-normal distributions).</dd>
<dt><strong><code>geom_sd_formula</code></strong> :&ensp;<code>str</code></dt>
<dd>A mathematical formula for the geometric standard deviation.</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>float</code></dt>
<dd>The most likely value (used for triangle distributions).</dd>
<dt><strong><code>mode_formula</code></strong> :&ensp;<code>str</code></dt>
<dd>A mathematical formula for the most likely value.</dd>
<dt><strong><code>maximum</code></strong> :&ensp;<code>float</code></dt>
<dd>The maximum value (used for uniform and triangle distributions).</dd>
<dt><strong><code>maximum_formula</code></strong> :&ensp;<code>str</code></dt>
<dd>A mathematical formula for the maximum value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Uncertainty(Entity):
    &#34;&#34;&#34;
    Defines the parameter values of an uncertainty distribution. Depending on
    the uncertainty distribution type different parameters could be used.

    Attributes
    ----------
    distribution_type: UncertaintyType
        The uncertainty distribution type

    mean: float
        The arithmetic mean (used for normal distributions).

    mean_formula: str
        A mathematical formula for the arithmetic mean.

    geom_mean: float
        The geometric mean value (used for log-normal distributions).

    geom_mean_formula: str
        A mathematical formula for the geometric mean.

    minimum: float
        The minimum value (used for uniform and triangle distributions).

    minimum_formula: str
        A mathematical formula for the minimum value.

    sd: float
        The arithmetic standard deviation (used for normal distributions).

    sd_formula: str
        A mathematical formula for the arithmetic standard deviation.

    geom_sd: float
        The geometric standard deviation (used for log-normal distributions).

    geom_sd_formula: str
        A mathematical formula for the geometric standard deviation.

    mode: float
        The most likely value (used for triangle distributions).

    mode_formula: str
        A mathematical formula for the most likely value.

    maximum: float
        The maximum value (used for uniform and triangle distributions).

    maximum_formula: str
        A mathematical formula for the maximum value.

    &#34;&#34;&#34;

    olca_type: str = &#39;Uncertainty&#39;
    distribution_type: Optional[UncertaintyType] = None
    mean: Optional[float] = None
    mean_formula: Optional[str] = None
    geom_mean: Optional[float] = None
    geom_mean_formula: Optional[str] = None
    minimum: Optional[float] = None
    minimum_formula: Optional[str] = None
    sd: Optional[float] = None
    sd_formula: Optional[str] = None
    geom_sd: Optional[float] = None
    geom_sd_formula: Optional[str] = None
    mode: Optional[float] = None
    mode_formula: Optional[str] = None
    maximum: Optional[float] = None
    maximum_formula: Optional[str] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Uncertainty, self).to_json()
        if self.distribution_type is not None:
            json[&#39;distributionType&#39;] = self.distribution_type.value
        if self.mean is not None:
            json[&#39;mean&#39;] = self.mean
        if self.mean_formula is not None:
            json[&#39;meanFormula&#39;] = self.mean_formula
        if self.geom_mean is not None:
            json[&#39;geomMean&#39;] = self.geom_mean
        if self.geom_mean_formula is not None:
            json[&#39;geomMeanFormula&#39;] = self.geom_mean_formula
        if self.minimum is not None:
            json[&#39;minimum&#39;] = self.minimum
        if self.minimum_formula is not None:
            json[&#39;minimumFormula&#39;] = self.minimum_formula
        if self.sd is not None:
            json[&#39;sd&#39;] = self.sd
        if self.sd_formula is not None:
            json[&#39;sdFormula&#39;] = self.sd_formula
        if self.geom_sd is not None:
            json[&#39;geomSd&#39;] = self.geom_sd
        if self.geom_sd_formula is not None:
            json[&#39;geomSdFormula&#39;] = self.geom_sd_formula
        if self.mode is not None:
            json[&#39;mode&#39;] = self.mode
        if self.mode_formula is not None:
            json[&#39;modeFormula&#39;] = self.mode_formula
        if self.maximum is not None:
            json[&#39;maximum&#39;] = self.maximum
        if self.maximum_formula is not None:
            json[&#39;maximumFormula&#39;] = self.maximum_formula
        return json

    def read_json(self, json: dict):
        super(Uncertainty, self).read_json(json)
        val = json.get(&#39;distributionType&#39;)
        if val is not None:
            self.distribution_type = UncertaintyType(val)
        val = json.get(&#39;mean&#39;)
        if val is not None:
            self.mean = val
        val = json.get(&#39;meanFormula&#39;)
        if val is not None:
            self.mean_formula = val
        val = json.get(&#39;geomMean&#39;)
        if val is not None:
            self.geom_mean = val
        val = json.get(&#39;geomMeanFormula&#39;)
        if val is not None:
            self.geom_mean_formula = val
        val = json.get(&#39;minimum&#39;)
        if val is not None:
            self.minimum = val
        val = json.get(&#39;minimumFormula&#39;)
        if val is not None:
            self.minimum_formula = val
        val = json.get(&#39;sd&#39;)
        if val is not None:
            self.sd = val
        val = json.get(&#39;sdFormula&#39;)
        if val is not None:
            self.sd_formula = val
        val = json.get(&#39;geomSd&#39;)
        if val is not None:
            self.geom_sd = val
        val = json.get(&#39;geomSdFormula&#39;)
        if val is not None:
            self.geom_sd_formula = val
        val = json.get(&#39;mode&#39;)
        if val is not None:
            self.mode = val
        val = json.get(&#39;modeFormula&#39;)
        if val is not None:
            self.mode_formula = val
        val = json.get(&#39;maximum&#39;)
        if val is not None:
            self.maximum = val
        val = json.get(&#39;maximumFormula&#39;)
        if val is not None:
            self.maximum_formula = val

    @staticmethod
    def from_json(json: dict):
        instance = Uncertainty()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.Uncertainty.distribution_type"><code class="name">var <span class="ident">distribution_type</span> :Optional[<a title="olca.schema.UncertaintyType" href="#olca.schema.UncertaintyType">UncertaintyType</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Uncertainty.geom_mean"><code class="name">var <span class="ident">geom_mean</span> :Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Uncertainty.geom_mean_formula"><code class="name">var <span class="ident">geom_mean_formula</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Uncertainty.geom_sd"><code class="name">var <span class="ident">geom_sd</span> :Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Uncertainty.geom_sd_formula"><code class="name">var <span class="ident">geom_sd_formula</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Uncertainty.maximum"><code class="name">var <span class="ident">maximum</span> :Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Uncertainty.maximum_formula"><code class="name">var <span class="ident">maximum_formula</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Uncertainty.mean"><code class="name">var <span class="ident">mean</span> :Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Uncertainty.mean_formula"><code class="name">var <span class="ident">mean_formula</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Uncertainty.minimum"><code class="name">var <span class="ident">minimum</span> :Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Uncertainty.minimum_formula"><code class="name">var <span class="ident">minimum_formula</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Uncertainty.mode"><code class="name">var <span class="ident">mode</span> :Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Uncertainty.mode_formula"><code class="name">var <span class="ident">mode_formula</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Uncertainty.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Uncertainty.sd"><code class="name">var <span class="ident">sd</span> :Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Uncertainty.sd_formula"><code class="name">var <span class="ident">sd_formula</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.Uncertainty.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = Uncertainty()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.Uncertainty.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(Uncertainty, self).read_json(json)
    val = json.get(&#39;distributionType&#39;)
    if val is not None:
        self.distribution_type = UncertaintyType(val)
    val = json.get(&#39;mean&#39;)
    if val is not None:
        self.mean = val
    val = json.get(&#39;meanFormula&#39;)
    if val is not None:
        self.mean_formula = val
    val = json.get(&#39;geomMean&#39;)
    if val is not None:
        self.geom_mean = val
    val = json.get(&#39;geomMeanFormula&#39;)
    if val is not None:
        self.geom_mean_formula = val
    val = json.get(&#39;minimum&#39;)
    if val is not None:
        self.minimum = val
    val = json.get(&#39;minimumFormula&#39;)
    if val is not None:
        self.minimum_formula = val
    val = json.get(&#39;sd&#39;)
    if val is not None:
        self.sd = val
    val = json.get(&#39;sdFormula&#39;)
    if val is not None:
        self.sd_formula = val
    val = json.get(&#39;geomSd&#39;)
    if val is not None:
        self.geom_sd = val
    val = json.get(&#39;geomSdFormula&#39;)
    if val is not None:
        self.geom_sd_formula = val
    val = json.get(&#39;mode&#39;)
    if val is not None:
        self.mode = val
    val = json.get(&#39;modeFormula&#39;)
    if val is not None:
        self.mode_formula = val
    val = json.get(&#39;maximum&#39;)
    if val is not None:
        self.maximum = val
    val = json.get(&#39;maximumFormula&#39;)
    if val is not None:
        self.maximum_formula = val</code></pre>
</details>
</dd>
<dt id="olca.schema.Uncertainty.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(Uncertainty, self).to_json()
    if self.distribution_type is not None:
        json[&#39;distributionType&#39;] = self.distribution_type.value
    if self.mean is not None:
        json[&#39;mean&#39;] = self.mean
    if self.mean_formula is not None:
        json[&#39;meanFormula&#39;] = self.mean_formula
    if self.geom_mean is not None:
        json[&#39;geomMean&#39;] = self.geom_mean
    if self.geom_mean_formula is not None:
        json[&#39;geomMeanFormula&#39;] = self.geom_mean_formula
    if self.minimum is not None:
        json[&#39;minimum&#39;] = self.minimum
    if self.minimum_formula is not None:
        json[&#39;minimumFormula&#39;] = self.minimum_formula
    if self.sd is not None:
        json[&#39;sd&#39;] = self.sd
    if self.sd_formula is not None:
        json[&#39;sdFormula&#39;] = self.sd_formula
    if self.geom_sd is not None:
        json[&#39;geomSd&#39;] = self.geom_sd
    if self.geom_sd_formula is not None:
        json[&#39;geomSdFormula&#39;] = self.geom_sd_formula
    if self.mode is not None:
        json[&#39;mode&#39;] = self.mode
    if self.mode_formula is not None:
        json[&#39;modeFormula&#39;] = self.mode_formula
    if self.maximum is not None:
        json[&#39;maximum&#39;] = self.maximum
    if self.maximum_formula is not None:
        json[&#39;maximumFormula&#39;] = self.maximum_formula
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.UncertaintyType"><code class="flex name class">
<span>class <span class="ident">UncertaintyType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enumeration of uncertainty distribution types that can be used in
exchanges, parameters, LCIA factors, etc.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UncertaintyType(Enum):
    &#34;&#34;&#34;
    Enumeration of uncertainty distribution types that can be used in
    exchanges, parameters, LCIA factors, etc.
    &#34;&#34;&#34;

    LOG_NORMAL_DISTRIBUTION = &#39;LOG_NORMAL_DISTRIBUTION&#39;
    NORMAL_DISTRIBUTION = &#39;NORMAL_DISTRIBUTION&#39;
    TRIANGLE_DISTRIBUTION = &#39;TRIANGLE_DISTRIBUTION&#39;
    UNIFORM_DISTRIBUTION = &#39;UNIFORM_DISTRIBUTION&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.UncertaintyType.LOG_NORMAL_DISTRIBUTION"><code class="name">var <span class="ident">LOG_NORMAL_DISTRIBUTION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.UncertaintyType.NORMAL_DISTRIBUTION"><code class="name">var <span class="ident">NORMAL_DISTRIBUTION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.UncertaintyType.TRIANGLE_DISTRIBUTION"><code class="name">var <span class="ident">TRIANGLE_DISTRIBUTION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.UncertaintyType.UNIFORM_DISTRIBUTION"><code class="name">var <span class="ident">UNIFORM_DISTRIBUTION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="olca.schema.Unit"><code class="flex name class">
<span>class <span class="ident">Unit</span></span>
<span>(</span><span>id:str='', olca_type:str='Unit', name:Optional[str]=None, description:Optional[str]=None, version:Optional[str]=None, last_change:Optional[str]=None, conversion_factor:Optional[float]=None, reference_unit:Optional[bool]=None, synonyms:Optional[list[str]]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>An unit of measure</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>conversion_factor</code></strong> :&ensp;<code>float</code></dt>
<dd>The conversion factor to the reference unit of the unit group to which
this unit belongs.</dd>
<dt><strong><code>reference_unit</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates whether the unit is the reference unit of the unit group to
which this unit belongs. If it is the reference unit the conversion
factor must be 1.0. There should be always only one reference unit in a
unit group. The reference unit is used to convert amounts given in one
unit to amounts given in another unit of the respective unit group.</dd>
<dt><strong><code>synonyms</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>A list of synonyms for the unit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Unit(RootEntity):
    &#34;&#34;&#34;
    An unit of measure

    Attributes
    ----------
    conversion_factor: float
        The conversion factor to the reference unit of the unit group to which
        this unit belongs.

    reference_unit: bool
        Indicates whether the unit is the reference unit of the unit group to
        which this unit belongs. If it is the reference unit the conversion
        factor must be 1.0. There should be always only one reference unit in a
        unit group. The reference unit is used to convert amounts given in one
        unit to amounts given in another unit of the respective unit group.

    synonyms: list[str]
        A list of synonyms for the unit.

    &#34;&#34;&#34;

    olca_type: str = &#39;Unit&#39;
    conversion_factor: Optional[float] = None
    reference_unit: Optional[bool] = None
    synonyms: Optional[list[str]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(Unit, self).to_json()
        if self.conversion_factor is not None:
            json[&#39;conversionFactor&#39;] = self.conversion_factor
        if self.reference_unit is not None:
            json[&#39;referenceUnit&#39;] = self.reference_unit
        if self.synonyms is not None:
            json[&#39;synonyms&#39;] = []
            for e in self.synonyms:
                json[&#39;synonyms&#39;].append(e)
        return json

    def read_json(self, json: dict):
        super(Unit, self).read_json(json)
        val = json.get(&#39;conversionFactor&#39;)
        if val is not None:
            self.conversion_factor = val
        val = json.get(&#39;referenceUnit&#39;)
        if val is not None:
            self.reference_unit = val
        val = json.get(&#39;synonyms&#39;)
        if val is not None:
            self.synonyms = []
            for d in val:
                e = d
                self.synonyms.append(e)

    @staticmethod
    def from_json(json: dict):
        instance = Unit()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.Unit.conversion_factor"><code class="name">var <span class="ident">conversion_factor</span> :Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Unit.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Unit.reference_unit"><code class="name">var <span class="ident">reference_unit</span> :Optional[bool]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.Unit.synonyms"><code class="name">var <span class="ident">synonyms</span> :Optional[list]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.Unit.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = Unit()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.Unit.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(Unit, self).read_json(json)
    val = json.get(&#39;conversionFactor&#39;)
    if val is not None:
        self.conversion_factor = val
    val = json.get(&#39;referenceUnit&#39;)
    if val is not None:
        self.reference_unit = val
    val = json.get(&#39;synonyms&#39;)
    if val is not None:
        self.synonyms = []
        for d in val:
            e = d
            self.synonyms.append(e)</code></pre>
</details>
</dd>
<dt id="olca.schema.Unit.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(Unit, self).to_json()
    if self.conversion_factor is not None:
        json[&#39;conversionFactor&#39;] = self.conversion_factor
    if self.reference_unit is not None:
        json[&#39;referenceUnit&#39;] = self.reference_unit
    if self.synonyms is not None:
        json[&#39;synonyms&#39;] = []
        for e in self.synonyms:
            json[&#39;synonyms&#39;].append(e)
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olca.schema.UnitGroup"><code class="flex name class">
<span>class <span class="ident">UnitGroup</span></span>
<span>(</span><span>id:str='', olca_type:str='UnitGroup', name:Optional[str]=None, description:Optional[str]=None, version:Optional[str]=None, last_change:Optional[str]=None, category:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, tags:Optional[list[str]]=None, library:Optional[str]=None, default_flow_property:Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]=None, units:Optional[list[<a title="olca.schema.Unit" href="#olca.schema.Unit">Unit</a>]]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A group of units that can be converted into each other.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>default_flow_property</code></strong> :&ensp;<code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></dt>
<dd>Some LCA data formats do not have the concept of flow properties or
quantities. This field provides a default link to a flow property for
units that are contained in this group.</dd>
<dt><strong><code>units</code></strong> :&ensp;<code>list[<a title="olca.schema.Unit" href="#olca.schema.Unit">Unit</a>]</code></dt>
<dd>The units of the unit group.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class UnitGroup(CategorizedEntity):
    &#34;&#34;&#34;
    A group of units that can be converted into each other.

    Attributes
    ----------
    default_flow_property: Ref
        Some LCA data formats do not have the concept of flow properties or
        quantities. This field provides a default link to a flow property for
        units that are contained in this group.

    units: list[Unit]
        The units of the unit group.

    &#34;&#34;&#34;

    olca_type: str = &#39;UnitGroup&#39;
    default_flow_property: Optional[Ref] = None
    units: Optional[list[Unit]] = None

    def to_json(self) -&gt; dict:
        json: dict = super(UnitGroup, self).to_json()
        if self.default_flow_property is not None:
            json[&#39;defaultFlowProperty&#39;] = self.default_flow_property.to_json()
        if self.units is not None:
            json[&#39;units&#39;] = []
            for e in self.units:
                json[&#39;units&#39;].append(e.to_json())
        return json

    def read_json(self, json: dict):
        super(UnitGroup, self).read_json(json)
        val = json.get(&#39;defaultFlowProperty&#39;)
        if val is not None:
            self.default_flow_property = Ref()
            self.default_flow_property.read_json(val)
        val = json.get(&#39;units&#39;)
        if val is not None:
            self.units = []
            for d in val:
                e = Unit()
                e.read_json(d)
                self.units.append(e)

    @staticmethod
    def from_json(json: dict):
        instance = UnitGroup()
        instance.read_json(json)
        return instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="olca.schema.CategorizedEntity" href="#olca.schema.CategorizedEntity">CategorizedEntity</a></li>
<li><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></li>
<li><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="olca.schema.UnitGroup.default_flow_property"><code class="name">var <span class="ident">default_flow_property</span> :Optional[<a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.UnitGroup.olca_type"><code class="name">var <span class="ident">olca_type</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="olca.schema.UnitGroup.units"><code class="name">var <span class="ident">units</span> :Optional[list]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="olca.schema.UnitGroup.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(json: dict):
    instance = UnitGroup()
    instance.read_json(json)
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olca.schema.UnitGroup.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, json:dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, json: dict):
    super(UnitGroup, self).read_json(json)
    val = json.get(&#39;defaultFlowProperty&#39;)
    if val is not None:
        self.default_flow_property = Ref()
        self.default_flow_property.read_json(val)
    val = json.get(&#39;units&#39;)
    if val is not None:
        self.units = []
        for d in val:
            e = Unit()
            e.read_json(d)
            self.units.append(e)</code></pre>
</details>
</dd>
<dt id="olca.schema.UnitGroup.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) >dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; dict:
    json: dict = super(UnitGroup, self).to_json()
    if self.default_flow_property is not None:
        json[&#39;defaultFlowProperty&#39;] = self.default_flow_property.to_json()
    if self.units is not None:
        json[&#39;units&#39;] = []
        for e in self.units:
            json[&#39;units&#39;].append(e.to_json())
    return json</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="olca" href="index.html">olca</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="olca.schema.Actor" href="#olca.schema.Actor">Actor</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.Actor.address" href="#olca.schema.Actor.address">address</a></code></li>
<li><code><a title="olca.schema.Actor.city" href="#olca.schema.Actor.city">city</a></code></li>
<li><code><a title="olca.schema.Actor.country" href="#olca.schema.Actor.country">country</a></code></li>
<li><code><a title="olca.schema.Actor.email" href="#olca.schema.Actor.email">email</a></code></li>
<li><code><a title="olca.schema.Actor.from_json" href="#olca.schema.Actor.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.Actor.olca_type" href="#olca.schema.Actor.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.Actor.read_json" href="#olca.schema.Actor.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.Actor.telefax" href="#olca.schema.Actor.telefax">telefax</a></code></li>
<li><code><a title="olca.schema.Actor.telephone" href="#olca.schema.Actor.telephone">telephone</a></code></li>
<li><code><a title="olca.schema.Actor.to_json" href="#olca.schema.Actor.to_json">to_json</a></code></li>
<li><code><a title="olca.schema.Actor.website" href="#olca.schema.Actor.website">website</a></code></li>
<li><code><a title="olca.schema.Actor.zip_code" href="#olca.schema.Actor.zip_code">zip_code</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.AllocationFactor" href="#olca.schema.AllocationFactor">AllocationFactor</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.AllocationFactor.allocation_type" href="#olca.schema.AllocationFactor.allocation_type">allocation_type</a></code></li>
<li><code><a title="olca.schema.AllocationFactor.exchange" href="#olca.schema.AllocationFactor.exchange">exchange</a></code></li>
<li><code><a title="olca.schema.AllocationFactor.formula" href="#olca.schema.AllocationFactor.formula">formula</a></code></li>
<li><code><a title="olca.schema.AllocationFactor.from_json" href="#olca.schema.AllocationFactor.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.AllocationFactor.olca_type" href="#olca.schema.AllocationFactor.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.AllocationFactor.product" href="#olca.schema.AllocationFactor.product">product</a></code></li>
<li><code><a title="olca.schema.AllocationFactor.read_json" href="#olca.schema.AllocationFactor.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.AllocationFactor.to_json" href="#olca.schema.AllocationFactor.to_json">to_json</a></code></li>
<li><code><a title="olca.schema.AllocationFactor.value" href="#olca.schema.AllocationFactor.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.AllocationType" href="#olca.schema.AllocationType">AllocationType</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.AllocationType.CAUSAL_ALLOCATION" href="#olca.schema.AllocationType.CAUSAL_ALLOCATION">CAUSAL_ALLOCATION</a></code></li>
<li><code><a title="olca.schema.AllocationType.ECONOMIC_ALLOCATION" href="#olca.schema.AllocationType.ECONOMIC_ALLOCATION">ECONOMIC_ALLOCATION</a></code></li>
<li><code><a title="olca.schema.AllocationType.NO_ALLOCATION" href="#olca.schema.AllocationType.NO_ALLOCATION">NO_ALLOCATION</a></code></li>
<li><code><a title="olca.schema.AllocationType.PHYSICAL_ALLOCATION" href="#olca.schema.AllocationType.PHYSICAL_ALLOCATION">PHYSICAL_ALLOCATION</a></code></li>
<li><code><a title="olca.schema.AllocationType.USE_DEFAULT_ALLOCATION" href="#olca.schema.AllocationType.USE_DEFAULT_ALLOCATION">USE_DEFAULT_ALLOCATION</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.CalculationSetup" href="#olca.schema.CalculationSetup">CalculationSetup</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.CalculationSetup.allocation_method" href="#olca.schema.CalculationSetup.allocation_method">allocation_method</a></code></li>
<li><code><a title="olca.schema.CalculationSetup.amount" href="#olca.schema.CalculationSetup.amount">amount</a></code></li>
<li><code><a title="olca.schema.CalculationSetup.calculation_type" href="#olca.schema.CalculationSetup.calculation_type">calculation_type</a></code></li>
<li><code><a title="olca.schema.CalculationSetup.flow_property" href="#olca.schema.CalculationSetup.flow_property">flow_property</a></code></li>
<li><code><a title="olca.schema.CalculationSetup.from_json" href="#olca.schema.CalculationSetup.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.CalculationSetup.impact_method" href="#olca.schema.CalculationSetup.impact_method">impact_method</a></code></li>
<li><code><a title="olca.schema.CalculationSetup.nw_set" href="#olca.schema.CalculationSetup.nw_set">nw_set</a></code></li>
<li><code><a title="olca.schema.CalculationSetup.olca_type" href="#olca.schema.CalculationSetup.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.CalculationSetup.parameter_redefs" href="#olca.schema.CalculationSetup.parameter_redefs">parameter_redefs</a></code></li>
<li><code><a title="olca.schema.CalculationSetup.product_system" href="#olca.schema.CalculationSetup.product_system">product_system</a></code></li>
<li><code><a title="olca.schema.CalculationSetup.read_json" href="#olca.schema.CalculationSetup.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.CalculationSetup.to_json" href="#olca.schema.CalculationSetup.to_json">to_json</a></code></li>
<li><code><a title="olca.schema.CalculationSetup.unit" href="#olca.schema.CalculationSetup.unit">unit</a></code></li>
<li><code><a title="olca.schema.CalculationSetup.with_costs" href="#olca.schema.CalculationSetup.with_costs">with_costs</a></code></li>
<li><code><a title="olca.schema.CalculationSetup.with_regionalization" href="#olca.schema.CalculationSetup.with_regionalization">with_regionalization</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.CalculationType" href="#olca.schema.CalculationType">CalculationType</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.CalculationType.CONTRIBUTION_ANALYSIS" href="#olca.schema.CalculationType.CONTRIBUTION_ANALYSIS">CONTRIBUTION_ANALYSIS</a></code></li>
<li><code><a title="olca.schema.CalculationType.MONTE_CARLO_SIMULATION" href="#olca.schema.CalculationType.MONTE_CARLO_SIMULATION">MONTE_CARLO_SIMULATION</a></code></li>
<li><code><a title="olca.schema.CalculationType.REGIONALIZED_CALCULATION" href="#olca.schema.CalculationType.REGIONALIZED_CALCULATION">REGIONALIZED_CALCULATION</a></code></li>
<li><code><a title="olca.schema.CalculationType.SIMPLE_CALCULATION" href="#olca.schema.CalculationType.SIMPLE_CALCULATION">SIMPLE_CALCULATION</a></code></li>
<li><code><a title="olca.schema.CalculationType.UPSTREAM_ANALYSIS" href="#olca.schema.CalculationType.UPSTREAM_ANALYSIS">UPSTREAM_ANALYSIS</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.CategorizedEntity" href="#olca.schema.CategorizedEntity">CategorizedEntity</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.CategorizedEntity.category" href="#olca.schema.CategorizedEntity.category">category</a></code></li>
<li><code><a title="olca.schema.CategorizedEntity.from_json" href="#olca.schema.CategorizedEntity.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.CategorizedEntity.library" href="#olca.schema.CategorizedEntity.library">library</a></code></li>
<li><code><a title="olca.schema.CategorizedEntity.read_json" href="#olca.schema.CategorizedEntity.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.CategorizedEntity.tags" href="#olca.schema.CategorizedEntity.tags">tags</a></code></li>
<li><code><a title="olca.schema.CategorizedEntity.to_json" href="#olca.schema.CategorizedEntity.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.Category" href="#olca.schema.Category">Category</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.Category.from_json" href="#olca.schema.Category.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.Category.model_type" href="#olca.schema.Category.model_type">model_type</a></code></li>
<li><code><a title="olca.schema.Category.olca_type" href="#olca.schema.Category.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.Category.read_json" href="#olca.schema.Category.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.Category.to_json" href="#olca.schema.Category.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.Currency" href="#olca.schema.Currency">Currency</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.Currency.code" href="#olca.schema.Currency.code">code</a></code></li>
<li><code><a title="olca.schema.Currency.conversion_factor" href="#olca.schema.Currency.conversion_factor">conversion_factor</a></code></li>
<li><code><a title="olca.schema.Currency.from_json" href="#olca.schema.Currency.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.Currency.olca_type" href="#olca.schema.Currency.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.Currency.read_json" href="#olca.schema.Currency.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.Currency.reference_currency" href="#olca.schema.Currency.reference_currency">reference_currency</a></code></li>
<li><code><a title="olca.schema.Currency.to_json" href="#olca.schema.Currency.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.DQIndicator" href="#olca.schema.DQIndicator">DQIndicator</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.DQIndicator.from_json" href="#olca.schema.DQIndicator.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.DQIndicator.name" href="#olca.schema.DQIndicator.name">name</a></code></li>
<li><code><a title="olca.schema.DQIndicator.olca_type" href="#olca.schema.DQIndicator.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.DQIndicator.position" href="#olca.schema.DQIndicator.position">position</a></code></li>
<li><code><a title="olca.schema.DQIndicator.read_json" href="#olca.schema.DQIndicator.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.DQIndicator.scores" href="#olca.schema.DQIndicator.scores">scores</a></code></li>
<li><code><a title="olca.schema.DQIndicator.to_json" href="#olca.schema.DQIndicator.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.DQScore" href="#olca.schema.DQScore">DQScore</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.DQScore.description" href="#olca.schema.DQScore.description">description</a></code></li>
<li><code><a title="olca.schema.DQScore.from_json" href="#olca.schema.DQScore.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.DQScore.label" href="#olca.schema.DQScore.label">label</a></code></li>
<li><code><a title="olca.schema.DQScore.olca_type" href="#olca.schema.DQScore.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.DQScore.position" href="#olca.schema.DQScore.position">position</a></code></li>
<li><code><a title="olca.schema.DQScore.read_json" href="#olca.schema.DQScore.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.DQScore.to_json" href="#olca.schema.DQScore.to_json">to_json</a></code></li>
<li><code><a title="olca.schema.DQScore.uncertainty" href="#olca.schema.DQScore.uncertainty">uncertainty</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.DQSystem" href="#olca.schema.DQSystem">DQSystem</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.DQSystem.from_json" href="#olca.schema.DQSystem.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.DQSystem.has_uncertainties" href="#olca.schema.DQSystem.has_uncertainties">has_uncertainties</a></code></li>
<li><code><a title="olca.schema.DQSystem.indicators" href="#olca.schema.DQSystem.indicators">indicators</a></code></li>
<li><code><a title="olca.schema.DQSystem.olca_type" href="#olca.schema.DQSystem.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.DQSystem.read_json" href="#olca.schema.DQSystem.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.DQSystem.source" href="#olca.schema.DQSystem.source">source</a></code></li>
<li><code><a title="olca.schema.DQSystem.to_json" href="#olca.schema.DQSystem.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.Entity" href="#olca.schema.Entity">Entity</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.Entity.from_json" href="#olca.schema.Entity.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.Entity.id" href="#olca.schema.Entity.id">id</a></code></li>
<li><code><a title="olca.schema.Entity.olca_type" href="#olca.schema.Entity.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.Entity.read_json" href="#olca.schema.Entity.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.Entity.to_json" href="#olca.schema.Entity.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.Exchange" href="#olca.schema.Exchange">Exchange</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.Exchange.amount" href="#olca.schema.Exchange.amount">amount</a></code></li>
<li><code><a title="olca.schema.Exchange.amount_formula" href="#olca.schema.Exchange.amount_formula">amount_formula</a></code></li>
<li><code><a title="olca.schema.Exchange.avoided_product" href="#olca.schema.Exchange.avoided_product">avoided_product</a></code></li>
<li><code><a title="olca.schema.Exchange.base_uncertainty" href="#olca.schema.Exchange.base_uncertainty">base_uncertainty</a></code></li>
<li><code><a title="olca.schema.Exchange.cost_formula" href="#olca.schema.Exchange.cost_formula">cost_formula</a></code></li>
<li><code><a title="olca.schema.Exchange.cost_value" href="#olca.schema.Exchange.cost_value">cost_value</a></code></li>
<li><code><a title="olca.schema.Exchange.currency" href="#olca.schema.Exchange.currency">currency</a></code></li>
<li><code><a title="olca.schema.Exchange.default_provider" href="#olca.schema.Exchange.default_provider">default_provider</a></code></li>
<li><code><a title="olca.schema.Exchange.description" href="#olca.schema.Exchange.description">description</a></code></li>
<li><code><a title="olca.schema.Exchange.dq_entry" href="#olca.schema.Exchange.dq_entry">dq_entry</a></code></li>
<li><code><a title="olca.schema.Exchange.flow" href="#olca.schema.Exchange.flow">flow</a></code></li>
<li><code><a title="olca.schema.Exchange.flow_property" href="#olca.schema.Exchange.flow_property">flow_property</a></code></li>
<li><code><a title="olca.schema.Exchange.from_json" href="#olca.schema.Exchange.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.Exchange.input" href="#olca.schema.Exchange.input">input</a></code></li>
<li><code><a title="olca.schema.Exchange.internal_id" href="#olca.schema.Exchange.internal_id">internal_id</a></code></li>
<li><code><a title="olca.schema.Exchange.olca_type" href="#olca.schema.Exchange.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.Exchange.quantitative_reference" href="#olca.schema.Exchange.quantitative_reference">quantitative_reference</a></code></li>
<li><code><a title="olca.schema.Exchange.read_json" href="#olca.schema.Exchange.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.Exchange.to_json" href="#olca.schema.Exchange.to_json">to_json</a></code></li>
<li><code><a title="olca.schema.Exchange.uncertainty" href="#olca.schema.Exchange.uncertainty">uncertainty</a></code></li>
<li><code><a title="olca.schema.Exchange.unit" href="#olca.schema.Exchange.unit">unit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.ExchangeRef" href="#olca.schema.ExchangeRef">ExchangeRef</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.ExchangeRef.from_json" href="#olca.schema.ExchangeRef.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.ExchangeRef.internal_id" href="#olca.schema.ExchangeRef.internal_id">internal_id</a></code></li>
<li><code><a title="olca.schema.ExchangeRef.olca_type" href="#olca.schema.ExchangeRef.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.ExchangeRef.read_json" href="#olca.schema.ExchangeRef.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.ExchangeRef.to_json" href="#olca.schema.ExchangeRef.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.Flow" href="#olca.schema.Flow">Flow</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.Flow.cas" href="#olca.schema.Flow.cas">cas</a></code></li>
<li><code><a title="olca.schema.Flow.flow_properties" href="#olca.schema.Flow.flow_properties">flow_properties</a></code></li>
<li><code><a title="olca.schema.Flow.flow_type" href="#olca.schema.Flow.flow_type">flow_type</a></code></li>
<li><code><a title="olca.schema.Flow.formula" href="#olca.schema.Flow.formula">formula</a></code></li>
<li><code><a title="olca.schema.Flow.from_json" href="#olca.schema.Flow.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.Flow.infrastructure_flow" href="#olca.schema.Flow.infrastructure_flow">infrastructure_flow</a></code></li>
<li><code><a title="olca.schema.Flow.location" href="#olca.schema.Flow.location">location</a></code></li>
<li><code><a title="olca.schema.Flow.olca_type" href="#olca.schema.Flow.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.Flow.read_json" href="#olca.schema.Flow.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.Flow.synonyms" href="#olca.schema.Flow.synonyms">synonyms</a></code></li>
<li><code><a title="olca.schema.Flow.to_json" href="#olca.schema.Flow.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.FlowMap" href="#olca.schema.FlowMap">FlowMap</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.FlowMap.from_json" href="#olca.schema.FlowMap.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.FlowMap.mappings" href="#olca.schema.FlowMap.mappings">mappings</a></code></li>
<li><code><a title="olca.schema.FlowMap.olca_type" href="#olca.schema.FlowMap.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.FlowMap.read_json" href="#olca.schema.FlowMap.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.FlowMap.source" href="#olca.schema.FlowMap.source">source</a></code></li>
<li><code><a title="olca.schema.FlowMap.target" href="#olca.schema.FlowMap.target">target</a></code></li>
<li><code><a title="olca.schema.FlowMap.to_json" href="#olca.schema.FlowMap.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.FlowMapEntry" href="#olca.schema.FlowMapEntry">FlowMapEntry</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.FlowMapEntry.conversion_factor" href="#olca.schema.FlowMapEntry.conversion_factor">conversion_factor</a></code></li>
<li><code><a title="olca.schema.FlowMapEntry.from_" href="#olca.schema.FlowMapEntry.from_">from_</a></code></li>
<li><code><a title="olca.schema.FlowMapEntry.from_json" href="#olca.schema.FlowMapEntry.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.FlowMapEntry.olca_type" href="#olca.schema.FlowMapEntry.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.FlowMapEntry.read_json" href="#olca.schema.FlowMapEntry.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.FlowMapEntry.to" href="#olca.schema.FlowMapEntry.to">to</a></code></li>
<li><code><a title="olca.schema.FlowMapEntry.to_json" href="#olca.schema.FlowMapEntry.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.FlowMapRef" href="#olca.schema.FlowMapRef">FlowMapRef</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.FlowMapRef.flow" href="#olca.schema.FlowMapRef.flow">flow</a></code></li>
<li><code><a title="olca.schema.FlowMapRef.flow_property" href="#olca.schema.FlowMapRef.flow_property">flow_property</a></code></li>
<li><code><a title="olca.schema.FlowMapRef.from_json" href="#olca.schema.FlowMapRef.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.FlowMapRef.olca_type" href="#olca.schema.FlowMapRef.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.FlowMapRef.provider" href="#olca.schema.FlowMapRef.provider">provider</a></code></li>
<li><code><a title="olca.schema.FlowMapRef.read_json" href="#olca.schema.FlowMapRef.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.FlowMapRef.to_json" href="#olca.schema.FlowMapRef.to_json">to_json</a></code></li>
<li><code><a title="olca.schema.FlowMapRef.unit" href="#olca.schema.FlowMapRef.unit">unit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.FlowProperty" href="#olca.schema.FlowProperty">FlowProperty</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.FlowProperty.flow_property_type" href="#olca.schema.FlowProperty.flow_property_type">flow_property_type</a></code></li>
<li><code><a title="olca.schema.FlowProperty.from_json" href="#olca.schema.FlowProperty.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.FlowProperty.olca_type" href="#olca.schema.FlowProperty.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.FlowProperty.read_json" href="#olca.schema.FlowProperty.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.FlowProperty.to_json" href="#olca.schema.FlowProperty.to_json">to_json</a></code></li>
<li><code><a title="olca.schema.FlowProperty.unit_group" href="#olca.schema.FlowProperty.unit_group">unit_group</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.FlowPropertyFactor" href="#olca.schema.FlowPropertyFactor">FlowPropertyFactor</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.FlowPropertyFactor.conversion_factor" href="#olca.schema.FlowPropertyFactor.conversion_factor">conversion_factor</a></code></li>
<li><code><a title="olca.schema.FlowPropertyFactor.flow_property" href="#olca.schema.FlowPropertyFactor.flow_property">flow_property</a></code></li>
<li><code><a title="olca.schema.FlowPropertyFactor.from_json" href="#olca.schema.FlowPropertyFactor.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.FlowPropertyFactor.olca_type" href="#olca.schema.FlowPropertyFactor.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.FlowPropertyFactor.read_json" href="#olca.schema.FlowPropertyFactor.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.FlowPropertyFactor.reference_flow_property" href="#olca.schema.FlowPropertyFactor.reference_flow_property">reference_flow_property</a></code></li>
<li><code><a title="olca.schema.FlowPropertyFactor.to_json" href="#olca.schema.FlowPropertyFactor.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.FlowPropertyType" href="#olca.schema.FlowPropertyType">FlowPropertyType</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.FlowPropertyType.ECONOMIC_QUANTITY" href="#olca.schema.FlowPropertyType.ECONOMIC_QUANTITY">ECONOMIC_QUANTITY</a></code></li>
<li><code><a title="olca.schema.FlowPropertyType.PHYSICAL_QUANTITY" href="#olca.schema.FlowPropertyType.PHYSICAL_QUANTITY">PHYSICAL_QUANTITY</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.FlowResult" href="#olca.schema.FlowResult">FlowResult</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.FlowResult.flow" href="#olca.schema.FlowResult.flow">flow</a></code></li>
<li><code><a title="olca.schema.FlowResult.from_json" href="#olca.schema.FlowResult.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.FlowResult.input" href="#olca.schema.FlowResult.input">input</a></code></li>
<li><code><a title="olca.schema.FlowResult.location" href="#olca.schema.FlowResult.location">location</a></code></li>
<li><code><a title="olca.schema.FlowResult.olca_type" href="#olca.schema.FlowResult.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.FlowResult.read_json" href="#olca.schema.FlowResult.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.FlowResult.to_json" href="#olca.schema.FlowResult.to_json">to_json</a></code></li>
<li><code><a title="olca.schema.FlowResult.value" href="#olca.schema.FlowResult.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.FlowType" href="#olca.schema.FlowType">FlowType</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.FlowType.ELEMENTARY_FLOW" href="#olca.schema.FlowType.ELEMENTARY_FLOW">ELEMENTARY_FLOW</a></code></li>
<li><code><a title="olca.schema.FlowType.PRODUCT_FLOW" href="#olca.schema.FlowType.PRODUCT_FLOW">PRODUCT_FLOW</a></code></li>
<li><code><a title="olca.schema.FlowType.WASTE_FLOW" href="#olca.schema.FlowType.WASTE_FLOW">WASTE_FLOW</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.ImpactCategory" href="#olca.schema.ImpactCategory">ImpactCategory</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.ImpactCategory.from_json" href="#olca.schema.ImpactCategory.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.ImpactCategory.impact_factors" href="#olca.schema.ImpactCategory.impact_factors">impact_factors</a></code></li>
<li><code><a title="olca.schema.ImpactCategory.olca_type" href="#olca.schema.ImpactCategory.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.ImpactCategory.parameters" href="#olca.schema.ImpactCategory.parameters">parameters</a></code></li>
<li><code><a title="olca.schema.ImpactCategory.read_json" href="#olca.schema.ImpactCategory.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.ImpactCategory.reference_unit_name" href="#olca.schema.ImpactCategory.reference_unit_name">reference_unit_name</a></code></li>
<li><code><a title="olca.schema.ImpactCategory.to_json" href="#olca.schema.ImpactCategory.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.ImpactFactor" href="#olca.schema.ImpactFactor">ImpactFactor</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.ImpactFactor.flow" href="#olca.schema.ImpactFactor.flow">flow</a></code></li>
<li><code><a title="olca.schema.ImpactFactor.flow_property" href="#olca.schema.ImpactFactor.flow_property">flow_property</a></code></li>
<li><code><a title="olca.schema.ImpactFactor.formula" href="#olca.schema.ImpactFactor.formula">formula</a></code></li>
<li><code><a title="olca.schema.ImpactFactor.from_json" href="#olca.schema.ImpactFactor.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.ImpactFactor.location" href="#olca.schema.ImpactFactor.location">location</a></code></li>
<li><code><a title="olca.schema.ImpactFactor.olca_type" href="#olca.schema.ImpactFactor.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.ImpactFactor.read_json" href="#olca.schema.ImpactFactor.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.ImpactFactor.to_json" href="#olca.schema.ImpactFactor.to_json">to_json</a></code></li>
<li><code><a title="olca.schema.ImpactFactor.uncertainty" href="#olca.schema.ImpactFactor.uncertainty">uncertainty</a></code></li>
<li><code><a title="olca.schema.ImpactFactor.unit" href="#olca.schema.ImpactFactor.unit">unit</a></code></li>
<li><code><a title="olca.schema.ImpactFactor.value" href="#olca.schema.ImpactFactor.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.ImpactMethod" href="#olca.schema.ImpactMethod">ImpactMethod</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.ImpactMethod.from_json" href="#olca.schema.ImpactMethod.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.ImpactMethod.impact_categories" href="#olca.schema.ImpactMethod.impact_categories">impact_categories</a></code></li>
<li><code><a title="olca.schema.ImpactMethod.nw_sets" href="#olca.schema.ImpactMethod.nw_sets">nw_sets</a></code></li>
<li><code><a title="olca.schema.ImpactMethod.olca_type" href="#olca.schema.ImpactMethod.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.ImpactMethod.read_json" href="#olca.schema.ImpactMethod.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.ImpactMethod.to_json" href="#olca.schema.ImpactMethod.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.ImpactResult" href="#olca.schema.ImpactResult">ImpactResult</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.ImpactResult.from_json" href="#olca.schema.ImpactResult.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.ImpactResult.impact_category" href="#olca.schema.ImpactResult.impact_category">impact_category</a></code></li>
<li><code><a title="olca.schema.ImpactResult.olca_type" href="#olca.schema.ImpactResult.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.ImpactResult.read_json" href="#olca.schema.ImpactResult.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.ImpactResult.to_json" href="#olca.schema.ImpactResult.to_json">to_json</a></code></li>
<li><code><a title="olca.schema.ImpactResult.value" href="#olca.schema.ImpactResult.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.Location" href="#olca.schema.Location">Location</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.Location.code" href="#olca.schema.Location.code">code</a></code></li>
<li><code><a title="olca.schema.Location.from_json" href="#olca.schema.Location.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.Location.geometry" href="#olca.schema.Location.geometry">geometry</a></code></li>
<li><code><a title="olca.schema.Location.latitude" href="#olca.schema.Location.latitude">latitude</a></code></li>
<li><code><a title="olca.schema.Location.longitude" href="#olca.schema.Location.longitude">longitude</a></code></li>
<li><code><a title="olca.schema.Location.olca_type" href="#olca.schema.Location.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.Location.read_json" href="#olca.schema.Location.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.Location.to_json" href="#olca.schema.Location.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.ModelType" href="#olca.schema.ModelType">ModelType</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.ModelType.ACTOR" href="#olca.schema.ModelType.ACTOR">ACTOR</a></code></li>
<li><code><a title="olca.schema.ModelType.CATEGORY" href="#olca.schema.ModelType.CATEGORY">CATEGORY</a></code></li>
<li><code><a title="olca.schema.ModelType.CURRENCY" href="#olca.schema.ModelType.CURRENCY">CURRENCY</a></code></li>
<li><code><a title="olca.schema.ModelType.DQ_SYSTEM" href="#olca.schema.ModelType.DQ_SYSTEM">DQ_SYSTEM</a></code></li>
<li><code><a title="olca.schema.ModelType.FLOW" href="#olca.schema.ModelType.FLOW">FLOW</a></code></li>
<li><code><a title="olca.schema.ModelType.FLOW_PROPERTY" href="#olca.schema.ModelType.FLOW_PROPERTY">FLOW_PROPERTY</a></code></li>
<li><code><a title="olca.schema.ModelType.IMPACT_CATEGORY" href="#olca.schema.ModelType.IMPACT_CATEGORY">IMPACT_CATEGORY</a></code></li>
<li><code><a title="olca.schema.ModelType.IMPACT_METHOD" href="#olca.schema.ModelType.IMPACT_METHOD">IMPACT_METHOD</a></code></li>
<li><code><a title="olca.schema.ModelType.LOCATION" href="#olca.schema.ModelType.LOCATION">LOCATION</a></code></li>
<li><code><a title="olca.schema.ModelType.NW_SET" href="#olca.schema.ModelType.NW_SET">NW_SET</a></code></li>
<li><code><a title="olca.schema.ModelType.PARAMETER" href="#olca.schema.ModelType.PARAMETER">PARAMETER</a></code></li>
<li><code><a title="olca.schema.ModelType.PROCESS" href="#olca.schema.ModelType.PROCESS">PROCESS</a></code></li>
<li><code><a title="olca.schema.ModelType.PRODUCT_SYSTEM" href="#olca.schema.ModelType.PRODUCT_SYSTEM">PRODUCT_SYSTEM</a></code></li>
<li><code><a title="olca.schema.ModelType.PROJECT" href="#olca.schema.ModelType.PROJECT">PROJECT</a></code></li>
<li><code><a title="olca.schema.ModelType.SOCIAL_INDICATOR" href="#olca.schema.ModelType.SOCIAL_INDICATOR">SOCIAL_INDICATOR</a></code></li>
<li><code><a title="olca.schema.ModelType.SOURCE" href="#olca.schema.ModelType.SOURCE">SOURCE</a></code></li>
<li><code><a title="olca.schema.ModelType.UNIT" href="#olca.schema.ModelType.UNIT">UNIT</a></code></li>
<li><code><a title="olca.schema.ModelType.UNIT_GROUP" href="#olca.schema.ModelType.UNIT_GROUP">UNIT_GROUP</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.NwFactor" href="#olca.schema.NwFactor">NwFactor</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.NwFactor.from_json" href="#olca.schema.NwFactor.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.NwFactor.impact_category" href="#olca.schema.NwFactor.impact_category">impact_category</a></code></li>
<li><code><a title="olca.schema.NwFactor.normalisation_factor" href="#olca.schema.NwFactor.normalisation_factor">normalisation_factor</a></code></li>
<li><code><a title="olca.schema.NwFactor.olca_type" href="#olca.schema.NwFactor.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.NwFactor.read_json" href="#olca.schema.NwFactor.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.NwFactor.to_json" href="#olca.schema.NwFactor.to_json">to_json</a></code></li>
<li><code><a title="olca.schema.NwFactor.weighting_factor" href="#olca.schema.NwFactor.weighting_factor">weighting_factor</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.NwSet" href="#olca.schema.NwSet">NwSet</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.NwSet.factors" href="#olca.schema.NwSet.factors">factors</a></code></li>
<li><code><a title="olca.schema.NwSet.from_json" href="#olca.schema.NwSet.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.NwSet.olca_type" href="#olca.schema.NwSet.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.NwSet.read_json" href="#olca.schema.NwSet.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.NwSet.to_json" href="#olca.schema.NwSet.to_json">to_json</a></code></li>
<li><code><a title="olca.schema.NwSet.weighted_score_unit" href="#olca.schema.NwSet.weighted_score_unit">weighted_score_unit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.Parameter" href="#olca.schema.Parameter">Parameter</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.Parameter.formula" href="#olca.schema.Parameter.formula">formula</a></code></li>
<li><code><a title="olca.schema.Parameter.from_json" href="#olca.schema.Parameter.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.Parameter.input_parameter" href="#olca.schema.Parameter.input_parameter">input_parameter</a></code></li>
<li><code><a title="olca.schema.Parameter.olca_type" href="#olca.schema.Parameter.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.Parameter.parameter_scope" href="#olca.schema.Parameter.parameter_scope">parameter_scope</a></code></li>
<li><code><a title="olca.schema.Parameter.read_json" href="#olca.schema.Parameter.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.Parameter.to_json" href="#olca.schema.Parameter.to_json">to_json</a></code></li>
<li><code><a title="olca.schema.Parameter.uncertainty" href="#olca.schema.Parameter.uncertainty">uncertainty</a></code></li>
<li><code><a title="olca.schema.Parameter.value" href="#olca.schema.Parameter.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.ParameterRedef" href="#olca.schema.ParameterRedef">ParameterRedef</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.ParameterRedef.context" href="#olca.schema.ParameterRedef.context">context</a></code></li>
<li><code><a title="olca.schema.ParameterRedef.description" href="#olca.schema.ParameterRedef.description">description</a></code></li>
<li><code><a title="olca.schema.ParameterRedef.from_json" href="#olca.schema.ParameterRedef.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.ParameterRedef.name" href="#olca.schema.ParameterRedef.name">name</a></code></li>
<li><code><a title="olca.schema.ParameterRedef.olca_type" href="#olca.schema.ParameterRedef.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.ParameterRedef.read_json" href="#olca.schema.ParameterRedef.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.ParameterRedef.to_json" href="#olca.schema.ParameterRedef.to_json">to_json</a></code></li>
<li><code><a title="olca.schema.ParameterRedef.uncertainty" href="#olca.schema.ParameterRedef.uncertainty">uncertainty</a></code></li>
<li><code><a title="olca.schema.ParameterRedef.value" href="#olca.schema.ParameterRedef.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.ParameterRedefSet" href="#olca.schema.ParameterRedefSet">ParameterRedefSet</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.ParameterRedefSet.description" href="#olca.schema.ParameterRedefSet.description">description</a></code></li>
<li><code><a title="olca.schema.ParameterRedefSet.from_json" href="#olca.schema.ParameterRedefSet.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.ParameterRedefSet.is_baseline" href="#olca.schema.ParameterRedefSet.is_baseline">is_baseline</a></code></li>
<li><code><a title="olca.schema.ParameterRedefSet.name" href="#olca.schema.ParameterRedefSet.name">name</a></code></li>
<li><code><a title="olca.schema.ParameterRedefSet.olca_type" href="#olca.schema.ParameterRedefSet.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.ParameterRedefSet.parameters" href="#olca.schema.ParameterRedefSet.parameters">parameters</a></code></li>
<li><code><a title="olca.schema.ParameterRedefSet.read_json" href="#olca.schema.ParameterRedefSet.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.ParameterRedefSet.to_json" href="#olca.schema.ParameterRedefSet.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.ParameterScope" href="#olca.schema.ParameterScope">ParameterScope</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.ParameterScope.GLOBAL_SCOPE" href="#olca.schema.ParameterScope.GLOBAL_SCOPE">GLOBAL_SCOPE</a></code></li>
<li><code><a title="olca.schema.ParameterScope.IMPACT_SCOPE" href="#olca.schema.ParameterScope.IMPACT_SCOPE">IMPACT_SCOPE</a></code></li>
<li><code><a title="olca.schema.ParameterScope.PROCESS_SCOPE" href="#olca.schema.ParameterScope.PROCESS_SCOPE">PROCESS_SCOPE</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.Process" href="#olca.schema.Process">Process</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.Process.allocation_factors" href="#olca.schema.Process.allocation_factors">allocation_factors</a></code></li>
<li><code><a title="olca.schema.Process.default_allocation_method" href="#olca.schema.Process.default_allocation_method">default_allocation_method</a></code></li>
<li><code><a title="olca.schema.Process.dq_entry" href="#olca.schema.Process.dq_entry">dq_entry</a></code></li>
<li><code><a title="olca.schema.Process.dq_system" href="#olca.schema.Process.dq_system">dq_system</a></code></li>
<li><code><a title="olca.schema.Process.exchange_dq_system" href="#olca.schema.Process.exchange_dq_system">exchange_dq_system</a></code></li>
<li><code><a title="olca.schema.Process.exchanges" href="#olca.schema.Process.exchanges">exchanges</a></code></li>
<li><code><a title="olca.schema.Process.from_json" href="#olca.schema.Process.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.Process.infrastructure_process" href="#olca.schema.Process.infrastructure_process">infrastructure_process</a></code></li>
<li><code><a title="olca.schema.Process.last_internal_id" href="#olca.schema.Process.last_internal_id">last_internal_id</a></code></li>
<li><code><a title="olca.schema.Process.location" href="#olca.schema.Process.location">location</a></code></li>
<li><code><a title="olca.schema.Process.olca_type" href="#olca.schema.Process.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.Process.parameters" href="#olca.schema.Process.parameters">parameters</a></code></li>
<li><code><a title="olca.schema.Process.process_documentation" href="#olca.schema.Process.process_documentation">process_documentation</a></code></li>
<li><code><a title="olca.schema.Process.process_type" href="#olca.schema.Process.process_type">process_type</a></code></li>
<li><code><a title="olca.schema.Process.read_json" href="#olca.schema.Process.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.Process.social_aspects" href="#olca.schema.Process.social_aspects">social_aspects</a></code></li>
<li><code><a title="olca.schema.Process.social_dq_system" href="#olca.schema.Process.social_dq_system">social_dq_system</a></code></li>
<li><code><a title="olca.schema.Process.to_json" href="#olca.schema.Process.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.ProcessDocumentation" href="#olca.schema.ProcessDocumentation">ProcessDocumentation</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.ProcessDocumentation.completeness_description" href="#olca.schema.ProcessDocumentation.completeness_description">completeness_description</a></code></li>
<li><code><a title="olca.schema.ProcessDocumentation.copyright" href="#olca.schema.ProcessDocumentation.copyright">copyright</a></code></li>
<li><code><a title="olca.schema.ProcessDocumentation.creation_date" href="#olca.schema.ProcessDocumentation.creation_date">creation_date</a></code></li>
<li><code><a title="olca.schema.ProcessDocumentation.data_collection_description" href="#olca.schema.ProcessDocumentation.data_collection_description">data_collection_description</a></code></li>
<li><code><a title="olca.schema.ProcessDocumentation.data_documentor" href="#olca.schema.ProcessDocumentation.data_documentor">data_documentor</a></code></li>
<li><code><a title="olca.schema.ProcessDocumentation.data_generator" href="#olca.schema.ProcessDocumentation.data_generator">data_generator</a></code></li>
<li><code><a title="olca.schema.ProcessDocumentation.data_selection_description" href="#olca.schema.ProcessDocumentation.data_selection_description">data_selection_description</a></code></li>
<li><code><a title="olca.schema.ProcessDocumentation.data_set_owner" href="#olca.schema.ProcessDocumentation.data_set_owner">data_set_owner</a></code></li>
<li><code><a title="olca.schema.ProcessDocumentation.data_treatment_description" href="#olca.schema.ProcessDocumentation.data_treatment_description">data_treatment_description</a></code></li>
<li><code><a title="olca.schema.ProcessDocumentation.from_json" href="#olca.schema.ProcessDocumentation.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.ProcessDocumentation.geography_description" href="#olca.schema.ProcessDocumentation.geography_description">geography_description</a></code></li>
<li><code><a title="olca.schema.ProcessDocumentation.intended_application" href="#olca.schema.ProcessDocumentation.intended_application">intended_application</a></code></li>
<li><code><a title="olca.schema.ProcessDocumentation.inventory_method_description" href="#olca.schema.ProcessDocumentation.inventory_method_description">inventory_method_description</a></code></li>
<li><code><a title="olca.schema.ProcessDocumentation.modeling_constants_description" href="#olca.schema.ProcessDocumentation.modeling_constants_description">modeling_constants_description</a></code></li>
<li><code><a title="olca.schema.ProcessDocumentation.olca_type" href="#olca.schema.ProcessDocumentation.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.ProcessDocumentation.project_description" href="#olca.schema.ProcessDocumentation.project_description">project_description</a></code></li>
<li><code><a title="olca.schema.ProcessDocumentation.publication" href="#olca.schema.ProcessDocumentation.publication">publication</a></code></li>
<li><code><a title="olca.schema.ProcessDocumentation.read_json" href="#olca.schema.ProcessDocumentation.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.ProcessDocumentation.restrictions_description" href="#olca.schema.ProcessDocumentation.restrictions_description">restrictions_description</a></code></li>
<li><code><a title="olca.schema.ProcessDocumentation.review_details" href="#olca.schema.ProcessDocumentation.review_details">review_details</a></code></li>
<li><code><a title="olca.schema.ProcessDocumentation.reviewer" href="#olca.schema.ProcessDocumentation.reviewer">reviewer</a></code></li>
<li><code><a title="olca.schema.ProcessDocumentation.sampling_description" href="#olca.schema.ProcessDocumentation.sampling_description">sampling_description</a></code></li>
<li><code><a title="olca.schema.ProcessDocumentation.sources" href="#olca.schema.ProcessDocumentation.sources">sources</a></code></li>
<li><code><a title="olca.schema.ProcessDocumentation.technology_description" href="#olca.schema.ProcessDocumentation.technology_description">technology_description</a></code></li>
<li><code><a title="olca.schema.ProcessDocumentation.time_description" href="#olca.schema.ProcessDocumentation.time_description">time_description</a></code></li>
<li><code><a title="olca.schema.ProcessDocumentation.to_json" href="#olca.schema.ProcessDocumentation.to_json">to_json</a></code></li>
<li><code><a title="olca.schema.ProcessDocumentation.valid_from" href="#olca.schema.ProcessDocumentation.valid_from">valid_from</a></code></li>
<li><code><a title="olca.schema.ProcessDocumentation.valid_until" href="#olca.schema.ProcessDocumentation.valid_until">valid_until</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.ProcessLink" href="#olca.schema.ProcessLink">ProcessLink</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.ProcessLink.exchange" href="#olca.schema.ProcessLink.exchange">exchange</a></code></li>
<li><code><a title="olca.schema.ProcessLink.flow" href="#olca.schema.ProcessLink.flow">flow</a></code></li>
<li><code><a title="olca.schema.ProcessLink.from_json" href="#olca.schema.ProcessLink.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.ProcessLink.olca_type" href="#olca.schema.ProcessLink.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.ProcessLink.process" href="#olca.schema.ProcessLink.process">process</a></code></li>
<li><code><a title="olca.schema.ProcessLink.provider" href="#olca.schema.ProcessLink.provider">provider</a></code></li>
<li><code><a title="olca.schema.ProcessLink.read_json" href="#olca.schema.ProcessLink.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.ProcessLink.to_json" href="#olca.schema.ProcessLink.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.ProcessType" href="#olca.schema.ProcessType">ProcessType</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.ProcessType.LCI_RESULT" href="#olca.schema.ProcessType.LCI_RESULT">LCI_RESULT</a></code></li>
<li><code><a title="olca.schema.ProcessType.UNIT_PROCESS" href="#olca.schema.ProcessType.UNIT_PROCESS">UNIT_PROCESS</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.ProductSystem" href="#olca.schema.ProductSystem">ProductSystem</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.ProductSystem.from_json" href="#olca.schema.ProductSystem.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.ProductSystem.olca_type" href="#olca.schema.ProductSystem.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.ProductSystem.parameter_sets" href="#olca.schema.ProductSystem.parameter_sets">parameter_sets</a></code></li>
<li><code><a title="olca.schema.ProductSystem.process_links" href="#olca.schema.ProductSystem.process_links">process_links</a></code></li>
<li><code><a title="olca.schema.ProductSystem.processes" href="#olca.schema.ProductSystem.processes">processes</a></code></li>
<li><code><a title="olca.schema.ProductSystem.read_json" href="#olca.schema.ProductSystem.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.ProductSystem.reference_exchange" href="#olca.schema.ProductSystem.reference_exchange">reference_exchange</a></code></li>
<li><code><a title="olca.schema.ProductSystem.reference_process" href="#olca.schema.ProductSystem.reference_process">reference_process</a></code></li>
<li><code><a title="olca.schema.ProductSystem.target_amount" href="#olca.schema.ProductSystem.target_amount">target_amount</a></code></li>
<li><code><a title="olca.schema.ProductSystem.target_flow_property" href="#olca.schema.ProductSystem.target_flow_property">target_flow_property</a></code></li>
<li><code><a title="olca.schema.ProductSystem.target_unit" href="#olca.schema.ProductSystem.target_unit">target_unit</a></code></li>
<li><code><a title="olca.schema.ProductSystem.to_json" href="#olca.schema.ProductSystem.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.Project" href="#olca.schema.Project">Project</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.Project.from_json" href="#olca.schema.Project.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.Project.impact_method" href="#olca.schema.Project.impact_method">impact_method</a></code></li>
<li><code><a title="olca.schema.Project.nw_set" href="#olca.schema.Project.nw_set">nw_set</a></code></li>
<li><code><a title="olca.schema.Project.olca_type" href="#olca.schema.Project.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.Project.read_json" href="#olca.schema.Project.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.Project.to_json" href="#olca.schema.Project.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.Ref" href="#olca.schema.Ref">Ref</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.Ref.category_path" href="#olca.schema.Ref.category_path">category_path</a></code></li>
<li><code><a title="olca.schema.Ref.flow_type" href="#olca.schema.Ref.flow_type">flow_type</a></code></li>
<li><code><a title="olca.schema.Ref.from_json" href="#olca.schema.Ref.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.Ref.library" href="#olca.schema.Ref.library">library</a></code></li>
<li><code><a title="olca.schema.Ref.location" href="#olca.schema.Ref.location">location</a></code></li>
<li><code><a title="olca.schema.Ref.olca_type" href="#olca.schema.Ref.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.Ref.process_type" href="#olca.schema.Ref.process_type">process_type</a></code></li>
<li><code><a title="olca.schema.Ref.read_json" href="#olca.schema.Ref.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.Ref.ref_unit" href="#olca.schema.Ref.ref_unit">ref_unit</a></code></li>
<li><code><a title="olca.schema.Ref.to_json" href="#olca.schema.Ref.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.RiskLevel" href="#olca.schema.RiskLevel">RiskLevel</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.RiskLevel.HIGH_OPPORTUNITY" href="#olca.schema.RiskLevel.HIGH_OPPORTUNITY">HIGH_OPPORTUNITY</a></code></li>
<li><code><a title="olca.schema.RiskLevel.HIGH_RISK" href="#olca.schema.RiskLevel.HIGH_RISK">HIGH_RISK</a></code></li>
<li><code><a title="olca.schema.RiskLevel.LOW_OPPORTUNITY" href="#olca.schema.RiskLevel.LOW_OPPORTUNITY">LOW_OPPORTUNITY</a></code></li>
<li><code><a title="olca.schema.RiskLevel.LOW_RISK" href="#olca.schema.RiskLevel.LOW_RISK">LOW_RISK</a></code></li>
<li><code><a title="olca.schema.RiskLevel.MEDIUM_OPPORTUNITY" href="#olca.schema.RiskLevel.MEDIUM_OPPORTUNITY">MEDIUM_OPPORTUNITY</a></code></li>
<li><code><a title="olca.schema.RiskLevel.MEDIUM_RISK" href="#olca.schema.RiskLevel.MEDIUM_RISK">MEDIUM_RISK</a></code></li>
<li><code><a title="olca.schema.RiskLevel.NOT_APPLICABLE" href="#olca.schema.RiskLevel.NOT_APPLICABLE">NOT_APPLICABLE</a></code></li>
<li><code><a title="olca.schema.RiskLevel.NO_DATA" href="#olca.schema.RiskLevel.NO_DATA">NO_DATA</a></code></li>
<li><code><a title="olca.schema.RiskLevel.NO_OPPORTUNITY" href="#olca.schema.RiskLevel.NO_OPPORTUNITY">NO_OPPORTUNITY</a></code></li>
<li><code><a title="olca.schema.RiskLevel.NO_RISK" href="#olca.schema.RiskLevel.NO_RISK">NO_RISK</a></code></li>
<li><code><a title="olca.schema.RiskLevel.VERY_HIGH_RISK" href="#olca.schema.RiskLevel.VERY_HIGH_RISK">VERY_HIGH_RISK</a></code></li>
<li><code><a title="olca.schema.RiskLevel.VERY_LOW_RISK" href="#olca.schema.RiskLevel.VERY_LOW_RISK">VERY_LOW_RISK</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.RootEntity" href="#olca.schema.RootEntity">RootEntity</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.RootEntity.description" href="#olca.schema.RootEntity.description">description</a></code></li>
<li><code><a title="olca.schema.RootEntity.from_json" href="#olca.schema.RootEntity.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.RootEntity.last_change" href="#olca.schema.RootEntity.last_change">last_change</a></code></li>
<li><code><a title="olca.schema.RootEntity.name" href="#olca.schema.RootEntity.name">name</a></code></li>
<li><code><a title="olca.schema.RootEntity.read_json" href="#olca.schema.RootEntity.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.RootEntity.to_json" href="#olca.schema.RootEntity.to_json">to_json</a></code></li>
<li><code><a title="olca.schema.RootEntity.version" href="#olca.schema.RootEntity.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.SimpleResult" href="#olca.schema.SimpleResult">SimpleResult</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.SimpleResult.flow_results" href="#olca.schema.SimpleResult.flow_results">flow_results</a></code></li>
<li><code><a title="olca.schema.SimpleResult.from_json" href="#olca.schema.SimpleResult.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.SimpleResult.impact_results" href="#olca.schema.SimpleResult.impact_results">impact_results</a></code></li>
<li><code><a title="olca.schema.SimpleResult.olca_type" href="#olca.schema.SimpleResult.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.SimpleResult.read_json" href="#olca.schema.SimpleResult.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.SimpleResult.to_json" href="#olca.schema.SimpleResult.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.SocialAspect" href="#olca.schema.SocialAspect">SocialAspect</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.SocialAspect.activity_value" href="#olca.schema.SocialAspect.activity_value">activity_value</a></code></li>
<li><code><a title="olca.schema.SocialAspect.comment" href="#olca.schema.SocialAspect.comment">comment</a></code></li>
<li><code><a title="olca.schema.SocialAspect.from_json" href="#olca.schema.SocialAspect.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.SocialAspect.olca_type" href="#olca.schema.SocialAspect.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.SocialAspect.quality" href="#olca.schema.SocialAspect.quality">quality</a></code></li>
<li><code><a title="olca.schema.SocialAspect.raw_amount" href="#olca.schema.SocialAspect.raw_amount">raw_amount</a></code></li>
<li><code><a title="olca.schema.SocialAspect.read_json" href="#olca.schema.SocialAspect.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.SocialAspect.risk_level" href="#olca.schema.SocialAspect.risk_level">risk_level</a></code></li>
<li><code><a title="olca.schema.SocialAspect.social_indicator" href="#olca.schema.SocialAspect.social_indicator">social_indicator</a></code></li>
<li><code><a title="olca.schema.SocialAspect.source" href="#olca.schema.SocialAspect.source">source</a></code></li>
<li><code><a title="olca.schema.SocialAspect.to_json" href="#olca.schema.SocialAspect.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.SocialIndicator" href="#olca.schema.SocialIndicator">SocialIndicator</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.SocialIndicator.activity_quantity" href="#olca.schema.SocialIndicator.activity_quantity">activity_quantity</a></code></li>
<li><code><a title="olca.schema.SocialIndicator.activity_unit" href="#olca.schema.SocialIndicator.activity_unit">activity_unit</a></code></li>
<li><code><a title="olca.schema.SocialIndicator.activity_variable" href="#olca.schema.SocialIndicator.activity_variable">activity_variable</a></code></li>
<li><code><a title="olca.schema.SocialIndicator.evaluation_scheme" href="#olca.schema.SocialIndicator.evaluation_scheme">evaluation_scheme</a></code></li>
<li><code><a title="olca.schema.SocialIndicator.from_json" href="#olca.schema.SocialIndicator.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.SocialIndicator.olca_type" href="#olca.schema.SocialIndicator.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.SocialIndicator.read_json" href="#olca.schema.SocialIndicator.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.SocialIndicator.to_json" href="#olca.schema.SocialIndicator.to_json">to_json</a></code></li>
<li><code><a title="olca.schema.SocialIndicator.unit_of_measurement" href="#olca.schema.SocialIndicator.unit_of_measurement">unit_of_measurement</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.Source" href="#olca.schema.Source">Source</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.Source.external_file" href="#olca.schema.Source.external_file">external_file</a></code></li>
<li><code><a title="olca.schema.Source.from_json" href="#olca.schema.Source.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.Source.olca_type" href="#olca.schema.Source.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.Source.read_json" href="#olca.schema.Source.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.Source.text_reference" href="#olca.schema.Source.text_reference">text_reference</a></code></li>
<li><code><a title="olca.schema.Source.to_json" href="#olca.schema.Source.to_json">to_json</a></code></li>
<li><code><a title="olca.schema.Source.url" href="#olca.schema.Source.url">url</a></code></li>
<li><code><a title="olca.schema.Source.year" href="#olca.schema.Source.year">year</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.Uncertainty" href="#olca.schema.Uncertainty">Uncertainty</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.Uncertainty.distribution_type" href="#olca.schema.Uncertainty.distribution_type">distribution_type</a></code></li>
<li><code><a title="olca.schema.Uncertainty.from_json" href="#olca.schema.Uncertainty.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.Uncertainty.geom_mean" href="#olca.schema.Uncertainty.geom_mean">geom_mean</a></code></li>
<li><code><a title="olca.schema.Uncertainty.geom_mean_formula" href="#olca.schema.Uncertainty.geom_mean_formula">geom_mean_formula</a></code></li>
<li><code><a title="olca.schema.Uncertainty.geom_sd" href="#olca.schema.Uncertainty.geom_sd">geom_sd</a></code></li>
<li><code><a title="olca.schema.Uncertainty.geom_sd_formula" href="#olca.schema.Uncertainty.geom_sd_formula">geom_sd_formula</a></code></li>
<li><code><a title="olca.schema.Uncertainty.maximum" href="#olca.schema.Uncertainty.maximum">maximum</a></code></li>
<li><code><a title="olca.schema.Uncertainty.maximum_formula" href="#olca.schema.Uncertainty.maximum_formula">maximum_formula</a></code></li>
<li><code><a title="olca.schema.Uncertainty.mean" href="#olca.schema.Uncertainty.mean">mean</a></code></li>
<li><code><a title="olca.schema.Uncertainty.mean_formula" href="#olca.schema.Uncertainty.mean_formula">mean_formula</a></code></li>
<li><code><a title="olca.schema.Uncertainty.minimum" href="#olca.schema.Uncertainty.minimum">minimum</a></code></li>
<li><code><a title="olca.schema.Uncertainty.minimum_formula" href="#olca.schema.Uncertainty.minimum_formula">minimum_formula</a></code></li>
<li><code><a title="olca.schema.Uncertainty.mode" href="#olca.schema.Uncertainty.mode">mode</a></code></li>
<li><code><a title="olca.schema.Uncertainty.mode_formula" href="#olca.schema.Uncertainty.mode_formula">mode_formula</a></code></li>
<li><code><a title="olca.schema.Uncertainty.olca_type" href="#olca.schema.Uncertainty.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.Uncertainty.read_json" href="#olca.schema.Uncertainty.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.Uncertainty.sd" href="#olca.schema.Uncertainty.sd">sd</a></code></li>
<li><code><a title="olca.schema.Uncertainty.sd_formula" href="#olca.schema.Uncertainty.sd_formula">sd_formula</a></code></li>
<li><code><a title="olca.schema.Uncertainty.to_json" href="#olca.schema.Uncertainty.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.UncertaintyType" href="#olca.schema.UncertaintyType">UncertaintyType</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.UncertaintyType.LOG_NORMAL_DISTRIBUTION" href="#olca.schema.UncertaintyType.LOG_NORMAL_DISTRIBUTION">LOG_NORMAL_DISTRIBUTION</a></code></li>
<li><code><a title="olca.schema.UncertaintyType.NORMAL_DISTRIBUTION" href="#olca.schema.UncertaintyType.NORMAL_DISTRIBUTION">NORMAL_DISTRIBUTION</a></code></li>
<li><code><a title="olca.schema.UncertaintyType.TRIANGLE_DISTRIBUTION" href="#olca.schema.UncertaintyType.TRIANGLE_DISTRIBUTION">TRIANGLE_DISTRIBUTION</a></code></li>
<li><code><a title="olca.schema.UncertaintyType.UNIFORM_DISTRIBUTION" href="#olca.schema.UncertaintyType.UNIFORM_DISTRIBUTION">UNIFORM_DISTRIBUTION</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.Unit" href="#olca.schema.Unit">Unit</a></code></h4>
<ul class="two-column">
<li><code><a title="olca.schema.Unit.conversion_factor" href="#olca.schema.Unit.conversion_factor">conversion_factor</a></code></li>
<li><code><a title="olca.schema.Unit.from_json" href="#olca.schema.Unit.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.Unit.olca_type" href="#olca.schema.Unit.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.Unit.read_json" href="#olca.schema.Unit.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.Unit.reference_unit" href="#olca.schema.Unit.reference_unit">reference_unit</a></code></li>
<li><code><a title="olca.schema.Unit.synonyms" href="#olca.schema.Unit.synonyms">synonyms</a></code></li>
<li><code><a title="olca.schema.Unit.to_json" href="#olca.schema.Unit.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olca.schema.UnitGroup" href="#olca.schema.UnitGroup">UnitGroup</a></code></h4>
<ul class="">
<li><code><a title="olca.schema.UnitGroup.default_flow_property" href="#olca.schema.UnitGroup.default_flow_property">default_flow_property</a></code></li>
<li><code><a title="olca.schema.UnitGroup.from_json" href="#olca.schema.UnitGroup.from_json">from_json</a></code></li>
<li><code><a title="olca.schema.UnitGroup.olca_type" href="#olca.schema.UnitGroup.olca_type">olca_type</a></code></li>
<li><code><a title="olca.schema.UnitGroup.read_json" href="#olca.schema.UnitGroup.read_json">read_json</a></code></li>
<li><code><a title="olca.schema.UnitGroup.to_json" href="#olca.schema.UnitGroup.to_json">to_json</a></code></li>
<li><code><a title="olca.schema.UnitGroup.units" href="#olca.schema.UnitGroup.units">units</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>